-- Squashed baseline migration
-- Generated: 2026-01-21
-- Source migrations concatenated (in lexicographic order):
--   - 0001_baseline_schema.sql
--   - 0002_rls_policies.sql
--   - 0003_functions_triggers.sql
--   - 0004_stripe_marketplace.sql
--   - 0005_indexes_performance.sql
--   - 0006_job_lifecycle.sql
--   - 0007_job_lifecycle_functions.sql
--   - 0008_quotes_customer_update.sql
--   - 0009_notify_user_function.sql
--   - 0010_trust_system.sql
--   - 0011_trust_system_rls.sql
--   - 0013_update_profile_card.sql
--   - 0014_seed_data.sql
--   - 0015_job_lifecycle_rls.sql
--   - 0016_cleanup_and_validation.sql
--   - 0017_fix_duplicate_contract_and_cancel_quote.sql
--   - 0018_job_lifecycle_triggers.sql
--   - 0019_trust_system_enhancements.sql
--   - 0020_trust_system_functions.sql
--   - 0021_badge_awarding_system.sql
--   - 0022_trust_system_triggers.sql
--   - 0023_financial_visibility_system.sql
--   - 0024_job_lifecycle_hardening.sql
--   - 0025_fix_rating_column_references.sql
--   - 0026_earnings_rpcs.sql
--   - 0027_invitation_promo_system.sql
--   - 0028_grant_service_role_promo.sql
--   - 0029_payment_method_enforcement.sql
--   - 0030_payment_rls_enforcement.sql
--   - 0031_service_area_enforcement.sql
--   - 0032_invite_system.sql
--   - 0033_add_deleted_reason.sql
--   - 0034_add_deletion_columns.sql
--   - 0035_add_preferred_time_to_job_rpc.sql
--   - 0036_promo_system_enhancements.sql
--   - 0037_promo_validate_function.sql
--   - 0038_promo_apply_function.sql
--   - 0039_promo_helper_function.sql
--   - 0040_promo_grants.sql
--   - 0041_promo_grants2.sql
--   - 0042_promo_grants3.sql
--   - 0043_fix_avatar_storage_policy.sql
--   - 0044_fix_mechanic_quote_check.sql
--   - 0045_fix_quote_upsert.sql
--   - 0046_fix_profile_card_reviews.sql
--   - 0047_chat_moderation_system.sql
--   - 0048_chat_moderation_rpcs.sql
--   - 0049_support_phase1.sql
--   - 0050_fix_quote_rejected_status.sql
--   - 0051_add_payout_method_status.sql
--   - 0052_fix_log_message_audit_mechanic_id.sql
--   - 0053_fix_log_message_audit_patterns.sql
--   - 0054_fix_job_stage_values.sql
--   - 0055_fix_phone_detection.sql
--   - 0056_fix_phone_detection_v2.sql
--   - 0057_always_block_contact_info.sql
--   - 0060_postgis_service_areas.sql
--   - 0061_hardened_get_mechanic_leads.sql
--   - 0062_properly_hardened_get_mechanic_leads.sql
--   - 0063_fix_postgis_optional.sql
--   - 0064_rating_prompt_system.sql
--   - 0065_fix_postgis_optional.sql
--   - 0068_fix_job_status_enum.sql
--   - 0069_update_invite_rewards.sql
--   - 0070_fix_cancel_job_for_update.sql
--   - 0071_add_payout_method_status.sql
--   - 0073_chat_attachments.sql
--   - 0074_make_chat_attachments_public.sql
--   - 0075_fix_accept_quote_for_retry.sql
--   - 0076_fix_invitation_awards_constraint.sql
--   - 0077_add_gross_earnings_to_summary.sql
--   - 0078_fix_referral_immediate_reward.sql
--   - 0079_update_submit_review_ratings.sql
--   - 0080_update_get_public_profile_card.sql
--   - 0081_service_hubs.sql
--   - 0082_fix_launch_metrics_mechanic_count.sql
--   - 0083_add_customers_to_launch_metrics.sql
--   - 0084_add_check_mechanic_service_area.sql
--   - 0085_add_check_customer_service_area.sql
--   - 0086_add_get_nearest_hub.sql
--   - 0087_service_hubs.sql
--   - 0088_service_hubs.sql
--   - 0089_create_get_public_profile_card.sql
--   - 0090_create_get_public_profile_card.sql
--   - 0091_fix_messages_rls.sql
--   - 0125_add_admin_role_enum.sql
--   - 0126_job_media_photo_evidence.sql
--   - 0127_mechanic_tier_admin_rpcs.sql
--   - 0128_admin_customer_rpcs.sql
--   - 20260111000008_promo_credit_tracking.sql
--   - 20260111000009_sync_job_progress.sql
--   - 20260111000010_use_payment_promo_applications.sql
--   - 20260111000011_fix_review_prompts_completed.sql
--   - 20260111000012_retroactive_promo_apply.sql
--   - 20260111000013_fix_retroactive_promo.sql
--   - 20260111000014_add_symptom_to_create_job.sql
--   - 20260111000015_mechanic_verification_phase1.sql
--   - 20260111000016_fix_admin_verifications_rpc.sql
--   - 20260111000017_fix_mechanic_leads_overload.sql
--   - 20260111000018_create_verification_bucket.sql
--   - 20260111000019_mechanic_verification_selfie_patch.sql
--   - 20260111000020_fix_verification_storage_policies.sql
--   - 20260111000021_fix_mechanic_leads_urgency.sql
--   - 20260111000022_fix_mechanic_leads_vehicles.sql
--   - 20260111000023_fix_mechanic_leads_status.sql
--   - 20260112000001_mechanic_verification_phase2.sql
--   - 20260112000002_fix_mechanic_leads_alias.sql
--   - 20260112000003_fix_create_job_symptom_id.sql
--   - 20260113000001_phase3_disputes_chat_enforcement.sql
--   - 20260117000001_fix_mechanic_leads_quoted_filter.sql
--   - 20260117000002_fix_mechanic_leads_statuses.sql
--   - 20260117000003_fix_mechanic_leads_cast.sql
--   - 20260117000004_fix_leads_summary.sql
--   - 20260118000001_dispute_notify_mechanic.sql
--   - 20260118000002_dispute_notify_customer_on_response.sql
--   - 20260118000003_add_admin_role_enum.sql
--   - 20260119000001_fix_profile_card_job_count.sql
--   - 20260120000001_phase4_admin_audit_metrics.sql
--   - 20260120000002_fix_is_admin.sql
--   - 20260120000003_fix_support_requests_rpc.sql
--   - 20260120000004_fix_admin_schema_mismatches.sql
--   - 20260120000006_fix_admin_rpcs.sql
--   - 20260120000007_phase41_support_customers_rpcs.sql
--   - 20260120000008_phase41_fix_pack.sql
--   - 20260120000009_phase42_fix_pack.sql
--   - 20260120000010_platform_terms_phase45.sql
--   - 20260121000001_fix_create_job_sets_job_lat_lng.sql
--   - 20260121000001_fix_job_location_hub_and_escrow.sql
--   - 20260121000002_accept_quote_pending_payment.sql
--   - 20260121000003_set_user_service_area_by_zip.sql
--   - 20260121000004_add_stripe_webhook_events.sql
--   - 20260125000001_data_integrity_repair.sql
--   - 20260125000002_has_used_referral.sql
--   - 20260125000003_fix_admin_tier_defaults.sql
--   - 20260126000001_mechanic_promo_auto_apply.sql
--   - 20260126000002_add_mechanic_promo_event_type.sql
--   - 20260127000001_admin_messaging.sql
--   - 20260127000002_create_storage_buckets.sql
--   - 20260127000003_add_media_uploaded_event_type.sql
--   - 20260127000004_fix_job_media_event_title.sql
--   - 20260127000005_fix_job_media_function_overload.sql
--   - 20260127000006_add_mechanic_verification_tier.sql
--   - 20260127000007_fix_admin_mechanics_no_hubs.sql
--   - 20260127000008_fix_admin_list_customers_payment_status.sql
--   - 20260127000009_fix_profile_card_verification_source.sql
--   - 20260127000010_trust_score_system_complete.sql
--   - 20260127000011_fix_trust_trigger_enum.sql
--   - 20260127000012_fix_trust_score_trigger_permission.sql
--   - 20260127000013_fix_submit_review_finalized.sql
--   - 20260127000014_safe_review_trigger.sql
--   - 20260127000015_add_reviews_unique_constraint.sql
--   - 20260127000016_fix_review_prompts_completion.sql
--   - 20260127000017_mechanic_skills_rollup.sql
--   - 20260128000001_fix_admin_message_audit.sql
--   - 20260129000001_add_admin_message_event_type.sql
--   - 20260130000001_no_double_booking.sql
--   - 20260130000002_fix_mark_admin_message_read.sql
--   - 20260131000001_support_thread_replies.sql
--   - 20260131000002_support_threads_list.sql
--   - 20260201000001_admin_hub_scoping.sql
--   - 20260201000002_admin_messaging_rpcs.sql
--   - 20260202000001_fix_commission_calculation.sql
--   - 20260202000002_admin_hub_update_permission.sql
--   - 20260203000001_mandatory_review_system.sql
--   - 20260203000002_hub_recommendations_rpc.sql
--   - 20260203000003_fix_hub_recommendations_rpc.sql
--   - 20260203000004_service_hubs_insert_policy.sql
--   - 20260204000001_user_location_and_hub_assignment.sql
--   - 20260204000002_set_my_service_area.sql
--   - 20260204000003_align_payments_for_edge_functions.sql
--   - 20260204000004_contract_pending_payment_on_quote_accept.sql
--   - 20260204000004_payment_escrow_and_webhook_hardening.sql
--   - 20260204000005_fix_jobs_location_and_hub_assignment.sql
--   - 20260204000015_public_hub_stats.sql
--   - 20260205000001_public_hubs_rpc.sql
--   - 20260205000002_waitlist_rls_hardening.sql
--   - 20260205000003_vehicle_rls_mechanic_admin_select.sql
--   - 20260205000004_mechanic_customer_notes.sql
--   - 20260301000001_fix_set_my_service_area_home_lat.sql
--   - 20260301000002_mechanic_notes_and_media_geo.sql
--   - 20260301000002_waitlist_rls.sql
--   - 20260301000003_public_hub_stats.sql
--   - 20260302000001_quote_proposed_time_support.sql

\n\n-- ===================================================================
-- BEGIN: 0001_baseline_schema.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0001: BASELINE SCHEMA
-- =====================================================
-- Purpose: Extensions, enums, and ALL tables
-- Run: First migration - no dependencies
-- =====================================================

BEGIN;

-- =====================================================
-- EXTENSIONS
-- =====================================================
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;
CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA extensions;
CREATE EXTENSION IF NOT EXISTS "postgis" WITH SCHEMA extensions;

-- =====================================================
-- ENUMS
-- =====================================================
DO $$ BEGIN
  CREATE TYPE public.user_role AS ENUM ('customer', 'mechanic');
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  CREATE TYPE public.theme_mode AS ENUM ('light', 'dark', 'system');
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  CREATE TYPE public.job_status AS ENUM (
    'draft',
    'searching',
    'quoted',
    'accepted',
    'scheduled',
    'in_progress',
    'work_in_progress',
    'completed',
    'cancelled',
    'disputed'
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  CREATE TYPE public.quote_status AS ENUM (
    'pending',
    'accepted',
    'rejected',
    'expired',
    'withdrawn'
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  CREATE TYPE public.payment_status AS ENUM (
    'pending',
    'processing',
    'succeeded',
    'failed',
    'refunded',
    'partially_refunded'
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- =====================================================
-- TABLE: profiles
-- =====================================================
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email text,
  full_name text,
  display_name text,
  phone text,
  avatar_url text,
  role public.user_role,
  theme_preference public.theme_mode DEFAULT 'system',
  city text,
  state text,
  home_lat double precision,
  home_lng double precision,
  push_token text,
  deleted_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.profiles IS 'User profiles for both customers and mechanics';

-- =====================================================
-- TABLE: vehicles
-- =====================================================
CREATE TABLE IF NOT EXISTS public.vehicles (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  year int,
  make text,
  model text,
  nickname text,
  vin text,
  license_plate text,
  color text,
  notes text,
  deleted_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,

  CONSTRAINT vehicles_year_check CHECK (year IS NULL OR (year >= 1900 AND year <= 2100))
);

COMMENT ON TABLE public.vehicles IS 'Customer vehicles';

-- =====================================================
-- TABLE: jobs
-- =====================================================
CREATE TABLE IF NOT EXISTS public.jobs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  vehicle_id uuid REFERENCES public.vehicles(id) ON DELETE SET NULL,
  accepted_mechanic_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
  title text NOT NULL,
  description text,
  status public.job_status DEFAULT 'draft' NOT NULL,
  symptom_key text,
  symptom_id text,
  location_lat double precision,
  location_lng double precision,
  location_address text,
  preferred_time text,
  scheduled_at timestamptz,
  completed_at timestamptz,
  cancelled_at timestamptz,
  canceled_at timestamptz,
  canceled_by uuid REFERENCES public.profiles(id),
  final_price_cents int,
  deleted_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,

  CONSTRAINT jobs_positive_price CHECK (final_price_cents IS NULL OR final_price_cents >= 0)
);

COMMENT ON TABLE public.jobs IS 'Service jobs/requests from customers';

-- =====================================================
-- TABLE: quote_requests
-- =====================================================
CREATE TABLE IF NOT EXISTS public.quote_requests (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  customer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  status public.quote_status DEFAULT 'pending' NOT NULL,
  price_cents int,
  message text,
  notes text,
  expires_at timestamptz,
  responded_at timestamptz,
  accepted_at timestamptz,
  rejected_at timestamptz,
  canceled_at timestamptz,
  canceled_by uuid REFERENCES public.profiles(id),
  cancel_reason text,
  cancel_note text,
  cancellation_fee_cents int,
  deleted_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,

  CONSTRAINT quote_requests_positive_price CHECK (price_cents IS NULL OR price_cents >= 0)
);

COMMENT ON TABLE public.quote_requests IS 'Quotes from mechanics for jobs';

-- =====================================================
-- TABLE: quotes
-- =====================================================
CREATE TABLE IF NOT EXISTS public.quotes (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  price_cents int,
  estimated_hours numeric,
  notes text,
  status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'declined', 'expired', 'withdrawn')),
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,

  UNIQUE(job_id, mechanic_id)
);

COMMENT ON TABLE public.quotes IS 'Mechanic quotes for jobs';

-- =====================================================
-- TABLE: reviews
-- =====================================================
CREATE TABLE IF NOT EXISTS public.reviews (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  reviewer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reviewee_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reviewer_role public.user_role,
  overall_rating int NOT NULL,
  performance_rating int,
  timing_rating int,
  cost_rating int,
  comment text,
  is_hidden boolean DEFAULT false,
  deleted_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,

  CONSTRAINT reviews_overall_rating_range CHECK (overall_rating >= 1 AND overall_rating <= 5),
  CONSTRAINT reviews_performance_rating_range CHECK (performance_rating IS NULL OR (performance_rating >= 1 AND performance_rating <= 5)),
  CONSTRAINT reviews_timing_rating_range CHECK (timing_rating IS NULL OR (timing_rating >= 1 AND timing_rating <= 5)),
  CONSTRAINT reviews_cost_rating_range CHECK (cost_rating IS NULL OR (cost_rating >= 1 AND cost_rating <= 5)),
  UNIQUE(job_id, reviewer_id)
);

COMMENT ON TABLE public.reviews IS 'Reviews between users after job completion';

-- =====================================================
-- TABLE: mechanic_profiles
-- =====================================================
CREATE TABLE IF NOT EXISTS public.mechanic_profiles (
  id uuid PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  bio text,
  years_experience int,
  hourly_rate_cents int,
  service_radius_km double precision DEFAULT 50,
  mobile_service boolean DEFAULT true,
  is_available boolean DEFAULT true,
  rating_avg numeric(3,2) DEFAULT 0.00,
  rating_count int DEFAULT 0,
  jobs_completed int DEFAULT 0,
  stripe_account_id text,
  stripe_onboarding_complete boolean DEFAULT false,
  deleted_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  
  CONSTRAINT mechanic_profiles_positive_rate CHECK (hourly_rate_cents IS NULL OR hourly_rate_cents >= 0),
  CONSTRAINT mechanic_profiles_valid_rating CHECK (rating_avg >= 0 AND rating_avg <= 5)
);

COMMENT ON TABLE public.mechanic_profiles IS 'Extended profile for mechanics';

-- =====================================================
-- LOOKUP TABLE: skills
-- =====================================================
CREATE TABLE IF NOT EXISTS public.skills (
  key text PRIMARY KEY,
  label text NOT NULL,
  category text,
  created_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.skills IS 'Master lookup table for mechanic skills';

-- =====================================================
-- LOOKUP TABLE: tools
-- =====================================================
CREATE TABLE IF NOT EXISTS public.tools (
  key text PRIMARY KEY,
  label text NOT NULL,
  category text,
  created_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.tools IS 'Master lookup table for mechanic tools';

-- =====================================================
-- LOOKUP TABLE: safety_measures
-- =====================================================
CREATE TABLE IF NOT EXISTS public.safety_measures (
  key text PRIMARY KEY,
  label text NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.safety_measures IS 'Master lookup table for safety measures';

-- =====================================================
-- TABLE: mechanic_skills (junction)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.mechanic_skills (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  skill_key text NOT NULL REFERENCES public.skills(key) ON DELETE CASCADE,
  created_at timestamptz DEFAULT now() NOT NULL,
  
  UNIQUE(mechanic_id, skill_key)
);

COMMENT ON TABLE public.mechanic_skills IS 'Skills a mechanic has';

-- =====================================================
-- TABLE: mechanic_tools (junction)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.mechanic_tools (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  tool_key text NOT NULL REFERENCES public.tools(key) ON DELETE CASCADE,
  created_at timestamptz DEFAULT now() NOT NULL,
  
  UNIQUE(mechanic_id, tool_key)
);

COMMENT ON TABLE public.mechanic_tools IS 'Tools a mechanic has';

-- =====================================================
-- TABLE: mechanic_safety (junction)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.mechanic_safety (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  safety_key text NOT NULL REFERENCES public.safety_measures(key) ON DELETE CASCADE,
  created_at timestamptz DEFAULT now() NOT NULL,
  
  UNIQUE(mechanic_id, safety_key)
);

COMMENT ON TABLE public.mechanic_safety IS 'Safety measures a mechanic follows';

-- =====================================================
-- TABLE: symptoms
-- =====================================================
CREATE TABLE IF NOT EXISTS public.symptoms (
  key text PRIMARY KEY,
  label text NOT NULL,
  icon text,
  created_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.symptoms IS 'Master list of vehicle symptoms';

-- =====================================================
-- TABLE: symptom_mappings
-- =====================================================
CREATE TABLE IF NOT EXISTS public.symptom_mappings (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  symptom_key text UNIQUE NOT NULL REFERENCES public.symptoms(key) ON DELETE CASCADE,
  symptom_label text NOT NULL,
  category text NOT NULL,
  risk_level text NOT NULL,
  quote_strategy text,
  customer_explainer text,
  mechanic_notes text,
  required_skill_keys text[] DEFAULT '{}',
  suggested_tool_keys text[] DEFAULT '{}',
  required_safety_keys text[] DEFAULT '{}',
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.symptom_mappings IS 'Detailed symptom information for jobs';

-- =====================================================
-- TABLE: education_cards
-- =====================================================
CREATE TABLE IF NOT EXISTS public.education_cards (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  symptom_key text NOT NULL REFERENCES public.symptoms(key) ON DELETE CASCADE,
  card_key text NOT NULL,
  title text NOT NULL,
  summary text,
  why_it_happens text,
  what_we_check text,
  is_it_safe text,
  prep_before_visit text,
  quote_expectation text,
  red_flags text,
  order_index int DEFAULT 1,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  
  UNIQUE(symptom_key, card_key)
);

COMMENT ON TABLE public.education_cards IS 'Education cards for symptoms';

-- =====================================================
-- TABLE: symptom_education
-- =====================================================
CREATE TABLE IF NOT EXISTS public.symptom_education (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  symptom_key text UNIQUE NOT NULL REFERENCES public.symptoms(key) ON DELETE CASCADE,
  title text NOT NULL,
  summary text,
  is_it_safe text,
  what_we_check text,
  how_quotes_work text,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.symptom_education IS 'Education guides for symptoms';

-- =====================================================
-- TABLE: symptom_questions
-- =====================================================
CREATE TABLE IF NOT EXISTS public.symptom_questions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  symptom_key text NOT NULL REFERENCES public.symptoms(key) ON DELETE CASCADE,
  question_key text NOT NULL,
  question_text text NOT NULL,
  question_type text NOT NULL,
  options jsonb,
  affects_safety boolean DEFAULT false,
  affects_quote boolean DEFAULT false,
  display_order int DEFAULT 1,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  
  UNIQUE(symptom_key, question_key)
);

COMMENT ON TABLE public.symptom_questions IS 'Diagnostic questions for symptoms';

-- =====================================================
-- TABLE: messages
-- =====================================================
CREATE TABLE IF NOT EXISTS public.messages (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  recipient_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  body text NOT NULL,
  read_at timestamptz,
  deleted_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.messages IS 'Messages between users for a job';

-- =====================================================
-- TABLE: notifications
-- =====================================================
CREATE TABLE IF NOT EXISTS public.notifications (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  title text NOT NULL,
  body text,
  type text,
  entity_type text,
  entity_id uuid,
  data jsonb DEFAULT '{}',
  is_read boolean DEFAULT false NOT NULL,
  read_at timestamptz,
  deleted_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.notifications IS 'User notifications';

-- =====================================================
-- TABLE: media_assets
-- =====================================================
CREATE TABLE IF NOT EXISTS public.media_assets (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  key text UNIQUE,
  bucket text DEFAULT 'media',
  path text,
  public_url text,
  content_type text,
  size_bytes bigint,
  duration_seconds double precision,
  uploaded_by uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
  job_id uuid REFERENCES public.jobs(id) ON DELETE SET NULL,
  deleted_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.media_assets IS 'Media files (images, videos) for jobs and app content';

-- =====================================================
-- TABLE: mechanic_stripe_accounts
-- =====================================================
CREATE TABLE IF NOT EXISTS public.mechanic_stripe_accounts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  mechanic_id uuid UNIQUE NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  stripe_account_id text UNIQUE NOT NULL,
  onboarding_complete boolean DEFAULT false,
  charges_enabled boolean DEFAULT false,
  payouts_enabled boolean DEFAULT false,
  deleted_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.mechanic_stripe_accounts IS 'Stripe Connect accounts for mechanics';

-- =====================================================
-- TABLE: customer_payment_methods
-- =====================================================
CREATE TABLE IF NOT EXISTS public.customer_payment_methods (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  stripe_customer_id text,
  stripe_payment_method_id text UNIQUE NOT NULL,
  is_default boolean DEFAULT false,
  card_brand text,
  card_last4 text,
  card_exp_month int,
  card_exp_year int,
  deleted_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.customer_payment_methods IS 'Saved payment methods for customers';

-- =====================================================
-- TABLE: payments
-- =====================================================
CREATE TABLE IF NOT EXISTS public.payments (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  customer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  stripe_payment_intent_id text UNIQUE,
  amount_cents int NOT NULL,
  platform_fee_cents int DEFAULT 0,
  status public.payment_status DEFAULT 'pending' NOT NULL,
  paid_at timestamptz,
  refunded_at timestamptz,
  deleted_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  
  CONSTRAINT payments_positive_amount CHECK (amount_cents > 0)
);

COMMENT ON TABLE public.payments IS 'Payment records for jobs';

-- =====================================================
-- TABLE: badges
-- =====================================================
CREATE TABLE IF NOT EXISTS public.badges (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code text UNIQUE NOT NULL,
  title text NOT NULL,
  description text,
  icon text,
  badge_type text DEFAULT 'achievement',
  criteria_json jsonb,
  created_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.badges IS 'Master lookup table for badges';

-- =====================================================
-- TABLE: user_badges
-- =====================================================
CREATE TABLE IF NOT EXISTS public.user_badges (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  badge_id uuid NOT NULL REFERENCES public.badges(id) ON DELETE CASCADE,
  source text,
  awarded_at timestamptz DEFAULT now() NOT NULL,
  expires_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,

  UNIQUE(user_id, badge_id)
);

COMMENT ON TABLE public.user_badges IS 'Badges awarded to users';

COMMIT;
\n-- ===================================================================
-- END: 0001_baseline_schema.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0002_rls_policies.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0002: RLS POLICIES
-- =====================================================
-- Purpose: Enable RLS and create all security policies
-- Depends on: 0001_baseline_schema.sql
-- =====================================================

BEGIN;

-- =====================================================
-- ENABLE RLS ON ALL TABLES
-- =====================================================
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.vehicles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.quote_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.quotes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.mechanic_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.skills ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tools ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.safety_measures ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.mechanic_skills ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.mechanic_tools ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.mechanic_safety ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.symptoms ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.symptom_mappings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.education_cards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.symptom_education ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.symptom_questions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.media_assets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.mechanic_stripe_accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.customer_payment_methods ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- SCHEMA GRANTS
-- =====================================================
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT USAGE ON SCHEMA public TO anon;
GRANT USAGE ON SCHEMA public TO service_role;

-- =====================================================
-- TABLE GRANTS (authenticated users)
-- =====================================================
GRANT SELECT, INSERT, UPDATE, DELETE ON public.profiles TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.vehicles TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.jobs TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.quote_requests TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.quotes TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.reviews TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.mechanic_profiles TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.mechanic_skills TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.mechanic_tools TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.mechanic_safety TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.messages TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.notifications TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.media_assets TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.mechanic_stripe_accounts TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.customer_payment_methods TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.payments TO authenticated;

-- Read-only lookup tables
GRANT SELECT ON public.skills TO authenticated;
GRANT SELECT ON public.tools TO authenticated;
GRANT SELECT ON public.safety_measures TO authenticated;
GRANT SELECT ON public.symptoms TO authenticated;
GRANT SELECT ON public.symptom_mappings TO authenticated;
GRANT SELECT ON public.education_cards TO authenticated;
GRANT SELECT ON public.symptom_education TO authenticated;
GRANT SELECT ON public.symptom_questions TO authenticated;

-- Anon access for public content
GRANT SELECT ON public.media_assets TO anon;
GRANT SELECT ON public.symptoms TO anon;
GRANT SELECT ON public.symptom_mappings TO anon;

-- =====================================================
-- TABLE GRANTS (service_role - for edge functions)
-- =====================================================
GRANT ALL ON public.profiles TO service_role;
GRANT ALL ON public.vehicles TO service_role;
GRANT ALL ON public.jobs TO service_role;
GRANT ALL ON public.quote_requests TO service_role;
GRANT ALL ON public.reviews TO service_role;
GRANT ALL ON public.mechanic_profiles TO service_role;
GRANT ALL ON public.mechanic_skills TO service_role;
GRANT ALL ON public.mechanic_tools TO service_role;
GRANT ALL ON public.mechanic_safety TO service_role;
GRANT ALL ON public.messages TO service_role;
GRANT ALL ON public.notifications TO service_role;
GRANT ALL ON public.media_assets TO service_role;
GRANT ALL ON public.mechanic_stripe_accounts TO service_role;
GRANT ALL ON public.customer_payment_methods TO service_role;
GRANT ALL ON public.payments TO service_role;
GRANT ALL ON public.skills TO service_role;
GRANT ALL ON public.tools TO service_role;
GRANT ALL ON public.safety_measures TO service_role;
GRANT ALL ON public.symptoms TO service_role;
GRANT ALL ON public.symptom_mappings TO service_role;
GRANT ALL ON public.education_cards TO service_role;
GRANT ALL ON public.symptom_education TO service_role;
GRANT ALL ON public.symptom_questions TO service_role;

-- =====================================================
-- PROFILES POLICIES
-- User can read their own profile always
-- User can read other profiles with a role set (public directory)
-- User can only update their own profile
-- =====================================================
DROP POLICY IF EXISTS "profiles_select_own" ON public.profiles;
CREATE POLICY "profiles_select_own" ON public.profiles
  FOR SELECT TO authenticated
  USING (id = auth.uid());

DROP POLICY IF EXISTS "profiles_select_public" ON public.profiles;
CREATE POLICY "profiles_select_public" ON public.profiles
  FOR SELECT TO authenticated
  USING (role IS NOT NULL AND deleted_at IS NULL);

DROP POLICY IF EXISTS "profiles_insert_own" ON public.profiles;
CREATE POLICY "profiles_insert_own" ON public.profiles
  FOR INSERT TO authenticated
  WITH CHECK (id = auth.uid());

DROP POLICY IF EXISTS "profiles_update_own" ON public.profiles;
CREATE POLICY "profiles_update_own" ON public.profiles
  FOR UPDATE TO authenticated
  USING (id = auth.uid())
  WITH CHECK (id = auth.uid());

-- =====================================================
-- VEHICLES POLICIES (owner only)
-- =====================================================
DROP POLICY IF EXISTS "vehicles_all_own" ON public.vehicles;
CREATE POLICY "vehicles_all_own" ON public.vehicles
  FOR ALL TO authenticated
  USING (customer_id = auth.uid())
  WITH CHECK (customer_id = auth.uid());

-- =====================================================
-- JOBS POLICIES
-- Customer can see their own jobs
-- Mechanic can see jobs they're assigned to
-- Mechanics can see jobs in searching/quoted status (leads)
-- =====================================================
DROP POLICY IF EXISTS "jobs_select_involved" ON public.jobs;
CREATE POLICY "jobs_select_involved" ON public.jobs
  FOR SELECT TO authenticated
  USING (
    customer_id = auth.uid() 
    OR accepted_mechanic_id = auth.uid()
    OR status IN ('searching', 'quoted')
  );

DROP POLICY IF EXISTS "jobs_insert_customer" ON public.jobs;
CREATE POLICY "jobs_insert_customer" ON public.jobs
  FOR INSERT TO authenticated
  WITH CHECK (customer_id = auth.uid());

DROP POLICY IF EXISTS "jobs_update_involved" ON public.jobs;
CREATE POLICY "jobs_update_involved" ON public.jobs
  FOR UPDATE TO authenticated
  USING (customer_id = auth.uid() OR accepted_mechanic_id = auth.uid())
  WITH CHECK (customer_id = auth.uid() OR accepted_mechanic_id = auth.uid());

DROP POLICY IF EXISTS "jobs_delete_own" ON public.jobs;
CREATE POLICY "jobs_delete_own" ON public.jobs
  FOR DELETE TO authenticated
  USING (customer_id = auth.uid());

-- =====================================================
-- QUOTE_REQUESTS POLICIES
-- =====================================================
DROP POLICY IF EXISTS "quote_requests_select_involved" ON public.quote_requests;
CREATE POLICY "quote_requests_select_involved" ON public.quote_requests
  FOR SELECT TO authenticated
  USING (customer_id = auth.uid() OR mechanic_id = auth.uid());

DROP POLICY IF EXISTS "quote_requests_insert_mechanic" ON public.quote_requests;
CREATE POLICY "quote_requests_insert_mechanic" ON public.quote_requests
  FOR INSERT TO authenticated
  WITH CHECK (mechanic_id = auth.uid());

DROP POLICY IF EXISTS "quote_requests_update_involved" ON public.quote_requests;
CREATE POLICY "quote_requests_update_involved" ON public.quote_requests
  FOR UPDATE TO authenticated
  USING (customer_id = auth.uid() OR mechanic_id = auth.uid())
  WITH CHECK (customer_id = auth.uid() OR mechanic_id = auth.uid());

-- =====================================================
-- REVIEWS POLICIES
-- =====================================================
DROP POLICY IF EXISTS "reviews_select_public" ON public.reviews;
CREATE POLICY "reviews_select_public" ON public.reviews
  FOR SELECT TO authenticated
  USING (deleted_at IS NULL);

DROP POLICY IF EXISTS "reviews_insert_own" ON public.reviews;
CREATE POLICY "reviews_insert_own" ON public.reviews
  FOR INSERT TO authenticated
  WITH CHECK (reviewer_id = auth.uid());

DROP POLICY IF EXISTS "reviews_update_own" ON public.reviews;
CREATE POLICY "reviews_update_own" ON public.reviews
  FOR UPDATE TO authenticated
  USING (reviewer_id = auth.uid())
  WITH CHECK (reviewer_id = auth.uid());

-- =====================================================
-- MECHANIC_PROFILES POLICIES
-- Owner can do everything
-- Public can read (for browsing mechanics)
-- =====================================================
DROP POLICY IF EXISTS "mechanic_profiles_select_own" ON public.mechanic_profiles;
CREATE POLICY "mechanic_profiles_select_own" ON public.mechanic_profiles
  FOR SELECT TO authenticated
  USING (id = auth.uid());

DROP POLICY IF EXISTS "mechanic_profiles_select_public" ON public.mechanic_profiles;
CREATE POLICY "mechanic_profiles_select_public" ON public.mechanic_profiles
  FOR SELECT TO authenticated
  USING (deleted_at IS NULL);

DROP POLICY IF EXISTS "mechanic_profiles_insert_own" ON public.mechanic_profiles;
CREATE POLICY "mechanic_profiles_insert_own" ON public.mechanic_profiles
  FOR INSERT TO authenticated
  WITH CHECK (id = auth.uid());

DROP POLICY IF EXISTS "mechanic_profiles_update_own" ON public.mechanic_profiles;
CREATE POLICY "mechanic_profiles_update_own" ON public.mechanic_profiles
  FOR UPDATE TO authenticated
  USING (id = auth.uid())
  WITH CHECK (id = auth.uid());

-- =====================================================
-- MECHANIC SKILLS/TOOLS/SAFETY POLICIES
-- Owner can manage their own
-- Public can read (for viewing mechanic capabilities)
-- =====================================================
DROP POLICY IF EXISTS "mechanic_skills_select_public" ON public.mechanic_skills;
CREATE POLICY "mechanic_skills_select_public" ON public.mechanic_skills
  FOR SELECT TO authenticated
  USING (true);

DROP POLICY IF EXISTS "mechanic_skills_manage_own" ON public.mechanic_skills;
CREATE POLICY "mechanic_skills_manage_own" ON public.mechanic_skills
  FOR ALL TO authenticated
  USING (mechanic_id = auth.uid())
  WITH CHECK (mechanic_id = auth.uid());

DROP POLICY IF EXISTS "mechanic_tools_select_public" ON public.mechanic_tools;
CREATE POLICY "mechanic_tools_select_public" ON public.mechanic_tools
  FOR SELECT TO authenticated
  USING (true);

DROP POLICY IF EXISTS "mechanic_tools_manage_own" ON public.mechanic_tools;
CREATE POLICY "mechanic_tools_manage_own" ON public.mechanic_tools
  FOR ALL TO authenticated
  USING (mechanic_id = auth.uid())
  WITH CHECK (mechanic_id = auth.uid());

DROP POLICY IF EXISTS "mechanic_safety_select_public" ON public.mechanic_safety;
CREATE POLICY "mechanic_safety_select_public" ON public.mechanic_safety
  FOR SELECT TO authenticated
  USING (true);

DROP POLICY IF EXISTS "mechanic_safety_manage_own" ON public.mechanic_safety;
CREATE POLICY "mechanic_safety_manage_own" ON public.mechanic_safety
  FOR ALL TO authenticated
  USING (mechanic_id = auth.uid())
  WITH CHECK (mechanic_id = auth.uid());

-- =====================================================
-- LOOKUP TABLES POLICIES (public read)
-- =====================================================
DROP POLICY IF EXISTS "skills_select_all" ON public.skills;
CREATE POLICY "skills_select_all" ON public.skills
  FOR SELECT USING (true);

DROP POLICY IF EXISTS "tools_select_all" ON public.tools;
CREATE POLICY "tools_select_all" ON public.tools
  FOR SELECT USING (true);

DROP POLICY IF EXISTS "safety_measures_select_all" ON public.safety_measures;
CREATE POLICY "safety_measures_select_all" ON public.safety_measures
  FOR SELECT USING (true);

DROP POLICY IF EXISTS "symptoms_select_all" ON public.symptoms;
CREATE POLICY "symptoms_select_all" ON public.symptoms
  FOR SELECT USING (true);

DROP POLICY IF EXISTS "symptom_mappings_select_all" ON public.symptom_mappings;
CREATE POLICY "symptom_mappings_select_all" ON public.symptom_mappings
  FOR SELECT USING (true);

DROP POLICY IF EXISTS "education_cards_select_all" ON public.education_cards;
CREATE POLICY "education_cards_select_all" ON public.education_cards
  FOR SELECT USING (true);

DROP POLICY IF EXISTS "symptom_education_select_all" ON public.symptom_education;
CREATE POLICY "symptom_education_select_all" ON public.symptom_education
  FOR SELECT USING (true);

DROP POLICY IF EXISTS "symptom_questions_select_all" ON public.symptom_questions;
CREATE POLICY "symptom_questions_select_all" ON public.symptom_questions
  FOR SELECT USING (true);

-- =====================================================
-- MESSAGES POLICIES
-- =====================================================
DROP POLICY IF EXISTS "messages_select_involved" ON public.messages;
CREATE POLICY "messages_select_involved" ON public.messages
  FOR SELECT TO authenticated
  USING (sender_id = auth.uid() OR recipient_id = auth.uid());

DROP POLICY IF EXISTS "messages_insert_own" ON public.messages;
CREATE POLICY "messages_insert_own" ON public.messages
  FOR INSERT TO authenticated
  WITH CHECK (sender_id = auth.uid());

DROP POLICY IF EXISTS "messages_update_recipient" ON public.messages;
CREATE POLICY "messages_update_recipient" ON public.messages
  FOR UPDATE TO authenticated
  USING (recipient_id = auth.uid())
  WITH CHECK (recipient_id = auth.uid());

-- =====================================================
-- NOTIFICATIONS POLICIES (owner only)
-- =====================================================
DROP POLICY IF EXISTS "notifications_all_own" ON public.notifications;
CREATE POLICY "notifications_all_own" ON public.notifications
  FOR ALL TO authenticated
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- =====================================================
-- MEDIA_ASSETS POLICIES
-- Public assets (no owner) - anyone can read
-- Owner can manage their own
-- Job participants can read job media
-- =====================================================
DROP POLICY IF EXISTS "media_assets_select_public" ON public.media_assets;
CREATE POLICY "media_assets_select_public" ON public.media_assets
  FOR SELECT
  USING (uploaded_by IS NULL AND job_id IS NULL);

DROP POLICY IF EXISTS "media_assets_select_own" ON public.media_assets;
CREATE POLICY "media_assets_select_own" ON public.media_assets
  FOR SELECT TO authenticated
  USING (uploaded_by = auth.uid());

DROP POLICY IF EXISTS "media_assets_select_job" ON public.media_assets;
CREATE POLICY "media_assets_select_job" ON public.media_assets
  FOR SELECT TO authenticated
  USING (
    job_id IS NOT NULL
    AND EXISTS (
      SELECT 1 FROM public.jobs j
      WHERE j.id = media_assets.job_id
      AND (j.customer_id = auth.uid() OR j.accepted_mechanic_id = auth.uid())
    )
  );

DROP POLICY IF EXISTS "media_assets_insert_own" ON public.media_assets;
CREATE POLICY "media_assets_insert_own" ON public.media_assets
  FOR INSERT TO authenticated
  WITH CHECK (uploaded_by = auth.uid() OR uploaded_by IS NULL);

DROP POLICY IF EXISTS "media_assets_update_own" ON public.media_assets;
CREATE POLICY "media_assets_update_own" ON public.media_assets
  FOR UPDATE TO authenticated
  USING (uploaded_by = auth.uid())
  WITH CHECK (uploaded_by = auth.uid());

DROP POLICY IF EXISTS "media_assets_delete_own" ON public.media_assets;
CREATE POLICY "media_assets_delete_own" ON public.media_assets
  FOR DELETE TO authenticated
  USING (uploaded_by = auth.uid());

-- =====================================================
-- STRIPE/PAYMENT POLICIES
-- =====================================================
DROP POLICY IF EXISTS "mechanic_stripe_accounts_all_own" ON public.mechanic_stripe_accounts;
CREATE POLICY "mechanic_stripe_accounts_all_own" ON public.mechanic_stripe_accounts
  FOR ALL TO authenticated
  USING (mechanic_id = auth.uid())
  WITH CHECK (mechanic_id = auth.uid());

DROP POLICY IF EXISTS "customer_payment_methods_all_own" ON public.customer_payment_methods;
CREATE POLICY "customer_payment_methods_all_own" ON public.customer_payment_methods
  FOR ALL TO authenticated
  USING (customer_id = auth.uid())
  WITH CHECK (customer_id = auth.uid());

DROP POLICY IF EXISTS "payments_select_involved" ON public.payments;
CREATE POLICY "payments_select_involved" ON public.payments
  FOR SELECT TO authenticated
  USING (customer_id = auth.uid() OR mechanic_id = auth.uid());

DROP POLICY IF EXISTS "payments_insert_customer" ON public.payments;
CREATE POLICY "payments_insert_customer" ON public.payments
  FOR INSERT TO authenticated
  WITH CHECK (customer_id = auth.uid());

DROP POLICY IF EXISTS "payments_update_involved" ON public.payments;
CREATE POLICY "payments_update_involved" ON public.payments
  FOR UPDATE TO authenticated
  USING (customer_id = auth.uid() OR mechanic_id = auth.uid());

-- =====================================================
-- QUOTES POLICIES
-- =====================================================
DROP POLICY IF EXISTS "quotes_select_involved" ON public.quotes;
CREATE POLICY "quotes_select_involved" ON public.quotes
  FOR SELECT TO authenticated
  USING (
    mechanic_id = auth.uid() OR
    job_id IN (SELECT id FROM jobs WHERE customer_id = auth.uid())
  );

DROP POLICY IF EXISTS "quotes_insert_mechanic" ON public.quotes;
CREATE POLICY "quotes_insert_mechanic" ON public.quotes
  FOR INSERT TO authenticated
  WITH CHECK (mechanic_id = auth.uid());

DROP POLICY IF EXISTS "quotes_update_mechanic" ON public.quotes;
CREATE POLICY "quotes_update_mechanic" ON public.quotes
  FOR UPDATE TO authenticated
  USING (mechanic_id = auth.uid());

COMMIT;\n-- ===================================================================
-- END: 0002_rls_policies.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0003_functions_triggers.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0003: FUNCTIONS AND TRIGGERS
-- =====================================================
-- Purpose: All database functions and triggers
-- Depends on: 0001_baseline_schema.sql, 0002_rls_policies.sql
-- =====================================================

BEGIN;

-- =====================================================
-- TABLE OWNERSHIP (for SECURITY DEFINER functions)
-- =====================================================
ALTER TABLE public.profiles OWNER TO postgres;
ALTER TABLE public.mechanic_profiles OWNER TO postgres;

-- =====================================================
-- FUNCTION: handle_new_user
-- Auto-creates profile on auth signup (Google sign-in support)
-- =====================================================
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, avatar_url, created_at, updated_at)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data ->> 'full_name', NEW.raw_user_meta_data ->> 'name'),
    NEW.raw_user_meta_data ->> 'avatar_url',
    NOW(),
    NOW()
  )
  ON CONFLICT (id) DO NOTHING;
  RETURN NEW;
END;
$$;

-- Trigger on auth.users
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- =====================================================
-- FUNCTION: set_user_role
-- Allows one-time role setting per user
-- =====================================================
CREATE OR REPLACE FUNCTION public.set_user_role(new_role public.user_role)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  existing_role public.user_role;
BEGIN
  SELECT role INTO existing_role
  FROM public.profiles
  WHERE id = auth.uid();
  
  IF existing_role IS NOT NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Role already set to ' || existing_role::text
    );
  END IF;
  
  UPDATE public.profiles
  SET role = new_role, updated_at = NOW()
  WHERE id = auth.uid();
  
  IF new_role = 'mechanic' THEN
    INSERT INTO public.mechanic_profiles (id, created_at, updated_at)
    VALUES (auth.uid(), NOW(), NOW())
    ON CONFLICT (id) DO NOTHING;
  END IF;
  
  RETURN json_build_object(
    'success', true,
    'role', new_role::text
  );
END;
$$;

-- =====================================================
-- FUNCTION: get_my_role
-- Returns current user's role (bypasses RLS)
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_my_role()
RETURNS public.user_role
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  user_role public.user_role;
BEGIN
  SELECT role INTO user_role
  FROM public.profiles
  WHERE id = auth.uid();
  
  RETURN user_role;
END;
$$;

-- =====================================================
-- FUNCTION: get_my_profile
-- Returns current user's full profile (bypasses RLS)
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_my_profile()
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  profile_data json;
BEGIN
  SELECT json_build_object(
    'id', p.id,
    'email', p.email,
    'full_name', p.full_name,
    'display_name', p.display_name,
    'phone', p.phone,
    'avatar_url', p.avatar_url,
    'role', p.role,
    'theme_preference', p.theme_preference,
    'city', p.city,
    'state', p.state,
    'home_lat', p.home_lat,
    'home_lng', p.home_lng,
    'created_at', p.created_at,
    'updated_at', p.updated_at
  ) INTO profile_data
  FROM public.profiles p
  WHERE p.id = auth.uid();
  
  RETURN profile_data;
END;
$$;

-- =====================================================
-- FUNCTION: get_profile_for_stripe
-- Returns profile for stripe operations (service_role)
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_profile_for_stripe(p_user_id uuid)
RETURNS TABLE (
  id uuid,
  email text,
  full_name text
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT p.id, p.email, p.full_name
  FROM public.profiles p
  WHERE p.id = p_user_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_profile_for_stripe(uuid) TO service_role;

-- =====================================================
-- FUNCTION: update_updated_at_column
-- Generic trigger to update updated_at timestamp
-- =====================================================
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- =====================================================
-- FUNCTION: update_mechanic_rating
-- Recalculates mechanic rating after review
-- =====================================================
CREATE OR REPLACE FUNCTION public.update_mechanic_rating()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE public.mechanic_profiles
  SET
    rating_avg = (
      SELECT COALESCE(AVG(overall_rating)::numeric(3,2), 0)
      FROM public.reviews
      WHERE reviewee_id = NEW.reviewee_id AND deleted_at IS NULL
    ),
    rating_count = (
      SELECT COUNT(*)
      FROM public.reviews
      WHERE reviewee_id = NEW.reviewee_id AND deleted_at IS NULL
    ),
    updated_at = NOW()
  WHERE id = NEW.reviewee_id;
  
  RETURN NEW;
END;
$$;

-- =====================================================
-- FUNCTION: increment_mechanic_job_count
-- Increments completed job count for mechanic
-- =====================================================
CREATE OR REPLACE FUNCTION public.increment_mechanic_job_count()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
    UPDATE public.mechanic_profiles
    SET jobs_completed = jobs_completed + 1, updated_at = NOW()
    WHERE id = NEW.accepted_mechanic_id;
  END IF;
  RETURN NEW;
END;
$$;

-- =====================================================
-- FUNCTION: get_mechanic_leads
-- Returns job leads for mechanics based on location and filter
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text,
  p_mechanic_lat numeric DEFAULT NULL,
  p_mechanic_lng numeric DEFAULT NULL,
  p_radius_miles numeric DEFAULT 25,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  created_at timestamptz,
  preferred_time text,
  location_address text,
  latitude numeric,
  longitude numeric,
  distance_miles numeric,
  customer_id uuid,
  customer_name text,
  customer_photo_url text,
  customer_rating numeric,
  customer_review_count bigint,
  vehicle_id uuid,
  vehicle_year integer,
  vehicle_make text,
  vehicle_model text,
  has_quoted boolean,
  quote_id uuid,
  quote_amount integer,
  quote_status text,
  quote_created_at timestamptz,
  is_new boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  effective_radius numeric;
BEGIN
  -- For 'nearby' filter, use 5 miles. For 'all', use mechanic's radius (p_radius_miles)
  IF p_filter = 'nearby' THEN
    effective_radius := 5;
  ELSE
    effective_radius := p_radius_miles;
  END IF;

  RETURN QUERY
  SELECT
    j.id AS job_id,
    j.title,
    j.description,
    j.status::text,
    j.created_at,
    j.preferred_time,
    j.location_address,
    j.location_lat::numeric AS latitude,
    j.location_lng::numeric AS longitude,
    CASE
      WHEN p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      THEN (
        3959 * acos(
          cos(radians(p_mechanic_lat)) *
          cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) *
          sin(radians(j.location_lat))
        )
      )::numeric
      ELSE NULL
    END AS distance_miles,
    p.id AS customer_id,
    p.full_name AS customer_name,
    p.avatar_url AS customer_photo_url,
    COALESCE((
      SELECT AVG(r.overall_rating)::numeric
      FROM reviews r
      WHERE r.reviewee_id = p.id
        AND r.is_hidden = false
        AND r.deleted_at IS NULL
    ), 0) AS customer_rating,
    COALESCE((
      SELECT COUNT(*)::bigint
      FROM reviews r
      WHERE r.reviewee_id = p.id
        AND r.is_hidden = false
        AND r.deleted_at IS NULL
    ), 0) AS customer_review_count,
    j.vehicle_id,
    v.year AS vehicle_year,
    v.make AS vehicle_make,
    v.model AS vehicle_model,
    EXISTS(SELECT 1 FROM quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id) AS has_quoted,
    (SELECT q.id FROM quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id LIMIT 1) AS quote_id,
    (SELECT q.price_cents FROM quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id LIMIT 1) AS quote_amount,
    (SELECT q.status::text FROM quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id LIMIT 1) AS quote_status,
    (SELECT q.created_at FROM quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id LIMIT 1) AS quote_created_at,
    (j.created_at > NOW() - INTERVAL '24 hours') AS is_new
  FROM jobs j
  INNER JOIN profiles p ON p.id = j.customer_id
  LEFT JOIN vehicles v ON v.id = j.vehicle_id
  WHERE
    j.deleted_at IS NULL
    AND p.deleted_at IS NULL
    AND (
      (p_filter = 'all' AND j.status IN ('searching', 'quoted'))
      OR (p_filter = 'quoted' AND EXISTS(SELECT 1 FROM quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id))
      OR (p_filter = 'nearby' AND j.status IN ('searching', 'quoted'))
    )
    AND (
      p_mechanic_lat IS NULL
      OR p_mechanic_lng IS NULL
      OR j.location_lat IS NULL
      OR j.location_lng IS NULL
      OR (
        3959 * acos(
          cos(radians(p_mechanic_lat)) *
          cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) *
          sin(radians(j.location_lat))
        )
      ) <= effective_radius
    )
  ORDER BY
    CASE WHEN p_sort_by = 'newest' THEN j.created_at ELSE NULL END DESC,
    CASE WHEN p_sort_by = 'closest' THEN (
      CASE
        WHEN p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
        THEN 3959 * acos(
          cos(radians(p_mechanic_lat)) *
          cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) *
          sin(radians(j.location_lat))
        )
        ELSE 999999
      END
    ) ELSE NULL END ASC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads(uuid, text, numeric, numeric, numeric, integer, integer, text) TO authenticated;

-- =====================================================
-- FUNCTION: get_mechanic_leads_summary
-- Returns summary counts for mechanic leads
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_mechanic_leads_summary(
  p_mechanic_id uuid,
  p_mechanic_lat numeric DEFAULT NULL,
  p_mechanic_lng numeric DEFAULT NULL,
  p_radius_miles numeric DEFAULT 25
)
RETURNS TABLE (
  all_count bigint,
  nearby_count bigint,
  quoted_count bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    -- all_count: jobs within mechanic's service radius
    (SELECT COUNT(*) FROM jobs j
     INNER JOIN profiles p ON p.id = j.customer_id
     WHERE j.deleted_at IS NULL AND p.deleted_at IS NULL
     AND j.status IN ('searching', 'quoted')
     AND (
       p_mechanic_lat IS NULL OR p_mechanic_lng IS NULL
       OR j.location_lat IS NULL OR j.location_lng IS NULL
       OR (3959 * acos(
         cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
         cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
         sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
       )) <= p_radius_miles
     )
    ) AS all_count,
    -- nearby_count: jobs within 5 miles
    (SELECT COUNT(*) FROM jobs j
     INNER JOIN profiles p ON p.id = j.customer_id
     WHERE j.deleted_at IS NULL AND p.deleted_at IS NULL
     AND j.status IN ('searching', 'quoted')
     AND (
       p_mechanic_lat IS NULL OR p_mechanic_lng IS NULL
       OR j.location_lat IS NULL OR j.location_lng IS NULL
       OR (3959 * acos(
         cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
         cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
         sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
       )) <= 5
     )
    ) AS nearby_count,
    -- quoted_count: jobs mechanic has quoted on
    (SELECT COUNT(*) FROM jobs j
     INNER JOIN profiles p ON p.id = j.customer_id
     WHERE j.deleted_at IS NULL AND p.deleted_at IS NULL
     AND EXISTS(SELECT 1 FROM quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id)
    ) AS quoted_count;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads_summary(uuid, numeric, numeric, numeric) TO authenticated;

-- =====================================================
-- FUNCTION: get_public_profile_card
-- Returns public profile data for profile cards
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_public_profile_card(user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  result jsonb;
  profile_record record;
  profile_ratings jsonb;
  profile_badges jsonb;
  profile_skills jsonb;
BEGIN
  -- Get the profile record
  SELECT p.id, p.role, p.full_name, p.avatar_url, p.created_at
  INTO profile_record
  FROM profiles p
  WHERE p.id = user_id
    AND p.deleted_at IS NULL;

  IF NOT FOUND THEN
    RETURN NULL;
  END IF;

  -- Get ratings from reviews
  SELECT jsonb_build_object(
    'overall_avg', COALESCE(AVG(r.overall_rating), 0),
    'performance_avg', COALESCE(AVG(r.performance_rating), 0),
    'timing_avg', COALESCE(AVG(r.timing_rating), 0),
    'cost_avg', COALESCE(AVG(r.cost_rating), 0),
    'review_count', COUNT(r.id)::integer
  )
  INTO profile_ratings
  FROM reviews r
  WHERE r.reviewee_id = profile_record.id
    AND r.is_hidden = false
    AND r.deleted_at IS NULL;

  -- Get badges
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ub.id,
      'badge_id', ub.badge_id,
      'awarded_at', ub.awarded_at,
      'badge', jsonb_build_object(
        'code', b.code,
        'title', b.title,
        'description', b.description,
        'icon', b.icon,
        'badge_type', b.badge_type
      )
    )
  ), '[]'::jsonb)
  INTO profile_badges
  FROM user_badges ub
  INNER JOIN badges b ON b.id = ub.badge_id
  WHERE ub.user_id = profile_record.id
    AND (ub.expires_at IS NULL OR ub.expires_at > NOW());

  -- Get skills (for mechanics only)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ms.id,
      'skill', jsonb_build_object(
        'key', s.key,
        'label', s.label,
        'category', s.category
      )
    )
  ), '[]'::jsonb)
  INTO profile_skills
  FROM mechanic_skills ms
  INNER JOIN skills s ON s.key = ms.skill_key
  WHERE ms.mechanic_id = profile_record.id;

  -- Build result
  result := jsonb_build_object(
    'id', profile_record.id,
    'role', profile_record.role,
    'display_name', COALESCE(profile_record.full_name, 'Unknown User'),
    'avatar_url', profile_record.avatar_url,
    'created_at', profile_record.created_at,
    'ratings', profile_ratings,
    'badges', profile_badges,
    'skills', profile_skills
  );

  RETURN result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO anon;

-- =====================================================
-- FUNCTION: get_mechanic_profile_full
-- Returns complete mechanic profile with skills, tools, safety
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_mechanic_profile_full(p_mechanic_id uuid DEFAULT NULL)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  mechanic_id uuid;
  result json;
BEGIN
  mechanic_id := COALESCE(p_mechanic_id, auth.uid());
  
  SELECT json_build_object(
    'profile', (
      SELECT json_build_object(
        'id', mp.id,
        'bio', mp.bio,
        'years_experience', mp.years_experience,
        'hourly_rate_cents', mp.hourly_rate_cents,
        'service_radius_km', mp.service_radius_km,
        'mobile_service', mp.mobile_service,
        'is_available', mp.is_available,
        'rating_avg', mp.rating_avg,
        'rating_count', mp.rating_count,
        'jobs_completed', mp.jobs_completed,
        'stripe_onboarding_complete', mp.stripe_onboarding_complete
      )
      FROM public.mechanic_profiles mp
      WHERE mp.id = mechanic_id
    ),
    'user', (
      SELECT json_build_object(
        'full_name', p.full_name,
        'display_name', p.display_name,
        'avatar_url', p.avatar_url,
        'city', p.city,
        'state', p.state,
        'home_lat', p.home_lat,
        'home_lng', p.home_lng
      )
      FROM public.profiles p
      WHERE p.id = mechanic_id
    ),
    'skills', (
      SELECT COALESCE(json_agg(json_build_object(
        'key', s.key,
        'label', s.label,
        'category', s.category
      )), '[]'::json)
      FROM public.mechanic_skills ms
      JOIN public.skills s ON ms.skill_key = s.key
      WHERE ms.mechanic_id = mechanic_id
    ),
    'tools', (
      SELECT COALESCE(json_agg(json_build_object(
        'key', t.key,
        'label', t.label,
        'category', t.category
      )), '[]'::json)
      FROM public.mechanic_tools mt
      JOIN public.tools t ON mt.tool_key = t.key
      WHERE mt.mechanic_id = mechanic_id
    ),
    'safety', (
      SELECT COALESCE(json_agg(json_build_object(
        'key', sm.key,
        'label', sm.label
      )), '[]'::json)
      FROM public.mechanic_safety msa
      JOIN public.safety_measures sm ON msa.safety_key = sm.key
      WHERE msa.mechanic_id = mechanic_id
    )
  ) INTO result;
  
  RETURN result;
END;
$$;

-- =====================================================
-- FUNCTION: save_theme_preference
-- Saves user's theme preference
-- =====================================================
CREATE OR REPLACE FUNCTION public.save_theme_preference(p_theme public.theme_mode)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE public.profiles
  SET theme_preference = p_theme, updated_at = NOW()
  WHERE id = auth.uid();
  
  RETURN FOUND;
END;
$$;

-- =====================================================
-- TRIGGERS: updated_at
-- =====================================================
DROP TRIGGER IF EXISTS set_updated_at ON public.profiles;
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS set_updated_at ON public.vehicles;
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.vehicles
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS set_updated_at ON public.jobs;
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.jobs
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS set_updated_at ON public.quote_requests;
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.quote_requests
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS set_updated_at ON public.reviews;
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.reviews
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS set_updated_at ON public.mechanic_profiles;
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.mechanic_profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS set_updated_at ON public.messages;
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.messages
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS set_updated_at ON public.notifications;
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.notifications
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS set_updated_at ON public.media_assets;
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.media_assets
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS set_updated_at ON public.mechanic_stripe_accounts;
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.mechanic_stripe_accounts
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS set_updated_at ON public.customer_payment_methods;
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.customer_payment_methods
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS set_updated_at ON public.payments;
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.payments
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- =====================================================
-- TRIGGER: update_mechanic_rating_trigger
-- =====================================================
DROP TRIGGER IF EXISTS update_mechanic_rating_trigger ON public.reviews;
CREATE TRIGGER update_mechanic_rating_trigger
  AFTER INSERT OR UPDATE ON public.reviews
  FOR EACH ROW
  EXECUTE FUNCTION public.update_mechanic_rating();

-- =====================================================
-- TRIGGER: increment_mechanic_job_count_trigger
-- =====================================================
DROP TRIGGER IF EXISTS increment_mechanic_job_count_trigger ON public.jobs;
CREATE TRIGGER increment_mechanic_job_count_trigger
  AFTER UPDATE ON public.jobs
  FOR EACH ROW
  EXECUTE FUNCTION public.increment_mechanic_job_count();

COMMIT;
\n-- ===================================================================
-- END: 0003_functions_triggers.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0004_stripe_marketplace.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0004: STRIPE MARKETPLACE
-- =====================================================
-- Purpose: Stripe Connect functions for mechanic payouts
-- Depends on: 0003_functions_triggers.sql
-- =====================================================

BEGIN;

-- =====================================================
-- FUNCTION: create_stripe_connect_account
-- Creates or retrieves Stripe Connect account for mechanic
-- =====================================================
CREATE OR REPLACE FUNCTION public.create_stripe_connect_account()
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  mechanic_profile_exists boolean;
  existing_account text;
BEGIN
  SELECT EXISTS (
    SELECT 1 FROM public.mechanic_profiles WHERE id = auth.uid()
  ) INTO mechanic_profile_exists;
  
  IF NOT mechanic_profile_exists THEN
    INSERT INTO public.mechanic_profiles (id, created_at, updated_at)
    VALUES (auth.uid(), NOW(), NOW())
    ON CONFLICT (id) DO NOTHING;
  END IF;
  
  SELECT stripe_account_id INTO existing_account
  FROM public.mechanic_stripe_accounts
  WHERE mechanic_id = auth.uid();
  
  IF existing_account IS NOT NULL THEN
    RETURN json_build_object(
      'success', true,
      'account_id', existing_account,
      'is_new', false
    );
  END IF;
  
  RETURN json_build_object(
    'success', true,
    'account_id', null,
    'is_new', true,
    'message', 'Ready to create new Stripe account'
  );
END;
$$;

-- =====================================================
-- FUNCTION: save_stripe_account
-- Saves Stripe account ID after creation
-- =====================================================
CREATE OR REPLACE FUNCTION public.save_stripe_account(
  p_stripe_account_id text
)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.mechanic_stripe_accounts (
    mechanic_id,
    stripe_account_id,
    created_at,
    updated_at
  )
  VALUES (
    auth.uid(),
    p_stripe_account_id,
    NOW(),
    NOW()
  )
  ON CONFLICT (mechanic_id) 
  DO UPDATE SET 
    stripe_account_id = p_stripe_account_id,
    updated_at = NOW();
  
  UPDATE public.mechanic_profiles
  SET stripe_account_id = p_stripe_account_id, updated_at = NOW()
  WHERE id = auth.uid();
  
  RETURN json_build_object('success', true);
END;
$$;

-- =====================================================
-- FUNCTION: update_stripe_account_status
-- Updates Stripe account status after webhook
-- =====================================================
CREATE OR REPLACE FUNCTION public.update_stripe_account_status(
  p_stripe_account_id text,
  p_charges_enabled boolean,
  p_payouts_enabled boolean,
  p_onboarding_complete boolean
)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE public.mechanic_stripe_accounts
  SET 
    charges_enabled = p_charges_enabled,
    payouts_enabled = p_payouts_enabled,
    onboarding_complete = p_onboarding_complete,
    updated_at = NOW()
  WHERE stripe_account_id = p_stripe_account_id;
  
  UPDATE public.mechanic_profiles
  SET 
    stripe_onboarding_complete = p_onboarding_complete,
    updated_at = NOW()
  WHERE stripe_account_id = p_stripe_account_id;
  
  RETURN json_build_object('success', true);
END;
$$;

-- =====================================================
-- FUNCTION: get_stripe_account_status
-- Gets current Stripe account status for mechanic
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_stripe_account_status()
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  result json;
BEGIN
  SELECT json_build_object(
    'has_account', msa.stripe_account_id IS NOT NULL,
    'stripe_account_id', msa.stripe_account_id,
    'onboarding_complete', COALESCE(msa.onboarding_complete, false),
    'charges_enabled', COALESCE(msa.charges_enabled, false),
    'payouts_enabled', COALESCE(msa.payouts_enabled, false)
  ) INTO result
  FROM public.mechanic_profiles mp
  LEFT JOIN public.mechanic_stripe_accounts msa ON msa.mechanic_id = mp.id
  WHERE mp.id = auth.uid();
  
  IF result IS NULL THEN
    RETURN json_build_object(
      'has_account', false,
      'stripe_account_id', null,
      'onboarding_complete', false,
      'charges_enabled', false,
      'payouts_enabled', false
    );
  END IF;
  
  RETURN result;
END;
$$;

-- =====================================================
-- FUNCTION: create_payment_intent
-- Creates a payment record for a job
-- =====================================================
CREATE OR REPLACE FUNCTION public.create_payment_intent(
  p_job_id uuid,
  p_amount_cents int,
  p_stripe_payment_intent_id text DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_job record;
  v_payment_id uuid;
  v_platform_fee int;
BEGIN
  SELECT * INTO v_job
  FROM public.jobs
  WHERE id = p_job_id AND customer_id = auth.uid();
  
  IF v_job IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Job not found or not authorized');
  END IF;
  
  IF v_job.accepted_mechanic_id IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'No mechanic assigned to job');
  END IF;
  
  v_platform_fee := (p_amount_cents * 0.15)::int;
  
  INSERT INTO public.payments (
    job_id,
    customer_id,
    mechanic_id,
    stripe_payment_intent_id,
    amount_cents,
    platform_fee_cents,
    status,
    created_at,
    updated_at
  )
  VALUES (
    p_job_id,
    auth.uid(),
    v_job.accepted_mechanic_id,
    p_stripe_payment_intent_id,
    p_amount_cents,
    v_platform_fee,
    'pending',
    NOW(),
    NOW()
  )
  RETURNING id INTO v_payment_id;
  
  RETURN json_build_object(
    'success', true,
    'payment_id', v_payment_id,
    'amount_cents', p_amount_cents,
    'platform_fee_cents', v_platform_fee
  );
END;
$$;

-- =====================================================
-- FUNCTION: update_payment_status
-- Updates payment status (called by webhook)
-- =====================================================
CREATE OR REPLACE FUNCTION public.update_payment_status(
  p_stripe_payment_intent_id text,
  p_status public.payment_status,
  p_paid_at timestamptz DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE public.payments
  SET 
    status = p_status,
    paid_at = COALESCE(p_paid_at, paid_at),
    updated_at = NOW()
  WHERE stripe_payment_intent_id = p_stripe_payment_intent_id;
  
  IF p_status = 'succeeded' THEN
    UPDATE public.jobs
    SET status = 'completed', completed_at = NOW(), updated_at = NOW()
    WHERE id = (
      SELECT job_id FROM public.payments 
      WHERE stripe_payment_intent_id = p_stripe_payment_intent_id
    );
  END IF;
  
  RETURN json_build_object('success', true);
END;
$$;

COMMIT;
\n-- ===================================================================
-- END: 0004_stripe_marketplace.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0005_indexes_performance.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0005: INDEXES AND PERFORMANCE
-- =====================================================
-- Purpose: All database indexes for query performance
-- Depends on: 0001_baseline_schema.sql
-- =====================================================

BEGIN;

-- =====================================================
-- PROFILES INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_profiles_role ON public.profiles(role) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_profiles_email ON public.profiles(email) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_profiles_location ON public.profiles(home_lat, home_lng) WHERE deleted_at IS NULL;

-- =====================================================
-- VEHICLES INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_vehicles_customer ON public.vehicles(customer_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_vehicles_vin ON public.vehicles(vin) WHERE vin IS NOT NULL AND deleted_at IS NULL;

-- =====================================================
-- JOBS INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_jobs_customer ON public.jobs(customer_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_jobs_mechanic ON public.jobs(accepted_mechanic_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_jobs_status ON public.jobs(status) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_jobs_location ON public.jobs(location_lat, location_lng) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_jobs_searching ON public.jobs(status, created_at DESC) 
  WHERE status IN ('searching', 'quoted') AND deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_jobs_created ON public.jobs(created_at DESC) WHERE deleted_at IS NULL;

-- =====================================================
-- QUOTE_REQUESTS INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_quote_requests_job ON public.quote_requests(job_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_quote_requests_mechanic ON public.quote_requests(mechanic_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_quote_requests_customer ON public.quote_requests(customer_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_quote_requests_status ON public.quote_requests(status) WHERE deleted_at IS NULL;

-- =====================================================
-- QUOTES INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_quotes_job ON public.quotes(job_id);
CREATE INDEX IF NOT EXISTS idx_quotes_mechanic ON public.quotes(mechanic_id);
CREATE INDEX IF NOT EXISTS idx_quotes_status ON public.quotes(status);

-- =====================================================
-- REVIEWS INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_reviews_job ON public.reviews(job_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_reviews_reviewer ON public.reviews(reviewer_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_reviews_reviewee ON public.reviews(reviewee_id) WHERE deleted_at IS NULL;

-- =====================================================
-- MECHANIC_PROFILES INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_mechanic_profiles_available ON public.mechanic_profiles(is_available) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_mechanic_profiles_rating ON public.mechanic_profiles(rating_avg DESC) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_mechanic_profiles_stripe ON public.mechanic_profiles(stripe_account_id) WHERE stripe_account_id IS NOT NULL;

-- =====================================================
-- MECHANIC SKILLS/TOOLS/SAFETY INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_mechanic_skills_mechanic ON public.mechanic_skills(mechanic_id);
CREATE INDEX IF NOT EXISTS idx_mechanic_skills_key ON public.mechanic_skills(skill_key);
CREATE INDEX IF NOT EXISTS idx_mechanic_tools_mechanic ON public.mechanic_tools(mechanic_id);
CREATE INDEX IF NOT EXISTS idx_mechanic_tools_key ON public.mechanic_tools(tool_key);
CREATE INDEX IF NOT EXISTS idx_mechanic_safety_mechanic ON public.mechanic_safety(mechanic_id);
CREATE INDEX IF NOT EXISTS idx_mechanic_safety_key ON public.mechanic_safety(safety_key);

-- =====================================================
-- SYMPTOM TABLES INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_symptom_mappings_category ON public.symptom_mappings(category);
CREATE INDEX IF NOT EXISTS idx_symptom_mappings_risk ON public.symptom_mappings(risk_level);
CREATE INDEX IF NOT EXISTS idx_education_cards_symptom ON public.education_cards(symptom_key);
CREATE INDEX IF NOT EXISTS idx_symptom_questions_symptom ON public.symptom_questions(symptom_key);
CREATE INDEX IF NOT EXISTS idx_symptom_questions_order ON public.symptom_questions(symptom_key, display_order);

-- =====================================================
-- MESSAGES INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_messages_job ON public.messages(job_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_messages_sender ON public.messages(sender_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_messages_recipient ON public.messages(recipient_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_messages_unread ON public.messages(recipient_id, read_at) 
  WHERE read_at IS NULL AND deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_messages_created ON public.messages(job_id, created_at DESC) WHERE deleted_at IS NULL;

-- =====================================================
-- NOTIFICATIONS INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_notifications_user ON public.notifications(user_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_notifications_unread ON public.notifications(user_id, is_read) 
  WHERE is_read = false AND deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_notifications_created ON public.notifications(user_id, created_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_notifications_entity ON public.notifications(entity_type, entity_id) WHERE deleted_at IS NULL;

-- =====================================================
-- MEDIA_ASSETS INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_media_assets_key ON public.media_assets(key) WHERE key IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_media_assets_job ON public.media_assets(job_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_media_assets_uploaded_by ON public.media_assets(uploaded_by) WHERE deleted_at IS NULL;

-- =====================================================
-- PAYMENT INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_mechanic_stripe_accounts_mechanic ON public.mechanic_stripe_accounts(mechanic_id);
CREATE INDEX IF NOT EXISTS idx_mechanic_stripe_accounts_stripe ON public.mechanic_stripe_accounts(stripe_account_id);
CREATE INDEX IF NOT EXISTS idx_customer_payment_methods_customer ON public.customer_payment_methods(customer_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_payments_job ON public.payments(job_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_payments_customer ON public.payments(customer_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_payments_mechanic ON public.payments(mechanic_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_payments_status ON public.payments(status) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_payments_stripe ON public.payments(stripe_payment_intent_id) WHERE stripe_payment_intent_id IS NOT NULL;

COMMIT;
\n-- ===================================================================
-- END: 0005_indexes_performance.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0006_job_lifecycle.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0006: JOB LIFECYCLE & TRANSACTION SYSTEM
-- =====================================================
-- Purpose: Complete job lifecycle from quote acceptance to payout
-- Includes: Contracts, invoices, approvals, disputes, payouts, audit logs
-- =====================================================

BEGIN;

-- =====================================================
-- NEW ENUMS
-- =====================================================

-- Job contract status
DO $$ BEGIN
  CREATE TYPE public.contract_status AS ENUM (
    'pending_payment',    -- Awaiting initial payment authorization
    'active',             -- Payment authorized, contract in effect
    'completed',          -- Both parties confirmed completion
    'cancelled',          -- Cancelled (see cancellation_reason)
    'disputed',           -- Under dispute
    'refunded'            -- Fully refunded
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- Cancellation reason types
DO $$ BEGIN
  CREATE TYPE public.cancellation_reason AS ENUM (
    'customer_before_departure',   -- Full refund
    'customer_after_departure',    -- Travel fee may apply
    'customer_after_arrival',      -- Travel fee applies
    'customer_after_work_started', -- Partial charge
    'mechanic_before_departure',   -- Full refund
    'mechanic_after_departure',    -- Full refund + penalty
    'mechanic_no_show',            -- Full refund + penalty
    'customer_no_show',            -- Travel fee charged
    'mutual_agreement',            -- Negotiated refund
    'platform_intervention'        -- Platform cancelled
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- Invoice line item types
DO $$ BEGIN
  CREATE TYPE public.line_item_type AS ENUM (
    'base_labor',         -- Original quoted labor
    'additional_labor',   -- Added labor during job
    'parts',              -- Parts/materials
    'diagnostic',         -- Diagnostic fee
    'travel',             -- Travel/trip fee
    'platform_fee',       -- Platform fee (customer side)
    'discount',           -- Discount applied
    'tax'                 -- Tax if applicable
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- Line item approval status
DO $$ BEGIN
  CREATE TYPE public.approval_status AS ENUM (
    'pending',            -- Awaiting customer approval
    'approved',           -- Customer approved
    'rejected',           -- Customer rejected
    'auto_rejected'       -- Auto-rejected after timeout
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- Dispute status
DO $$ BEGIN
  CREATE TYPE public.dispute_status AS ENUM (
    'open',               -- Dispute filed
    'under_review',       -- Platform reviewing
    'evidence_requested', -- Awaiting evidence
    'resolved_customer',  -- Resolved in customer favor
    'resolved_mechanic',  -- Resolved in mechanic favor
    'resolved_split',     -- Split resolution
    'closed'              -- Closed without resolution
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- Payout status
DO $$ BEGIN
  CREATE TYPE public.payout_status AS ENUM (
    'pending',            -- Awaiting job completion
    'processing',         -- Being processed
    'completed',          -- Sent to mechanic
    'failed',             -- Failed to process
    'held',               -- On hold (dispute/review)
    'cancelled'           -- Cancelled
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- Job event types for audit log
DO $$ BEGIN
  CREATE TYPE public.job_event_type AS ENUM (
    'quote_accepted',
    'contract_created',
    'payment_authorized',
    'payment_failed',
    'mechanic_departed',
    'mechanic_arrived',
    'customer_confirmed_arrival',
    'work_started',
    'line_item_added',
    'line_item_approved',
    'line_item_rejected',
    'work_completed_mechanic',
    'work_completed_customer',
    'job_finalized',
    'payment_captured',
    'payout_initiated',
    'payout_completed',
    'cancelled',
    'dispute_opened',
    'dispute_resolved',
    'refund_issued',
    'message_sent',
    'system_note'
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- =====================================================
-- TABLE: job_contracts
-- =====================================================
-- Binding agreement created when customer accepts quote
-- Contains immutable snapshot of agreed terms

CREATE TABLE IF NOT EXISTS public.job_contracts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  quote_id uuid NOT NULL REFERENCES public.quotes(id) ON DELETE CASCADE,
  customer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Status
  status public.contract_status DEFAULT 'pending_payment' NOT NULL,
  
  -- Agreed amounts (snapshot at time of acceptance)
  quoted_price_cents int NOT NULL,
  platform_fee_cents int NOT NULL DEFAULT 1500,  -- $15 default
  estimated_hours numeric,
  
  -- Calculated totals (updated as invoice changes)
  subtotal_cents int NOT NULL,           -- Sum of all approved line items
  total_customer_cents int NOT NULL,     -- What customer pays (subtotal + platform fee)
  mechanic_commission_cents int NOT NULL, -- 12% capped at $50
  mechanic_payout_cents int NOT NULL,    -- What mechanic receives
  
  -- Payment info
  stripe_payment_intent_id text,
  stripe_transfer_id text,
  payment_authorized_at timestamptz,
  payment_captured_at timestamptz,
  
  -- Terms snapshot
  terms_version text DEFAULT '2025.01',
  terms_accepted_at timestamptz NOT NULL DEFAULT now(),
  
  -- Cancellation
  cancelled_at timestamptz,
  cancelled_by uuid REFERENCES public.profiles(id),
  cancellation_reason public.cancellation_reason,
  cancellation_note text,
  refund_amount_cents int,
  
  -- Timestamps
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  
  UNIQUE(job_id),
  UNIQUE(quote_id),
  CONSTRAINT positive_amounts CHECK (
    quoted_price_cents >= 0 AND 
    platform_fee_cents >= 0 AND 
    subtotal_cents >= 0 AND
    total_customer_cents >= 0 AND
    mechanic_commission_cents >= 0 AND
    mechanic_payout_cents >= 0
  )
);

COMMENT ON TABLE public.job_contracts IS 'Binding contract created when quote is accepted';

-- =====================================================
-- TABLE: invoice_line_items
-- =====================================================
-- Editable invoice items during job

CREATE TABLE IF NOT EXISTS public.invoice_line_items (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  contract_id uuid NOT NULL REFERENCES public.job_contracts(id) ON DELETE CASCADE,
  
  -- Item details
  item_type public.line_item_type NOT NULL,
  description text NOT NULL,
  quantity numeric DEFAULT 1 NOT NULL,
  unit_price_cents int NOT NULL,
  total_cents int NOT NULL,            -- quantity * unit_price_cents
  
  -- For parts: additional info
  part_number text,
  part_source text,                    -- e.g., "Customer provided", "AutoZone"
  
  -- Approval tracking
  approval_status public.approval_status DEFAULT 'pending' NOT NULL,
  requires_approval boolean DEFAULT true NOT NULL,  -- false for original quote items
  approved_at timestamptz,
  approved_by uuid REFERENCES public.profiles(id),
  rejected_at timestamptz,
  rejected_by uuid REFERENCES public.profiles(id),
  rejection_reason text,
  approval_deadline timestamptz,       -- Auto-reject after this time
  
  -- Who added this
  added_by uuid NOT NULL REFERENCES public.profiles(id),
  added_by_role public.user_role NOT NULL,
  
  -- Notes
  notes text,
  
  -- Ordering
  sort_order int DEFAULT 0,
  
  -- Timestamps
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  
  CONSTRAINT positive_line_amounts CHECK (
    quantity > 0 AND 
    unit_price_cents >= 0 AND 
    total_cents >= 0
  )
);

COMMENT ON TABLE public.invoice_line_items IS 'Line items on job invoice, editable during job';

-- =====================================================
-- TABLE: job_events
-- =====================================================
-- Complete audit log of all job activities

CREATE TABLE IF NOT EXISTS public.job_events (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  contract_id uuid REFERENCES public.job_contracts(id) ON DELETE SET NULL,
  
  -- Event info
  event_type public.job_event_type NOT NULL,
  actor_id uuid REFERENCES public.profiles(id),   -- NULL for system events
  actor_role public.user_role,
  
  -- Event data
  title text NOT NULL,
  description text,
  metadata jsonb DEFAULT '{}',         -- Additional event-specific data
  
  -- For financial events
  amount_cents int,
  
  -- Visibility
  visible_to_customer boolean DEFAULT true,
  visible_to_mechanic boolean DEFAULT true,
  is_system_message boolean DEFAULT false,
  
  -- Timestamps
  created_at timestamptz DEFAULT now() NOT NULL,
  
  -- Immutable - no updated_at
  CONSTRAINT job_events_immutable CHECK (true)  -- Placeholder for trigger
);

COMMENT ON TABLE public.job_events IS 'Immutable audit log of all job events';

-- =====================================================
-- TABLE: job_progress
-- =====================================================
-- Tracks job progress milestones

CREATE TABLE IF NOT EXISTS public.job_progress (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid UNIQUE NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  contract_id uuid REFERENCES public.job_contracts(id) ON DELETE SET NULL,
  
  -- Progress milestones
  mechanic_departed_at timestamptz,
  mechanic_arrived_at timestamptz,
  customer_confirmed_arrival_at timestamptz,
  work_started_at timestamptz,
  
  -- Completion (dual-confirmation)
  mechanic_completed_at timestamptz,
  customer_completed_at timestamptz,
  finalized_at timestamptz,            -- When both confirmed
  
  -- Location tracking (optional)
  mechanic_departure_lat double precision,
  mechanic_departure_lng double precision,
  mechanic_arrival_lat double precision,
  mechanic_arrival_lng double precision,
  
  -- Time tracking
  estimated_arrival_at timestamptz,
  actual_work_duration_minutes int,
  
  -- Timestamps
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.job_progress IS 'Tracks job progress through milestones';

-- =====================================================
-- TABLE: disputes
-- =====================================================

CREATE TABLE IF NOT EXISTS public.disputes (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  contract_id uuid REFERENCES public.job_contracts(id) ON DELETE SET NULL,
  
  -- Parties
  filed_by uuid NOT NULL REFERENCES public.profiles(id),
  filed_by_role public.user_role NOT NULL,
  filed_against uuid NOT NULL REFERENCES public.profiles(id),
  
  -- Status
  status public.dispute_status DEFAULT 'open' NOT NULL,
  
  -- Dispute details
  category text NOT NULL,              -- 'quality', 'no_show', 'overcharge', 'damage', 'other'
  description text NOT NULL,
  desired_resolution text,
  
  -- Evidence
  evidence_urls text[],
  
  -- Resolution
  resolved_at timestamptz,
  resolved_by uuid REFERENCES public.profiles(id),
  resolution_type text,                -- 'full_refund', 'partial_refund', 'no_refund', 'split'
  resolution_notes text,
  customer_refund_cents int,
  mechanic_adjustment_cents int,
  
  -- Platform notes (internal)
  internal_notes text,
  assigned_to text,                    -- Support agent email
  priority text DEFAULT 'normal',
  
  -- Deadlines
  response_deadline timestamptz,
  evidence_deadline timestamptz,
  
  -- Timestamps
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  
  -- Can only have one open dispute per job
  CONSTRAINT one_open_dispute_per_job UNIQUE (job_id, status) 
    DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE public.disputes IS 'Dispute records between customers and mechanics';

-- =====================================================
-- TABLE: payouts
-- =====================================================

CREATE TABLE IF NOT EXISTS public.payouts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  contract_id uuid NOT NULL REFERENCES public.job_contracts(id) ON DELETE CASCADE,
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Amounts
  gross_amount_cents int NOT NULL,     -- Original job amount
  commission_cents int NOT NULL,       -- Platform commission deducted
  adjustments_cents int DEFAULT 0,     -- Any adjustments (disputes, etc.)
  net_amount_cents int NOT NULL,       -- Final payout amount
  
  -- Status
  status public.payout_status DEFAULT 'pending' NOT NULL,
  
  -- Stripe
  stripe_transfer_id text,
  stripe_payout_id text,
  
  -- Processing
  scheduled_for timestamptz,
  processed_at timestamptz,
  failed_at timestamptz,
  failure_reason text,
  
  -- Hold info
  held_at timestamptz,
  hold_reason text,
  released_at timestamptz,
  
  -- Timestamps
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  
  UNIQUE(contract_id)
);

COMMENT ON TABLE public.payouts IS 'Mechanic payout records';

-- =====================================================
-- TABLE: reviews (update for blind reviews)
-- =====================================================

-- Add columns for blind review system
ALTER TABLE public.reviews 
  ADD COLUMN IF NOT EXISTS is_visible boolean DEFAULT false,
  ADD COLUMN IF NOT EXISTS made_visible_at timestamptz,
  ADD COLUMN IF NOT EXISTS visibility_reason text;

COMMENT ON COLUMN public.reviews.is_visible IS 'Whether review is visible to other party (blind until both submit)';

-- =====================================================
-- TABLE: job_media
-- =====================================================
-- Before/after photos linked to jobs

CREATE TABLE IF NOT EXISTS public.job_media (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  contract_id uuid REFERENCES public.job_contracts(id) ON DELETE SET NULL,
  
  -- Uploader
  uploaded_by uuid NOT NULL REFERENCES public.profiles(id),
  uploaded_by_role public.user_role NOT NULL,
  
  -- Media info
  media_type text NOT NULL,            -- 'image', 'video'
  media_category text NOT NULL,        -- 'before', 'during', 'after', 'issue', 'receipt'
  
  -- Storage
  bucket text DEFAULT 'job-media',
  path text NOT NULL,
  public_url text,
  thumbnail_url text,
  
  -- Metadata
  caption text,
  file_size_bytes bigint,
  mime_type text,
  
  -- Timestamps
  taken_at timestamptz,                -- When photo was taken (from EXIF)
  created_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.job_media IS 'Photos and videos for jobs (before/after)';

-- =====================================================
-- INDEXES
-- =====================================================

CREATE INDEX IF NOT EXISTS idx_job_contracts_job_id ON public.job_contracts(job_id);
CREATE INDEX IF NOT EXISTS idx_job_contracts_customer_id ON public.job_contracts(customer_id);
CREATE INDEX IF NOT EXISTS idx_job_contracts_mechanic_id ON public.job_contracts(mechanic_id);
CREATE INDEX IF NOT EXISTS idx_job_contracts_status ON public.job_contracts(status);

CREATE INDEX IF NOT EXISTS idx_invoice_line_items_contract_id ON public.invoice_line_items(contract_id);
CREATE INDEX IF NOT EXISTS idx_invoice_line_items_approval_status ON public.invoice_line_items(approval_status);

CREATE INDEX IF NOT EXISTS idx_job_events_job_id ON public.job_events(job_id);
CREATE INDEX IF NOT EXISTS idx_job_events_contract_id ON public.job_events(contract_id);
CREATE INDEX IF NOT EXISTS idx_job_events_event_type ON public.job_events(event_type);
CREATE INDEX IF NOT EXISTS idx_job_events_created_at ON public.job_events(created_at);

CREATE INDEX IF NOT EXISTS idx_job_progress_job_id ON public.job_progress(job_id);

CREATE INDEX IF NOT EXISTS idx_disputes_job_id ON public.disputes(job_id);
CREATE INDEX IF NOT EXISTS idx_disputes_filed_by ON public.disputes(filed_by);
CREATE INDEX IF NOT EXISTS idx_disputes_status ON public.disputes(status);

CREATE INDEX IF NOT EXISTS idx_payouts_mechanic_id ON public.payouts(mechanic_id);
CREATE INDEX IF NOT EXISTS idx_payouts_status ON public.payouts(status);

CREATE INDEX IF NOT EXISTS idx_job_media_job_id ON public.job_media(job_id);

COMMIT;
\n-- ===================================================================
-- END: 0006_job_lifecycle.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0007_job_lifecycle_functions.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0008: JOB LIFECYCLE FUNCTIONS
-- =====================================================
-- Purpose: State machine functions for job lifecycle
-- =====================================================

BEGIN;

-- =====================================================
-- HELPER: Calculate mechanic commission
-- =====================================================

CREATE OR REPLACE FUNCTION calculate_mechanic_commission(price_cents int)
RETURNS int
LANGUAGE plpgsql
AS $$
DECLARE
  commission int;
BEGIN
  -- 12% commission, capped at $50 (5000 cents)
  commission := LEAST(ROUND(price_cents * 0.12)::int, 5000);
  RETURN commission;
END;
$$;

-- =====================================================
-- HELPER: Log job event
-- =====================================================

CREATE OR REPLACE FUNCTION log_job_event(
  p_job_id uuid,
  p_contract_id uuid,
  p_event_type public.job_event_type,
  p_actor_id uuid,
  p_actor_role public.user_role,
  p_title text,
  p_description text DEFAULT NULL,
  p_metadata jsonb DEFAULT '{}',
  p_amount_cents int DEFAULT NULL,
  p_visible_to_customer boolean DEFAULT true,
  p_visible_to_mechanic boolean DEFAULT true,
  p_is_system_message boolean DEFAULT false
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  event_id uuid;
BEGIN
  INSERT INTO public.job_events (
    job_id, contract_id, event_type, actor_id, actor_role,
    title, description, metadata, amount_cents,
    visible_to_customer, visible_to_mechanic, is_system_message
  ) VALUES (
    p_job_id, p_contract_id, p_event_type, p_actor_id, p_actor_role,
    p_title, p_description, p_metadata, p_amount_cents,
    p_visible_to_customer, p_visible_to_mechanic, p_is_system_message
  )
  RETURNING id INTO event_id;
  
  RETURN event_id;
END;
$$;

-- =====================================================
-- FUNCTION: Accept quote and create contract
-- =====================================================

CREATE OR REPLACE FUNCTION accept_quote_and_create_contract(
  p_quote_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_quote RECORD;
  v_job RECORD;
  v_contract_id uuid;
  v_progress_id uuid;
  v_platform_fee_cents int := 1500;  -- $15
  v_commission_cents int;
  v_total_customer_cents int;
  v_mechanic_payout_cents int;
  v_line_item_id uuid;
BEGIN
  -- Get quote with lock
  SELECT q.*, j.customer_id as job_customer_id, j.status as job_status
  INTO v_quote
  FROM public.quotes q
  JOIN public.jobs j ON j.id = q.job_id
  WHERE q.id = p_quote_id
  FOR UPDATE OF q, j;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote not found');
  END IF;
  
  -- Validate customer owns the job
  IF v_quote.job_customer_id != p_customer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  -- Validate quote is pending
  IF v_quote.status != 'pending' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote is no longer available');
  END IF;
  
  -- Validate job is in correct state
  IF v_quote.job_status NOT IN ('searching', 'quoted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job is no longer accepting quotes');
  END IF;
  
  -- Calculate fees
  v_commission_cents := calculate_mechanic_commission(v_quote.price_cents);
  v_total_customer_cents := v_quote.price_cents + v_platform_fee_cents;
  v_mechanic_payout_cents := v_quote.price_cents - v_commission_cents;
  
  -- Create contract
  INSERT INTO public.job_contracts (
    job_id, quote_id, customer_id, mechanic_id,
    status, quoted_price_cents, platform_fee_cents, estimated_hours,
    subtotal_cents, total_customer_cents, mechanic_commission_cents, mechanic_payout_cents
  ) VALUES (
    v_quote.job_id, p_quote_id, p_customer_id, v_quote.mechanic_id,
    'active', v_quote.price_cents, v_platform_fee_cents, v_quote.estimated_hours,
    v_quote.price_cents, v_total_customer_cents, v_commission_cents, v_mechanic_payout_cents
  )
  RETURNING id INTO v_contract_id;
  
  -- Create initial line item for base labor
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'base_labor', 'Service as quoted', 1, v_quote.price_cents, v_quote.price_cents,
    'approved', false, v_quote.mechanic_id, 'mechanic', 0
  )
  RETURNING id INTO v_line_item_id;
  
  -- Create platform fee line item
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'platform_fee', 'WrenchGo platform fee', 1, v_platform_fee_cents, v_platform_fee_cents,
    'approved', false, p_customer_id, 'customer', 100
  );
  
  -- Create job progress record
  INSERT INTO public.job_progress (job_id, contract_id)
  VALUES (v_quote.job_id, v_contract_id)
  RETURNING id INTO v_progress_id;
  
  -- Update quote status
  UPDATE public.quotes
  SET status = 'accepted', updated_at = now()
  WHERE id = p_quote_id;
  
  -- Decline all other quotes for this job
  UPDATE public.quotes
  SET status = 'declined', updated_at = now()
  WHERE job_id = v_quote.job_id AND id != p_quote_id;
  
  -- Update job status
  UPDATE public.jobs
  SET 
    status = 'accepted',
    accepted_mechanic_id = v_quote.mechanic_id,
    updated_at = now()
  WHERE id = v_quote.job_id;
  
  -- Log event
  PERFORM log_job_event(
    v_quote.job_id, v_contract_id, 'contract_created',
    p_customer_id, 'customer',
    'Contract created',
    'Quote accepted and contract created',
    jsonb_build_object(
      'quoted_price_cents', v_quote.price_cents,
      'platform_fee_cents', v_platform_fee_cents,
      'total_cents', v_total_customer_cents
    ),
    v_total_customer_cents
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'contract_id', v_contract_id,
    'total_cents', v_total_customer_cents,
    'mechanic_id', v_quote.mechanic_id
  );
END;
$$;

-- =====================================================
-- FUNCTION: Mechanic marks departure
-- =====================================================

CREATE OR REPLACE FUNCTION mechanic_mark_departed(
  p_job_id uuid,
  p_mechanic_id uuid,
  p_departure_lat double precision DEFAULT NULL,
  p_departure_lng double precision DEFAULT NULL,
  p_estimated_arrival_minutes int DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_contract RECORD;
  v_estimated_arrival timestamptz;
BEGIN
  -- Get contract with lock
  SELECT c.*, jp.mechanic_departed_at
  INTO v_contract
  FROM public.job_contracts c
  JOIN public.job_progress jp ON jp.contract_id = c.id
  WHERE c.job_id = p_job_id AND c.mechanic_id = p_mechanic_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract not found');
  END IF;
  
  IF v_contract.status != 'active' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract is not active');
  END IF;
  
  IF v_contract.mechanic_departed_at IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Already marked as departed');
  END IF;
  
  -- Calculate estimated arrival
  IF p_estimated_arrival_minutes IS NOT NULL THEN
    v_estimated_arrival := now() + (p_estimated_arrival_minutes || ' minutes')::interval;
  END IF;
  
  -- Update progress
  UPDATE public.job_progress
  SET 
    mechanic_departed_at = now(),
    mechanic_departure_lat = p_departure_lat,
    mechanic_departure_lng = p_departure_lng,
    estimated_arrival_at = v_estimated_arrival,
    updated_at = now()
  WHERE contract_id = v_contract.id;
  
  -- Update job status
  UPDATE public.jobs
  SET status = 'scheduled', updated_at = now()
  WHERE id = p_job_id;
  
  -- Log event
  PERFORM log_job_event(
    p_job_id, v_contract.id, 'mechanic_departed',
    p_mechanic_id, 'mechanic',
    'Mechanic on the way',
    CASE WHEN p_estimated_arrival_minutes IS NOT NULL 
      THEN 'Estimated arrival in ' || p_estimated_arrival_minutes || ' minutes'
      ELSE 'Mechanic has departed for the job location'
    END,
    jsonb_build_object('estimated_minutes', p_estimated_arrival_minutes)
  );
  
  RETURN jsonb_build_object('success', true);
END;
$$;

-- =====================================================
-- FUNCTION: Mechanic marks arrival
-- =====================================================

CREATE OR REPLACE FUNCTION mechanic_mark_arrived(
  p_job_id uuid,
  p_mechanic_id uuid,
  p_arrival_lat double precision DEFAULT NULL,
  p_arrival_lng double precision DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_contract RECORD;
BEGIN
  -- Get contract with lock
  SELECT c.*, jp.mechanic_departed_at, jp.mechanic_arrived_at
  INTO v_contract
  FROM public.job_contracts c
  JOIN public.job_progress jp ON jp.contract_id = c.id
  WHERE c.job_id = p_job_id AND c.mechanic_id = p_mechanic_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract not found');
  END IF;
  
  IF v_contract.status != 'active' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract is not active');
  END IF;
  
  IF v_contract.mechanic_arrived_at IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Already marked as arrived');
  END IF;
  
  -- Update progress
  UPDATE public.job_progress
  SET 
    mechanic_arrived_at = now(),
    mechanic_arrival_lat = p_arrival_lat,
    mechanic_arrival_lng = p_arrival_lng,
    updated_at = now()
  WHERE contract_id = v_contract.id;
  
  -- Log event
  PERFORM log_job_event(
    p_job_id, v_contract.id, 'mechanic_arrived',
    p_mechanic_id, 'mechanic',
    'Mechanic arrived',
    'Mechanic has arrived at the job location. Waiting for customer confirmation.',
    jsonb_build_object()
  );
  
  RETURN jsonb_build_object('success', true);
END;
$$;

-- =====================================================
-- FUNCTION: Customer confirms mechanic arrival
-- =====================================================

CREATE OR REPLACE FUNCTION customer_confirm_arrival(
  p_job_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_contract RECORD;
BEGIN
  -- Get contract with lock
  SELECT c.*, jp.mechanic_arrived_at, jp.customer_confirmed_arrival_at
  INTO v_contract
  FROM public.job_contracts c
  JOIN public.job_progress jp ON jp.contract_id = c.id
  WHERE c.job_id = p_job_id AND c.customer_id = p_customer_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract not found');
  END IF;
  
  IF v_contract.status != 'active' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract is not active');
  END IF;
  
  IF v_contract.mechanic_arrived_at IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Mechanic has not marked arrival yet');
  END IF;
  
  IF v_contract.customer_confirmed_arrival_at IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Already confirmed');
  END IF;
  
  -- Update progress
  UPDATE public.job_progress
  SET 
    customer_confirmed_arrival_at = now(),
    updated_at = now()
  WHERE contract_id = v_contract.id;
  
  -- Log event
  PERFORM log_job_event(
    p_job_id, v_contract.id, 'customer_confirmed_arrival',
    p_customer_id, 'customer',
    'Arrival confirmed',
    'Customer confirmed mechanic arrival. Work can now begin.',
    jsonb_build_object()
  );
  
  RETURN jsonb_build_object('success', true);
END;
$$;

-- =====================================================
-- FUNCTION: Mechanic starts work
-- =====================================================

CREATE OR REPLACE FUNCTION mechanic_start_work(
  p_job_id uuid,
  p_mechanic_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_contract RECORD;
BEGIN
  -- Get contract with lock
  SELECT c.*, jp.customer_confirmed_arrival_at, jp.work_started_at
  INTO v_contract
  FROM public.job_contracts c
  JOIN public.job_progress jp ON jp.contract_id = c.id
  WHERE c.job_id = p_job_id AND c.mechanic_id = p_mechanic_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract not found');
  END IF;
  
  IF v_contract.status != 'active' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract is not active');
  END IF;
  
  IF v_contract.customer_confirmed_arrival_at IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Customer must confirm arrival first');
  END IF;
  
  IF v_contract.work_started_at IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Work already started');
  END IF;
  
  -- Update progress
  UPDATE public.job_progress
  SET 
    work_started_at = now(),
    updated_at = now()
  WHERE contract_id = v_contract.id;
  
  -- Update job status
  UPDATE public.jobs
  SET status = 'in_progress', updated_at = now()
  WHERE id = p_job_id;
  
  -- Log event
  PERFORM log_job_event(
    p_job_id, v_contract.id, 'work_started',
    p_mechanic_id, 'mechanic',
    'Work started',
    'Mechanic has started working on the job.',
    jsonb_build_object()
  );
  
  RETURN jsonb_build_object('success', true);
END;
$$;

-- =====================================================
-- FUNCTION: Add invoice line item
-- =====================================================

CREATE OR REPLACE FUNCTION add_invoice_line_item(
  p_job_id uuid,
  p_mechanic_id uuid,
  p_item_type public.line_item_type,
  p_description text,
  p_quantity numeric,
  p_unit_price_cents int,
  p_notes text DEFAULT NULL,
  p_part_number text DEFAULT NULL,
  p_part_source text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_contract RECORD;
  v_line_item_id uuid;
  v_total_cents int;
  v_approval_deadline timestamptz;
  v_max_sort int;
BEGIN
  -- Get contract
  SELECT c.*, jp.work_started_at
  INTO v_contract
  FROM public.job_contracts c
  JOIN public.job_progress jp ON jp.contract_id = c.id
  WHERE c.job_id = p_job_id AND c.mechanic_id = p_mechanic_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract not found');
  END IF;
  
  IF v_contract.status != 'active' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract is not active');
  END IF;
  
  IF v_contract.work_started_at IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Work must be started first');
  END IF;
  
  -- Calculate total
  v_total_cents := ROUND(p_quantity * p_unit_price_cents)::int;
  
  -- Set approval deadline (24 hours from now)
  v_approval_deadline := now() + interval '24 hours';
  
  -- Get max sort order
  SELECT COALESCE(MAX(sort_order), 0) + 1 INTO v_max_sort
  FROM public.invoice_line_items
  WHERE contract_id = v_contract.id;
  
  -- Insert line item
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, approval_deadline,
    added_by, added_by_role, notes, part_number, part_source, sort_order
  ) VALUES (
    v_contract.id, p_item_type, p_description, p_quantity, p_unit_price_cents, v_total_cents,
    'pending', true, v_approval_deadline,
    p_mechanic_id, 'mechanic', p_notes, p_part_number, p_part_source, v_max_sort
  )
  RETURNING id INTO v_line_item_id;
  
  -- Log event
  PERFORM log_job_event(
    p_job_id, v_contract.id, 'line_item_added',
    p_mechanic_id, 'mechanic',
    'Additional item requested',
    p_description || ' - $' || ROUND(v_total_cents / 100.0, 2)::text,
    jsonb_build_object(
      'line_item_id', v_line_item_id,
      'item_type', p_item_type,
      'amount_cents', v_total_cents
    ),
    v_total_cents
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'line_item_id', v_line_item_id,
    'total_cents', v_total_cents,
    'approval_deadline', v_approval_deadline
  );
END;
$$;

-- =====================================================
-- FUNCTION: Customer approves/rejects line item
-- =====================================================

CREATE OR REPLACE FUNCTION customer_respond_to_line_item(
  p_line_item_id uuid,
  p_customer_id uuid,
  p_approved boolean,
  p_rejection_reason text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_item RECORD;
  v_contract RECORD;
  v_new_subtotal int;
  v_new_total int;
  v_new_commission int;
  v_new_payout int;
BEGIN
  -- Get line item with contract
  SELECT li.*, c.id as contract_id, c.customer_id, c.job_id, c.platform_fee_cents
  INTO v_item
  FROM public.invoice_line_items li
  JOIN public.job_contracts c ON c.id = li.contract_id
  WHERE li.id = p_line_item_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Line item not found');
  END IF;
  
  IF v_item.customer_id != p_customer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  IF v_item.approval_status != 'pending' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Item already processed');
  END IF;
  
  -- Update line item
  IF p_approved THEN
    UPDATE public.invoice_line_items
    SET 
      approval_status = 'approved',
      approved_at = now(),
      approved_by = p_customer_id,
      updated_at = now()
    WHERE id = p_line_item_id;
    
    -- Recalculate contract totals
    SELECT SUM(total_cents) INTO v_new_subtotal
    FROM public.invoice_line_items
    WHERE contract_id = v_item.contract_id
    AND approval_status = 'approved'
    AND item_type != 'platform_fee';
    
    v_new_commission := calculate_mechanic_commission(v_new_subtotal);
    v_new_total := v_new_subtotal + v_item.platform_fee_cents;
    v_new_payout := v_new_subtotal - v_new_commission;
    
    UPDATE public.job_contracts
    SET 
      subtotal_cents = v_new_subtotal,
      total_customer_cents = v_new_total,
      mechanic_commission_cents = v_new_commission,
      mechanic_payout_cents = v_new_payout,
      updated_at = now()
    WHERE id = v_item.contract_id;
    
    -- Log event
    PERFORM log_job_event(
      v_item.job_id, v_item.contract_id, 'line_item_approved',
      p_customer_id, 'customer',
      'Additional item approved',
      v_item.description,
      jsonb_build_object('line_item_id', p_line_item_id, 'amount_cents', v_item.total_cents),
      v_item.total_cents
    );
  ELSE
    UPDATE public.invoice_line_items
    SET 
      approval_status = 'rejected',
      rejected_at = now(),
      rejected_by = p_customer_id,
      rejection_reason = p_rejection_reason,
      updated_at = now()
    WHERE id = p_line_item_id;
    
    -- Log event
    PERFORM log_job_event(
      v_item.job_id, v_item.contract_id, 'line_item_rejected',
      p_customer_id, 'customer',
      'Additional item rejected',
      v_item.description || COALESCE(' - Reason: ' || p_rejection_reason, ''),
      jsonb_build_object('line_item_id', p_line_item_id, 'reason', p_rejection_reason)
    );
  END IF;
  
  RETURN jsonb_build_object('success', true, 'approved', p_approved);
END;
$$;

-- =====================================================
-- FUNCTION: Mechanic marks work complete
-- =====================================================

CREATE OR REPLACE FUNCTION mechanic_mark_complete(
  p_job_id uuid,
  p_mechanic_id uuid,
  p_work_summary text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_contract RECORD;
  v_pending_items int;
BEGIN
  -- Get contract
  SELECT c.*, jp.work_started_at, jp.mechanic_completed_at, jp.customer_completed_at
  INTO v_contract
  FROM public.job_contracts c
  JOIN public.job_progress jp ON jp.contract_id = c.id
  WHERE c.job_id = p_job_id AND c.mechanic_id = p_mechanic_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract not found');
  END IF;
  
  IF v_contract.status != 'active' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract is not active');
  END IF;
  
  IF v_contract.work_started_at IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Work has not been started');
  END IF;
  
  IF v_contract.mechanic_completed_at IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Already marked as complete');
  END IF;
  
  -- Check for pending line items
  SELECT COUNT(*) INTO v_pending_items
  FROM public.invoice_line_items
  WHERE contract_id = v_contract.id AND approval_status = 'pending';
  
  IF v_pending_items > 0 THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'There are ' || v_pending_items || ' pending line items awaiting customer approval'
    );
  END IF;
  
  -- Update progress
  UPDATE public.job_progress
  SET 
    mechanic_completed_at = now(),
    actual_work_duration_minutes = EXTRACT(EPOCH FROM (now() - work_started_at)) / 60,
    updated_at = now()
  WHERE contract_id = v_contract.id;
  
  -- Log event
  PERFORM log_job_event(
    p_job_id, v_contract.id, 'work_completed_mechanic',
    p_mechanic_id, 'mechanic',
    'Work completed',
    COALESCE(p_work_summary, 'Mechanic has marked the work as complete. Awaiting customer confirmation.'),
    jsonb_build_object('summary', p_work_summary)
  );
  
  -- Check if customer also completed (finalize if so)
  IF v_contract.customer_completed_at IS NOT NULL THEN
    PERFORM finalize_job(p_job_id);
  END IF;
  
  RETURN jsonb_build_object('success', true, 'awaiting_customer', v_contract.customer_completed_at IS NULL);
END;
$$;

-- =====================================================
-- FUNCTION: Customer confirms completion
-- =====================================================

CREATE OR REPLACE FUNCTION customer_confirm_complete(
  p_job_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_contract RECORD;
BEGIN
  -- Get contract
  SELECT c.*, jp.work_started_at, jp.mechanic_completed_at, jp.customer_completed_at
  INTO v_contract
  FROM public.job_contracts c
  JOIN public.job_progress jp ON jp.contract_id = c.id
  WHERE c.job_id = p_job_id AND c.customer_id = p_customer_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract not found');
  END IF;
  
  IF v_contract.status != 'active' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract is not active');
  END IF;
  
  IF v_contract.customer_completed_at IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Already confirmed');
  END IF;
  
  -- Update progress
  UPDATE public.job_progress
  SET 
    customer_completed_at = now(),
    updated_at = now()
  WHERE contract_id = v_contract.id;
  
  -- Log event
  PERFORM log_job_event(
    p_job_id, v_contract.id, 'work_completed_customer',
    p_customer_id, 'customer',
    'Completion confirmed',
    'Customer has confirmed the work is complete.',
    jsonb_build_object()
  );
  
  -- Check if mechanic also completed (finalize if so)
  IF v_contract.mechanic_completed_at IS NOT NULL THEN
    PERFORM finalize_job(p_job_id);
  END IF;
  
  RETURN jsonb_build_object('success', true, 'awaiting_mechanic', v_contract.mechanic_completed_at IS NULL);
END;
$$;

-- =====================================================
-- FUNCTION: Finalize job (internal)
-- =====================================================

CREATE OR REPLACE FUNCTION finalize_job(p_job_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_contract RECORD;
BEGIN
  -- Get contract
  SELECT c.*
  INTO v_contract
  FROM public.job_contracts c
  WHERE c.job_id = p_job_id
  FOR UPDATE;
  
  IF NOT FOUND OR v_contract.status != 'active' THEN
    RETURN;
  END IF;
  
  -- Update progress
  UPDATE public.job_progress
  SET finalized_at = now(), updated_at = now()
  WHERE contract_id = v_contract.id;
  
  -- Update contract
  UPDATE public.job_contracts
  SET status = 'completed', updated_at = now()
  WHERE id = v_contract.id;
  
  -- Update job
  UPDATE public.jobs
  SET 
    status = 'completed',
    completed_at = now(),
    final_price_cents = v_contract.subtotal_cents,
    updated_at = now()
  WHERE id = p_job_id;
  
  -- Create payout record
  INSERT INTO public.payouts (
    contract_id, mechanic_id,
    gross_amount_cents, commission_cents, net_amount_cents,
    status, scheduled_for
  ) VALUES (
    v_contract.id, v_contract.mechanic_id,
    v_contract.subtotal_cents, v_contract.mechanic_commission_cents, v_contract.mechanic_payout_cents,
    'pending', now() + interval '2 days'
  );
  
  -- Log event
  PERFORM log_job_event(
    p_job_id, v_contract.id, 'job_finalized',
    NULL, NULL,
    'Job completed',
    'Both parties confirmed completion. Payment will be processed.',
    jsonb_build_object(
      'total_cents', v_contract.total_customer_cents,
      'mechanic_payout_cents', v_contract.mechanic_payout_cents
    ),
    v_contract.total_customer_cents,
    true, true, true
  );
END;
$$;

-- =====================================================
-- FUNCTION: Cancel job
-- =====================================================

CREATE OR REPLACE FUNCTION cancel_job(
  p_job_id uuid,
  p_cancelled_by uuid,
  p_reason public.cancellation_reason,
  p_note text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_contract RECORD;
  v_refund_amount int;
  v_is_customer boolean;
BEGIN
  -- Get contract
  SELECT c.*, jp.*
  INTO v_contract
  FROM public.job_contracts c
  LEFT JOIN public.job_progress jp ON jp.contract_id = c.id
  WHERE c.job_id = p_job_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract not found');
  END IF;
  
  IF v_contract.status NOT IN ('pending_payment', 'active') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Cannot cancel - job is ' || v_contract.status);
  END IF;
  
  -- Determine if canceller is customer
  v_is_customer := (p_cancelled_by = v_contract.customer_id);
  
  -- Calculate refund based on reason
  CASE p_reason
    WHEN 'customer_before_departure', 'mechanic_before_departure', 'mechanic_no_show' THEN
      v_refund_amount := v_contract.total_customer_cents;  -- Full refund
    WHEN 'customer_after_departure' THEN
      v_refund_amount := v_contract.total_customer_cents - 2500;  -- Minus $25 travel fee
    WHEN 'customer_after_arrival', 'customer_no_show' THEN
      v_refund_amount := v_contract.total_customer_cents - 2500;  -- Minus $25 travel fee
    WHEN 'customer_after_work_started' THEN
      v_refund_amount := 0;  -- No refund after work started
    WHEN 'mutual_agreement', 'platform_intervention' THEN
      v_refund_amount := v_contract.total_customer_cents;  -- Full refund (can be adjusted)
    ELSE
      v_refund_amount := v_contract.total_customer_cents;
  END CASE;
  
  -- Ensure refund is not negative
  v_refund_amount := GREATEST(v_refund_amount, 0);
  
  -- Update contract
  UPDATE public.job_contracts
  SET 
    status = 'cancelled',
    cancelled_at = now(),
    cancelled_by = p_cancelled_by,
    cancellation_reason = p_reason,
    cancellation_note = p_note,
    refund_amount_cents = v_refund_amount,
    updated_at = now()
  WHERE id = v_contract.id;
  
  -- Update job
  UPDATE public.jobs
  SET 
    status = 'cancelled',
    cancelled_at = now(),
    canceled_by = p_cancelled_by,
    updated_at = now()
  WHERE id = p_job_id;
  
  -- Log event
  PERFORM log_job_event(
    p_job_id, v_contract.id, 'cancelled',
    p_cancelled_by, CASE WHEN v_is_customer THEN 'customer'::public.user_role ELSE 'mechanic'::public.user_role END,
    'Job cancelled',
    COALESCE(p_note, 'Job was cancelled: ' || p_reason::text),
    jsonb_build_object(
      'reason', p_reason,
      'refund_amount_cents', v_refund_amount,
      'cancelled_by_customer', v_is_customer
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'refund_amount_cents', v_refund_amount
  );
END;
$$;

-- =====================================================
-- FUNCTION: Make reviews visible (blind review reveal)
-- =====================================================

CREATE OR REPLACE FUNCTION reveal_reviews_for_job(p_job_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Check if both reviews exist
  IF (SELECT COUNT(*) FROM public.reviews WHERE job_id = p_job_id) >= 2 THEN
    UPDATE public.reviews
    SET 
      is_visible = true,
      made_visible_at = now(),
      visibility_reason = 'both_submitted'
    WHERE job_id = p_job_id AND is_visible = false;
  END IF;
END;
$$;

-- =====================================================
-- TRIGGER: Auto-reveal reviews when both submitted
-- =====================================================

CREATE OR REPLACE FUNCTION trigger_check_review_visibility()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  PERFORM reveal_reviews_for_job(NEW.job_id);
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_check_review_visibility ON public.reviews;
CREATE TRIGGER trg_check_review_visibility
  AFTER INSERT ON public.reviews
  FOR EACH ROW
  EXECUTE FUNCTION trigger_check_review_visibility();

COMMIT;
\n-- ===================================================================
-- END: 0007_job_lifecycle_functions.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0008_quotes_customer_update.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0009: Allow customers to update quotes
-- =====================================================
-- Purpose: Add RLS policy for customers to accept/reject quotes
-- Depends on: 0002_rls_policies.sql
-- =====================================================

BEGIN;

-- Allow customers to update quotes for their jobs (accept/reject)
DROP POLICY IF EXISTS "quotes_update_customer" ON public.quotes;
CREATE POLICY "quotes_update_customer" ON public.quotes
  FOR UPDATE TO authenticated
  USING (
    job_id IN (SELECT id FROM jobs WHERE customer_id = auth.uid())
  )
  WITH CHECK (
    job_id IN (SELECT id FROM jobs WHERE customer_id = auth.uid())
  );

COMMIT;\n-- ===================================================================
-- END: 0008_quotes_customer_update.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0009_notify_user_function.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0010: Notify user function
-- =====================================================
-- Purpose: SECURITY DEFINER function to send notifications to any user
-- Depends on: 0002_rls_policies.sql
-- =====================================================

BEGIN;

CREATE OR REPLACE FUNCTION public.notify_user(
  p_user_id uuid,
  p_title text,
  p_body text,
  p_type text DEFAULT 'general',
  p_entity_type text DEFAULT NULL,
  p_entity_id uuid DEFAULT NULL
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_notification_id uuid;
BEGIN
  INSERT INTO public.notifications (
    user_id,
    title,
    body,
    type,
    entity_type,
    entity_id,
    is_read,
    created_at
  ) VALUES (
    p_user_id,
    p_title,
    p_body,
    p_type,
    p_entity_type,
    p_entity_id,
    false,
    now()
  )
  RETURNING id INTO v_notification_id;

  RETURN v_notification_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.notify_user TO authenticated;

COMMIT;\n-- ===================================================================
-- END: 0009_notify_user_function.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0010_trust_system.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0010: TRUST & REPUTATION SYSTEM
-- =====================================================
-- Purpose: Post-completion trust system with blind reviews,
--          badges, skill verification, and trust scores
-- =====================================================

BEGIN;

-- =====================================================
-- ENUMS
-- =====================================================

DO $$ BEGIN
  CREATE TYPE public.badge_category AS ENUM (
    'milestone',        -- Jobs completed milestones
    'quality',          -- Rating-based badges
    'reliability',      -- On-time, completion rate
    'skill',            -- Skill verification badges
    'special'           -- Platform-awarded special badges
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  CREATE TYPE public.review_visibility AS ENUM (
    'hidden',           -- Not yet visible (blind period)
    'visible',          -- Visible to all
    'moderated'         -- Hidden by moderation
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  CREATE TYPE public.moderation_status AS ENUM (
    'pending',
    'approved',
    'rejected',
    'flagged'
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  CREATE TYPE public.report_reason AS ENUM (
    'fake_review',
    'harassment',
    'spam',
    'inappropriate',
    'conflict_of_interest',
    'other'
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- =====================================================
-- ALTER TABLE: badges (add new columns to existing table)
-- Using text type for category to avoid enum issues
-- =====================================================
ALTER TABLE public.badges
  ADD COLUMN IF NOT EXISTS category text,
  ADD COLUMN IF NOT EXISTS tier int DEFAULT 1,
  ADD COLUMN IF NOT EXISTS criteria_type text,
  ADD COLUMN IF NOT EXISTS criteria_threshold numeric,
  ADD COLUMN IF NOT EXISTS criteria_window_days int,
  ADD COLUMN IF NOT EXISTS is_active boolean DEFAULT true,
  ADD COLUMN IF NOT EXISTS display_priority int DEFAULT 100;

-- Update existing badges to have defaults
UPDATE public.badges SET category = 'special' WHERE category IS NULL;
UPDATE public.badges SET criteria_type = 'manual' WHERE criteria_type IS NULL;
UPDATE public.badges SET criteria_threshold = 0 WHERE criteria_threshold IS NULL;

-- =====================================================
-- ALTER TABLE: user_badges (add new columns)
-- =====================================================
ALTER TABLE public.user_badges
  ADD COLUMN IF NOT EXISTS awarded_reason text,
  ADD COLUMN IF NOT EXISTS revoked_at timestamptz,
  ADD COLUMN IF NOT EXISTS revoked_reason text,
  ADD COLUMN IF NOT EXISTS job_id uuid REFERENCES public.jobs(id);

-- =====================================================
-- TABLE: badge_history (audit trail)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.badge_history (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  badge_id uuid NOT NULL REFERENCES public.badges(id) ON DELETE CASCADE,
  action text NOT NULL,                   -- 'awarded', 'revoked', 'expired'
  reason text,
  triggered_by uuid REFERENCES public.profiles(id),
  job_id uuid REFERENCES public.jobs(id),
  metadata jsonb DEFAULT '{}',
  created_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.badge_history IS 'Audit trail for badge awards and revocations';

-- =====================================================
-- ALTER TABLE: reviews (add blind review columns)
-- =====================================================
ALTER TABLE public.reviews 
  ADD COLUMN IF NOT EXISTS visibility public.review_visibility DEFAULT 'hidden',
  ADD COLUMN IF NOT EXISTS made_visible_at timestamptz,
  ADD COLUMN IF NOT EXISTS visibility_reason text,
  ADD COLUMN IF NOT EXISTS blind_deadline timestamptz,
  ADD COLUMN IF NOT EXISTS moderation_status public.moderation_status DEFAULT 'approved',
  ADD COLUMN IF NOT EXISTS moderated_at timestamptz,
  ADD COLUMN IF NOT EXISTS moderated_by uuid REFERENCES public.profiles(id),
  ADD COLUMN IF NOT EXISTS moderation_note text,
  ADD COLUMN IF NOT EXISTS professionalism_rating int,
  ADD COLUMN IF NOT EXISTS communication_rating int,
  ADD COLUMN IF NOT EXISTS would_recommend boolean;

-- Add constraint for new rating columns
ALTER TABLE public.reviews DROP CONSTRAINT IF EXISTS reviews_professionalism_rating_range;
ALTER TABLE public.reviews ADD CONSTRAINT reviews_professionalism_rating_range 
  CHECK (professionalism_rating IS NULL OR (professionalism_rating >= 1 AND professionalism_rating <= 5));

ALTER TABLE public.reviews DROP CONSTRAINT IF EXISTS reviews_communication_rating_range;
ALTER TABLE public.reviews ADD CONSTRAINT reviews_communication_rating_range 
  CHECK (communication_rating IS NULL OR (communication_rating >= 1 AND communication_rating <= 5));

-- =====================================================
-- TABLE: review_media (photos attached to reviews)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.review_media (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  review_id uuid NOT NULL REFERENCES public.reviews(id) ON DELETE CASCADE,
  url text NOT NULL,
  thumbnail_url text,
  media_type text DEFAULT 'image',        -- 'image', 'video'
  caption text,
  sort_order int DEFAULT 0,
  is_before boolean DEFAULT false,        -- Before/after indicator
  moderation_status public.moderation_status DEFAULT 'pending',
  created_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.review_media IS 'Photos and media attached to reviews';

-- =====================================================
-- TABLE: review_reports (flagged reviews for moderation)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.review_reports (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  review_id uuid NOT NULL REFERENCES public.reviews(id) ON DELETE CASCADE,
  reported_by uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reason public.report_reason NOT NULL,
  details text,
  status public.moderation_status DEFAULT 'pending',
  resolved_at timestamptz,
  resolved_by uuid REFERENCES public.profiles(id),
  resolution_note text,
  created_at timestamptz DEFAULT now() NOT NULL,
  
  UNIQUE(review_id, reported_by)          -- One report per user per review
);

COMMENT ON TABLE public.review_reports IS 'User reports against reviews';

-- =====================================================
-- TABLE: skill_verifications (track skill verification via jobs)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.skill_verifications (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  skill_key text NOT NULL REFERENCES public.skills(key) ON DELETE CASCADE,
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  customer_rating int,                    -- Rating from customer on this job
  verification_weight numeric DEFAULT 1,  -- Weight based on job complexity
  verified_at timestamptz DEFAULT now() NOT NULL,
  
  UNIQUE(mechanic_id, skill_key, job_id)
);

COMMENT ON TABLE public.skill_verifications IS 'Track skill verifications through completed jobs';

-- =====================================================
-- ALTER TABLE: mechanic_skills (add verification counts)
-- =====================================================
ALTER TABLE public.mechanic_skills
  ADD COLUMN IF NOT EXISTS verified_job_count int DEFAULT 0,
  ADD COLUMN IF NOT EXISTS avg_job_rating numeric(3,2),
  ADD COLUMN IF NOT EXISTS last_verified_at timestamptz,
  ADD COLUMN IF NOT EXISTS is_verified boolean DEFAULT false;

-- =====================================================
-- TABLE: trust_scores (user trust/reputation scores)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.trust_scores (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Composite score (0-100)
  overall_score int DEFAULT 50 NOT NULL,
  
  -- Component scores (0-100 each)
  rating_score int DEFAULT 50,            -- Based on review ratings
  completion_score int DEFAULT 100,       -- Job completion rate
  reliability_score int DEFAULT 50,       -- On-time, cancellation rate
  badge_score int DEFAULT 0,              -- Badge weight
  tenure_score int DEFAULT 0,             -- Time on platform
  
  -- Stats
  total_jobs int DEFAULT 0,
  completed_jobs int DEFAULT 0,
  cancelled_jobs int DEFAULT 0,
  disputed_jobs int DEFAULT 0,
  no_show_count int DEFAULT 0,
  
  -- Review stats
  reviews_given int DEFAULT 0,
  reviews_received int DEFAULT 0,
  avg_rating_given numeric(3,2),
  avg_rating_received numeric(3,2),
  
  -- Timestamps
  last_calculated_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  
  UNIQUE(user_id)
);

COMMENT ON TABLE public.trust_scores IS 'Calculated trust/reputation scores for users';

-- =====================================================
-- TABLE: trust_score_history (snapshots for trending)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.trust_score_history (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  overall_score int NOT NULL,
  rating_score int,
  completion_score int,
  reliability_score int,
  badge_score int,
  tenure_score int,
  snapshot_reason text,                   -- 'job_completed', 'review_received', 'weekly', etc.
  job_id uuid REFERENCES public.jobs(id),
  created_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.trust_score_history IS 'Historical snapshots of trust scores';

-- =====================================================
-- TABLE: review_prompts (track pending review requests)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.review_prompts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  target_user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  user_role public.user_role NOT NULL,    -- Role of user being prompted
  prompted_at timestamptz DEFAULT now() NOT NULL,
  reminder_count int DEFAULT 0,
  last_reminder_at timestamptz,
  completed_at timestamptz,               -- When review was submitted
  expires_at timestamptz NOT NULL,        -- When prompt expires
  
  UNIQUE(job_id, user_id)
);

COMMENT ON TABLE public.review_prompts IS 'Track review prompts and reminders';

-- =====================================================
-- INDEXES
-- =====================================================

-- Badges
CREATE INDEX IF NOT EXISTS idx_badges_category ON public.badges(category);
CREATE INDEX IF NOT EXISTS idx_badges_active ON public.badges(is_active) WHERE is_active = true;

-- User badges
CREATE INDEX IF NOT EXISTS idx_user_badges_user ON public.user_badges(user_id);
CREATE INDEX IF NOT EXISTS idx_user_badges_badge ON public.user_badges(badge_id);
CREATE INDEX IF NOT EXISTS idx_user_badges_active ON public.user_badges(user_id)
  WHERE revoked_at IS NULL;

-- Badge history
CREATE INDEX IF NOT EXISTS idx_badge_history_user ON public.badge_history(user_id);
CREATE INDEX IF NOT EXISTS idx_badge_history_badge ON public.badge_history(badge_id);

-- Reviews
CREATE INDEX IF NOT EXISTS idx_reviews_visibility ON public.reviews(visibility);
CREATE INDEX IF NOT EXISTS idx_reviews_blind_deadline ON public.reviews(blind_deadline)
  WHERE visibility = 'hidden' AND blind_deadline IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_reviews_moderation ON public.reviews(moderation_status)
  WHERE moderation_status = 'pending';

-- Review media
CREATE INDEX IF NOT EXISTS idx_review_media_review ON public.review_media(review_id);

-- Review reports
CREATE INDEX IF NOT EXISTS idx_review_reports_status ON public.review_reports(status)
  WHERE status = 'pending';
CREATE INDEX IF NOT EXISTS idx_review_reports_review ON public.review_reports(review_id);

-- Skill verifications
CREATE INDEX IF NOT EXISTS idx_skill_verifications_mechanic ON public.skill_verifications(mechanic_id);
CREATE INDEX IF NOT EXISTS idx_skill_verifications_skill ON public.skill_verifications(skill_key);
CREATE INDEX IF NOT EXISTS idx_skill_verifications_job ON public.skill_verifications(job_id);

-- Trust scores
CREATE INDEX IF NOT EXISTS idx_trust_scores_user ON public.trust_scores(user_id);
CREATE INDEX IF NOT EXISTS idx_trust_scores_overall ON public.trust_scores(overall_score DESC);

-- Trust score history
CREATE INDEX IF NOT EXISTS idx_trust_score_history_user ON public.trust_score_history(user_id);
CREATE INDEX IF NOT EXISTS idx_trust_score_history_time ON public.trust_score_history(created_at DESC);

-- Review prompts
CREATE INDEX IF NOT EXISTS idx_review_prompts_user ON public.review_prompts(user_id);
CREATE INDEX IF NOT EXISTS idx_review_prompts_pending ON public.review_prompts(user_id)
  WHERE completed_at IS NULL;

-- =====================================================
-- SEED DATA: Default badges
-- =====================================================

INSERT INTO public.badges (code, title, description, icon, category, tier, criteria_type, criteria_threshold, display_priority)
VALUES
  -- Milestone badges
  ('first_job', 'First Job', 'Completed your first job', '', 'milestone', 1, 'jobs_completed', 1, 10),
  ('jobs_5', 'Rising Star', 'Completed 5 jobs', '', 'milestone', 1, 'jobs_completed', 5, 20),
  ('jobs_10', 'Experienced', 'Completed 10 jobs', '', 'milestone', 2, 'jobs_completed', 10, 30),
  ('jobs_25', 'Seasoned Pro', 'Completed 25 jobs', '', 'milestone', 2, 'jobs_completed', 25, 40),
  ('jobs_50', 'Expert', 'Completed 50 jobs', '', 'milestone', 3, 'jobs_completed', 50, 50),
  ('jobs_100', 'Master Mechanic', 'Completed 100 jobs', '', 'milestone', 3, 'jobs_completed', 100, 60),
  
  -- Quality badges
  ('high_rated', 'Highly Rated', 'Maintained 4.5+ rating over 10+ reviews', '', 'quality', 2, 'avg_rating', 4.5, 15),
  ('perfect_score', 'Perfect Score', '5.0 average rating with 5+ reviews', '', 'quality', 3, 'avg_rating', 5.0, 5),
  ('recommended', 'Highly Recommended', '90%+ would recommend rate', '', 'quality', 2, 'recommend_rate', 90, 25),
  
  -- Reliability badges
  ('on_time', 'Punctual Pro', '95%+ on-time arrival rate', '', 'reliability', 2, 'on_time_rate', 95, 35),
  ('reliable', 'Reliable', '98%+ job completion rate', '', 'reliability', 2, 'completion_rate', 98, 45),
  ('quick_responder', 'Quick Responder', 'Average quote response under 30 minutes', '', 'reliability', 1, 'response_time', 30, 55),
  
  -- Skill badges
  ('verified_skill', 'Verified Specialist', 'Skill verified through 3+ successful jobs', '', 'skill', 1, 'skill_jobs', 3, 70),
  ('multi_skilled', 'Multi-Skilled', '5+ verified skills', '', 'skill', 2, 'verified_skills', 5, 65),
  
  -- Special badges
  ('early_adopter', 'Early Adopter', 'Joined during platform launch', '', 'special', 1, 'manual', 1, 80),
  ('top_performer', 'Top Performer', 'Top 10% in your area this month', '', 'special', 3, 'top_percentile', 10, 1)
ON CONFLICT (code) DO NOTHING;

COMMIT;
\n-- ===================================================================
-- END: 0010_trust_system.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0011_trust_system_rls.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0012: TRUST SYSTEM RLS POLICIES
-- =====================================================

BEGIN;

-- =====================================================
-- ENABLE RLS
-- =====================================================

ALTER TABLE public.badges ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_badges ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.badge_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.review_media ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.review_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.skill_verifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.trust_scores ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.trust_score_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.review_prompts ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- GRANTS
-- =====================================================

GRANT SELECT ON public.badges TO authenticated;
GRANT SELECT ON public.badges TO anon;

GRANT SELECT, INSERT ON public.user_badges TO authenticated;
GRANT SELECT ON public.user_badges TO anon;

GRANT SELECT ON public.badge_history TO authenticated;

GRANT SELECT, INSERT ON public.review_media TO authenticated;

GRANT SELECT, INSERT ON public.review_reports TO authenticated;

GRANT SELECT ON public.skill_verifications TO authenticated;

GRANT SELECT ON public.trust_scores TO authenticated;
GRANT SELECT ON public.trust_scores TO anon;

GRANT SELECT ON public.trust_score_history TO authenticated;

GRANT SELECT, UPDATE ON public.review_prompts TO authenticated;

-- Service role gets full access
GRANT ALL ON public.badges TO service_role;
GRANT ALL ON public.user_badges TO service_role;
GRANT ALL ON public.badge_history TO service_role;
GRANT ALL ON public.review_media TO service_role;
GRANT ALL ON public.review_reports TO service_role;
GRANT ALL ON public.skill_verifications TO service_role;
GRANT ALL ON public.trust_scores TO service_role;
GRANT ALL ON public.trust_score_history TO service_role;
GRANT ALL ON public.review_prompts TO service_role;

-- =====================================================
-- BADGES POLICIES
-- =====================================================

DROP POLICY IF EXISTS "badges_select_public" ON public.badges;
CREATE POLICY "badges_select_public" ON public.badges
  FOR SELECT USING (is_active = true);

-- =====================================================
-- USER_BADGES POLICIES
-- =====================================================

DROP POLICY IF EXISTS "user_badges_select_public" ON public.user_badges;
CREATE POLICY "user_badges_select_public" ON public.user_badges
  FOR SELECT USING (
    revoked_at IS NULL 
    AND (expires_at IS NULL OR expires_at > now())
  );

DROP POLICY IF EXISTS "user_badges_insert_system" ON public.user_badges;
CREATE POLICY "user_badges_insert_system" ON public.user_badges
  FOR INSERT WITH CHECK (
    source = 'system' OR auth.uid() = user_id
  );

-- =====================================================
-- BADGE_HISTORY POLICIES
-- =====================================================

DROP POLICY IF EXISTS "badge_history_select_own" ON public.badge_history;
CREATE POLICY "badge_history_select_own" ON public.badge_history
  FOR SELECT USING (auth.uid() = user_id);

-- =====================================================
-- REVIEW_MEDIA POLICIES
-- =====================================================

DROP POLICY IF EXISTS "review_media_select_visible" ON public.review_media;
CREATE POLICY "review_media_select_visible" ON public.review_media
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.reviews r 
      WHERE r.id = review_id 
      AND (r.visibility = 'visible' OR r.reviewer_id = auth.uid() OR r.reviewee_id = auth.uid())
    )
  );

DROP POLICY IF EXISTS "review_media_insert_own" ON public.review_media;
CREATE POLICY "review_media_insert_own" ON public.review_media
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.reviews r 
      WHERE r.id = review_id 
      AND r.reviewer_id = auth.uid()
    )
  );

-- =====================================================
-- REVIEW_REPORTS POLICIES
-- =====================================================

DROP POLICY IF EXISTS "review_reports_select_own" ON public.review_reports;
CREATE POLICY "review_reports_select_own" ON public.review_reports
  FOR SELECT USING (auth.uid() = reported_by);

DROP POLICY IF EXISTS "review_reports_insert_auth" ON public.review_reports;
CREATE POLICY "review_reports_insert_auth" ON public.review_reports
  FOR INSERT WITH CHECK (
    auth.uid() = reported_by
    AND EXISTS (
      SELECT 1 FROM public.reviews r 
      WHERE r.id = review_id 
      AND r.reviewee_id = auth.uid()  -- Can only report reviews about yourself
    )
  );

-- =====================================================
-- SKILL_VERIFICATIONS POLICIES
-- =====================================================

DROP POLICY IF EXISTS "skill_verifications_select_public" ON public.skill_verifications;
CREATE POLICY "skill_verifications_select_public" ON public.skill_verifications
  FOR SELECT USING (true);

-- =====================================================
-- TRUST_SCORES POLICIES
-- =====================================================

DROP POLICY IF EXISTS "trust_scores_select_public" ON public.trust_scores;
CREATE POLICY "trust_scores_select_public" ON public.trust_scores
  FOR SELECT USING (true);

-- =====================================================
-- TRUST_SCORE_HISTORY POLICIES
-- =====================================================

DROP POLICY IF EXISTS "trust_score_history_select_own" ON public.trust_score_history;
CREATE POLICY "trust_score_history_select_own" ON public.trust_score_history
  FOR SELECT USING (auth.uid() = user_id);

-- =====================================================
-- REVIEW_PROMPTS POLICIES
-- =====================================================

DROP POLICY IF EXISTS "review_prompts_select_own" ON public.review_prompts;
CREATE POLICY "review_prompts_select_own" ON public.review_prompts
  FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "review_prompts_update_own" ON public.review_prompts;
CREATE POLICY "review_prompts_update_own" ON public.review_prompts
  FOR UPDATE USING (auth.uid() = user_id);

-- =====================================================
-- REVIEWS POLICIES (updated for blind reviews)
-- =====================================================

DROP POLICY IF EXISTS "reviews_select_visible" ON public.reviews;
CREATE POLICY "reviews_select_visible" ON public.reviews
  FOR SELECT USING (
    -- Always see your own reviews (given or received)
    reviewer_id = auth.uid() 
    OR reviewee_id = auth.uid()
    -- Or visible reviews
    OR (visibility = 'visible' AND is_hidden = false AND deleted_at IS NULL)
  );

COMMIT;
\n-- ===================================================================
-- END: 0011_trust_system_rls.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0013_update_profile_card.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0014: UPDATE PROFILE CARD FOR TRUST SYSTEM
-- =====================================================

BEGIN;

-- =====================================================
-- UPDATE FUNCTION: get_public_profile_card
-- Now includes trust score and verified skill counts
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_public_profile_card(user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  result jsonb;
  profile_record record;
  profile_ratings jsonb;
  profile_badges jsonb;
  profile_skills jsonb;
  profile_trust_score jsonb;
BEGIN
  -- Get the profile record
  SELECT p.id, p.role, p.full_name, p.avatar_url, p.created_at
  INTO profile_record
  FROM profiles p
  WHERE p.id = user_id
    AND p.deleted_at IS NULL;

  IF NOT FOUND THEN
    RETURN NULL;
  END IF;

  -- Get ratings from visible reviews only
  SELECT jsonb_build_object(
    'overall_avg', COALESCE(AVG(r.overall_rating), 0),
    'performance_avg', COALESCE(AVG(r.performance_rating), 0),
    'timing_avg', COALESCE(AVG(r.timing_rating), 0),
    'cost_avg', COALESCE(AVG(r.cost_rating), 0),
    'professionalism_avg', COALESCE(AVG(r.professionalism_rating), 0),
    'communication_avg', COALESCE(AVG(r.communication_rating), 0),
    'review_count', COUNT(r.id)::integer,
    'would_recommend_count', COUNT(r.id) FILTER (WHERE r.would_recommend = true)::integer,
    'would_recommend_total', COUNT(r.id) FILTER (WHERE r.would_recommend IS NOT NULL)::integer
  )
  INTO profile_ratings
  FROM reviews r
  WHERE r.reviewee_id = profile_record.id
    AND r.visibility = 'visible'
    AND r.is_hidden = false
    AND r.deleted_at IS NULL;

  -- Get badges with tier info
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ub.id,
      'badge_id', ub.badge_id,
      'awarded_at', ub.awarded_at,
      'badge', jsonb_build_object(
        'code', b.code,
        'title', b.title,
        'description', b.description,
        'icon', b.icon,
        'category', b.category,
        'tier', b.tier
      )
    ) ORDER BY b.display_priority ASC
  ), '[]'::jsonb)
  INTO profile_badges
  FROM user_badges ub
  INNER JOIN badges b ON b.id = ub.badge_id
  WHERE ub.user_id = profile_record.id
    AND ub.revoked_at IS NULL
    AND (ub.expires_at IS NULL OR ub.expires_at > NOW());

  -- Get skills with verification status (for mechanics only)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ms.id,
      'skill', jsonb_build_object(
        'key', s.key,
        'label', s.label,
        'category', s.category
      ),
      'is_verified', COALESCE(ms.is_verified, false),
      'verified_job_count', COALESCE(ms.verified_job_count, 0),
      'avg_job_rating', ms.avg_job_rating
    ) ORDER BY ms.is_verified DESC, ms.verified_job_count DESC
  ), '[]'::jsonb)
  INTO profile_skills
  FROM mechanic_skills ms
  INNER JOIN skills s ON s.key = ms.skill_key
  WHERE ms.mechanic_id = profile_record.id;

  -- Get trust score
  SELECT jsonb_build_object(
    'overall_score', ts.overall_score,
    'rating_score', ts.rating_score,
    'completion_score', ts.completion_score,
    'reliability_score', ts.reliability_score,
    'badge_score', ts.badge_score,
    'tenure_score', ts.tenure_score,
    'completed_jobs', ts.completed_jobs,
    'total_jobs', ts.total_jobs
  )
  INTO profile_trust_score
  FROM trust_scores ts
  WHERE ts.user_id = profile_record.id;

  -- Build result (NO email, NO phone - privacy protected)
  result := jsonb_build_object(
    'id', profile_record.id,
    'role', profile_record.role,
    'display_name', COALESCE(profile_record.full_name, 'User'),
    'avatar_url', profile_record.avatar_url,
    'created_at', profile_record.created_at,
    'ratings', profile_ratings,
    'badges', profile_badges,
    'skills', profile_skills,
    'trust_score', COALESCE(profile_trust_score, jsonb_build_object(
      'overall_score', 50,
      'rating_score', 50,
      'completion_score', 100,
      'reliability_score', 50,
      'badge_score', 0,
      'tenure_score', 0,
      'completed_jobs', 0,
      'total_jobs', 0
    ))
  );

  RETURN result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO anon;

COMMIT;
\n-- ===================================================================
-- END: 0013_update_profile_card.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0014_seed_data.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0006: SEED DATA (POLISHED + EXPANDED)
-- =====================================================
-- Purpose: Idempotent seed data for lookup tables
-- Depends on: 0001_baseline_schema.sql
-- Safe for: supabase db reset (uses ON CONFLICT)
--
-- Notes:
-- - DO NOTHING is used where keys should be immutable once created.
-- - DO UPDATE is used where copy/labels/icons may evolve over time.
-- - All inserts are deterministic and can be re-run safely.
-- =====================================================

BEGIN;

-- =====================================================
-- 1) SKILLS
-- =====================================================
INSERT INTO public.skills (key, label, category, created_at)
VALUES
  ('brakes', 'Brakes', 'repair', NOW()),
  ('oil_change', 'Oil Change', 'maintenance', NOW()),
  ('battery', 'Battery', 'repair', NOW()),
  ('diagnostics', 'Diagnostics', 'diagnostics', NOW()),
  ('suspension', 'Suspension', 'repair', NOW()),
  ('engine', 'Engine', 'repair', NOW()),
  ('electrical', 'Electrical', 'repair', NOW()),
  ('cooling', 'Cooling System', 'repair', NOW()),
  ('transmission', 'Transmission', 'repair', NOW()),
  ('electrical_troubleshooting', 'Electrical Troubleshooting', 'diagnostics', NOW()),
  ('battery_charging_system', 'Battery & Charging System', 'repair', NOW()),
  ('cooling_systems', 'Cooling Systems', 'repair', NOW()),
  ('brake_service', 'Brake Service', 'repair', NOW())
ON CONFLICT (key) DO NOTHING;

-- =====================================================
-- 2) TOOLS (Expanded + standardized categories)
-- =====================================================
-- Categories used: General, Diagnostics, Lifting, Electrical, Safety, Cooling, Fluids, Brakes, Tires, Power Tools
INSERT INTO public.tools (key, label, category, created_at) VALUES
  -- Diagnostics
  ('scan_tool', 'Diagnostic Scanner', 'Diagnostics', NOW()),
  ('code_reader_basic', 'Basic OBD-II Code Reader', 'Diagnostics', NOW()),
  ('bidirectional_scan_tool', 'Bi-directional Scan Tool', 'Diagnostics', NOW()),
  ('infrared_thermometer', 'Infrared Thermometer', 'Diagnostics', NOW()),
  ('smoke_machine', 'EVAP/Intake Smoke Machine', 'Diagnostics', NOW()),
  ('vacuum_gauge', 'Vacuum Gauge', 'Diagnostics', NOW()),
  ('compression_tester', 'Compression Tester', 'Diagnostics', NOW()),
  ('leakdown_tester', 'Cylinder Leakdown Tester', 'Diagnostics', NOW()),
  ('fuel_pressure_gauge', 'Fuel Pressure Gauge', 'Diagnostics', NOW()),

  -- Lifting / Support
  ('jack', 'Jack', 'Lifting', NOW()),
  ('floor_jack', 'Floor Jack', 'Lifting', NOW()),
  ('bottle_jack', 'Bottle Jack', 'Lifting', NOW()),
  ('jack_stands', 'Jack Stands', 'Lifting', NOW()),
  ('wheel_chocks', 'Wheel Chocks', 'Lifting', NOW()),
  ('ramps', 'Vehicle Ramps', 'Lifting', NOW()),
  ('creeper', 'Mechanic Creeper', 'Lifting', NOW()),

  -- General hand tools
  ('wrench_set', 'Wrench Set', 'General', NOW()),
  ('socket_set', 'Socket Set (Metric + SAE)', 'General', NOW()),
  ('ratchet_set', 'Ratchet Set', 'General', NOW()),
  ('breaker_bar', 'Breaker Bar', 'General', NOW()),
  ('torque_wrench', 'Torque Wrench', 'General', NOW()),
  ('screwdriver_set', 'Screwdriver Set', 'General', NOW()),
  ('pliers_set', 'Pliers Set', 'General', NOW()),
  ('allen_keys', 'Allen/Hex Key Set', 'General', NOW()),
  ('pry_bar', 'Pry Bar', 'General', NOW()),
  ('hammer', 'Small Hammer (Tap Test)', 'General', NOW()),
  ('utility_knife', 'Utility Knife', 'General', NOW()),
  ('trim_tools', 'Trim Removal Tools', 'General', NOW()),
  ('magnetic_pickup', 'Magnetic Pickup Tool', 'General', NOW()),

  -- Power tools / air tools
  ('impact_wrench', 'Impact Wrench', 'Power Tools', NOW()),
  ('air_compressor', 'Air Compressor', 'Power Tools', NOW()),
  ('air_ratchet', 'Air Ratchet', 'Power Tools', NOW()),
  ('electric_ratchet', 'Electric Ratchet', 'Power Tools', NOW()),
  ('drill_driver', 'Drill/Driver', 'Power Tools', NOW()),

  -- Electrical
  ('multimeter', 'Multimeter', 'Electrical', NOW()),
  ('test_light', 'Test Light', 'Electrical', NOW()),
  ('power_probe', 'Power Probe (Circuit Tester)', 'Electrical', NOW()),
  ('jump_pack', 'Jump Starter Pack', 'Electrical', NOW()),
  ('battery_tester', 'Battery Tester', 'Electrical', NOW()),
  ('battery_charger', 'Battery Charger/Maintainer', 'Electrical', NOW()),

  -- Cooling / fluids
  ('pressure_tester', 'Cooling System Pressure Tester', 'Cooling', NOW()),
  ('coolant_funnel', 'No-Spill Coolant Funnel', 'Cooling', NOW()),
  ('uv_dye_kit', 'UV Dye Leak Kit', 'Fluids', NOW()),
  ('oil_filter_wrench', 'Oil Filter Wrench', 'Fluids', NOW()),
  ('fluid_pump', 'Fluid Transfer Pump', 'Fluids', NOW()),
  ('drain_pan', 'Drain Pan', 'Fluids', NOW()),

  -- Brakes
  ('brake_bleeder', 'Brake Bleeder Kit', 'Brakes', NOW()),
  ('brake_caliper_tool', 'Brake Caliper Piston Tool', 'Brakes', NOW()),
  ('c_clamp', 'C-Clamp (Brake Compression)', 'Brakes', NOW()),

  -- Tires / wheel
  ('tire_pressure_gauge', 'Tire Pressure Gauge', 'Tires', NOW()),
  ('lug_wrench', 'Lug Wrench', 'Tires', NOW()),
  ('tire_plug_kit', 'Tire Plug Kit', 'Tires', NOW()),

  -- Safety / visibility
  ('work_light', 'Work Light', 'Safety', NOW()),
  ('gloves', 'Safety Gloves', 'Safety', NOW()),
  ('safety_glasses', 'Safety Glasses', 'Safety', NOW()),
  ('reflective_vest', 'Reflective Vest', 'Safety', NOW()),
  ('fire_extinguisher', 'Fire Extinguisher', 'Safety', NOW())
ON CONFLICT (key) DO UPDATE SET
  label = EXCLUDED.label,
  category = EXCLUDED.category;

-- =====================================================
-- 3) SAFETY_MEASURES
-- =====================================================
INSERT INTO public.safety_measures (key, label, created_at) VALUES
  ('jack_stands_required', 'Use jack stands when lifting vehicle', NOW()),
  ('wheel_chocks_used', 'Use wheel chocks', NOW()),
  ('reflective_gear', 'Wear reflective vest', NOW()),
  ('roadside_awareness', 'Be aware of traffic', NOW()),
  ('photo_documentation', 'Take before/after photos', NOW()),
  ('battery_safety', 'Battery safety (sparks, acid, jump starts)', NOW()),
  ('hazard_positioning', 'Safe positioning & hazard awareness', NOW()),
  ('brake_safety', 'Brake safety (do not test if unsafe)', NOW()),
  ('chemical_safety', 'Heat/fire/chemical safety awareness', NOW()),
  ('do_not_drive', 'Do not drive until inspected', NOW()),
  ('fan_safety', 'Fan safety (fans may turn on unexpectedly)', NOW())
ON CONFLICT (key) DO NOTHING;

-- =====================================================
-- 4) SYMPTOMS
-- =====================================================
INSERT INTO public.symptoms (key, label, icon) VALUES
  ('basic_maintenance', 'Routine Maintenance', ''),
  ('battery_issue', 'Battery Problems', ''),
  ('brake_issue', 'Brake Problems', ''),
  ('fluid_leak', 'Fluid Leak', ''),
  ('no_start_no_crank', 'Won''t Start', ''),
  ('strange_noise', 'Strange Noise', ''),
  ('warning_light', 'Warning Light', ''),

  -- Electrical (more specific)
  ('elec_no_crank_no_click', 'No Crank No Click', ''),
  ('elec_starter_clicking', 'Starter Clicking', ''),
  ('elec_alternator_not_charging', 'Alternator Not Charging', ''),
  ('elec_parasitic_drain', 'Battery Drains When Parked', ''),
  ('elec_abs_light_on', 'ABS Light On', ''),

  -- Cooling
  ('cool_overheating', 'Overheating', ''),
  ('cool_coolant_leak', 'Coolant Leak', ''),
  ('cool_radiator_fan_not_working', 'Radiator Fan Not Working', ''),
  ('cool_thermostat_stuck', 'Thermostat Stuck', ''),
  ('cool_water_pump_failure', 'Water Pump Failure', '')
ON CONFLICT (key) DO UPDATE SET
  label = EXCLUDED.label,
  icon = EXCLUDED.icon;

-- =====================================================
-- 5) SYMPTOM_MAPPINGS
-- =====================================================
-- quote_strategy suggestions:
-- - fixed_simple, inspection_required, diagnostic_only, diagnosis_first
-- risk_level suggestions:
-- - low, medium, high
INSERT INTO public.symptom_mappings
(symptom_key, symptom_label, category, required_skill_keys, suggested_tool_keys, required_safety_keys, quote_strategy, risk_level, customer_explainer, mechanic_notes)
VALUES
('basic_maintenance', 'Basic Maintenance', 'Maintenance',
  ARRAY[]::text[], ARRAY[]::text[], ARRAY[]::text[],
  'fixed_simple', 'low',
  'Routine service like oil change, filters, wipers, or scheduled maintenance.',
  NULL),

('battery_issue', 'Battery Issue', 'Electrical & Charging',
  ARRAY[]::text[], ARRAY[]::text[], ARRAY[]::text[],
  'inspection_required', 'medium',
  'Slow crank, clicking, dead battery, or needing frequent jump-starts.',
  NULL),

('elec_no_crank_no_click', 'No crank, no click, no sound', 'Electrical & Charging',
  ARRAY['electrical_troubleshooting']::text[],
  ARRAY['multimeter','scan_tool']::text[],
  ARRAY['battery_safety','hazard_positioning']::text[],
  'diagnostic_only', 'medium',
  'No sound at all usually means no power to the starter.',
  'Check battery voltage first. Test ignition switch, neutral safety switch, clutch switch.'),

('elec_starter_clicking', 'Starter clicks but won''t crank', 'Electrical & Charging',
  ARRAY['electrical_troubleshooting']::text[],
  ARRAY['multimeter','jump_pack','battery_tester']::text[],
  ARRAY['battery_safety','hazard_positioning']::text[],
  'diagnostic_only', 'medium',
  'Clicking usually means low battery voltage or a failing starter.',
  'Test battery voltage under load. Check starter connections and ground.'),

('elec_alternator_not_charging', 'Alternator not charging', 'Electrical & Charging',
  ARRAY['battery_charging_system','electrical_troubleshooting']::text[],
  ARRAY['multimeter','battery_tester']::text[],
  ARRAY['battery_safety']::text[],
  'diagnostic_only', 'medium',
  'If the alternator isn''t charging, the battery will drain and the car may stall.',
  'Test battery voltage at idle and ~2000 RPM. Confirm belt condition and connections.'),

('elec_parasitic_drain', 'Battery drains when parked', 'Electrical & Charging',
  ARRAY['electrical_troubleshooting']::text[],
  ARRAY['multimeter','battery_tester']::text[],
  ARRAY['battery_safety']::text[],
  'diagnostic_only', 'low',
  'Something is drawing power when the car is off.',
  'Test battery health first. Then measure key-off draw and isolate by fuses.'),

('brake_issue', 'Brake Issue', 'Brakes',
  ARRAY['brake_service']::text[],
  ARRAY['jack','jack_stands','wheel_chocks','work_light']::text[],
  ARRAY['brake_safety','jack_stands_required','wheel_chocks_used']::text[],
  'inspection_required', 'high',
  'Braking feels unsafe: squealing/grinding, vibration, soft pedal, or pulling.',
  'Do not road-test if unsafe. Inspect pad/rotor thickness and caliper function first.'),

('elec_abs_light_on', 'ABS warning light on', 'Electrical & Charging',
  ARRAY['electrical_troubleshooting','brake_service']::text[],
  ARRAY['scan_tool']::text[],
  ARRAY['brake_safety']::text[],
  'diagnostic_only', 'medium',
  'ABS light indicates a fault in the anti-lock brake system.',
  'Scan for ABS codes. Common causes: wheel speed sensors, tone rings, wiring.'),

('cool_overheating', 'Engine overheating', 'Cooling System',
  ARRAY['cooling_systems']::text[],
  ARRAY['scan_tool','infrared_thermometer','pressure_tester']::text[],
  ARRAY['chemical_safety','do_not_drive']::text[],
  'diagnostic_only', 'high',
  'Overheating can cause severe engine damage.',
  'Check coolant level/condition, fan operation, and pressure test for leaks.'),

('cool_coolant_leak', 'Coolant leak', 'Cooling System',
  ARRAY['cooling_systems']::text[],
  ARRAY['pressure_tester','uv_dye_kit']::text[],
  ARRAY['chemical_safety']::text[],
  'inspection_required', 'medium',
  'Coolant leaks can come from hoses, radiator, water pump, or head gasket.',
  'Pressure test cooling system. Use UV dye if needed.'),

('cool_radiator_fan_not_working', 'Radiator fan not running', 'Cooling System',
  ARRAY['cooling_systems','electrical_troubleshooting']::text[],
  ARRAY['multimeter','scan_tool']::text[],
  ARRAY['fan_safety']::text[],
  'diagnostic_only', 'medium',
  'If the radiator fan doesn''t run, the engine may overheat in traffic.',
  'Command fan (if supported), test motor, relay, fuse, and sensor inputs.'),

('cool_thermostat_stuck', 'Thermostat stuck', 'Cooling System',
  ARRAY['cooling_systems']::text[],
  ARRAY['scan_tool','infrared_thermometer']::text[],
  ARRAY['chemical_safety']::text[],
  'diagnostic_only', 'medium',
  'A stuck thermostat can cause overheating or slow warm-up.',
  'Confirm temps via scan tool and compare inlet/outlet temps.'),

('cool_water_pump_failure', 'Water pump failing', 'Cooling System',
  ARRAY['cooling_systems']::text[],
  ARRAY['pressure_tester']::text[],
  ARRAY['chemical_safety','do_not_drive']::text[],
  'inspection_required', 'high',
  'A failing water pump can leak coolant or cause overheating.',
  'Check for leak at weep hole, bearing noise, and belt-driven play.'),

('fluid_leak', 'Fluid Leak', 'Engine',
  ARRAY[]::text[],
  ARRAY['work_light','uv_dye_kit','drain_pan']::text[],
  ARRAY['hazard_positioning','photo_documentation']::text[],
  'inspection_required', 'medium',
  'Visible fluid under the vehicle or low fluid warnings.',
  'Identify fluid type first (oil/coolant/brake/trans). Confirm level before starting.'),

('strange_noise', 'Strange Noise', 'Other',
  ARRAY[]::text[],
  ARRAY['work_light']::text[],
  ARRAY['hazard_positioning']::text[],
  'inspection_required', 'medium',
  'Unusual sound like squeal, rattle, clunk, grinding, or ticking.',
  'Try to reproduce: turning/braking/bumps/idle. Inspect likely systems.'),

('warning_light', 'Check Engine Light On', 'Engine',
  ARRAY[]::text[],
  ARRAY['scan_tool']::text[],
  ARRAY['photo_documentation']::text[],
  'diagnosis_first', 'medium',
  'Your vehicle stored a diagnostic code that points us to the system to inspect.',
  'Scan codes, check freeze frame, verify symptoms, then recommend fixes.'),

('no_start_no_crank', 'No Start / No Crank', 'Electrical',
  ARRAY[]::text[],
  ARRAY['multimeter','jump_pack','battery_tester']::text[],
  ARRAY['battery_safety','hazard_positioning']::text[],
  'diagnostic_only', 'high',
  'Turning the key does nothing or only clicks; engine does not crank.',
  'Verify battery state-of-charge, terminals/grounds, starter signal, immobilizer issues.')
ON CONFLICT (symptom_key) DO UPDATE SET
  symptom_label = EXCLUDED.symptom_label,
  category = EXCLUDED.category,
  required_skill_keys = EXCLUDED.required_skill_keys,
  suggested_tool_keys = EXCLUDED.suggested_tool_keys,
  required_safety_keys = EXCLUDED.required_safety_keys,
  quote_strategy = EXCLUDED.quote_strategy,
  risk_level = EXCLUDED.risk_level,
  customer_explainer = EXCLUDED.customer_explainer,
  mechanic_notes = EXCLUDED.mechanic_notes,
  updated_at = NOW();

-- =====================================================
-- 6) EDUCATION_CARDS
-- =====================================================
INSERT INTO public.education_cards
(symptom_key, card_key, title, summary, why_it_happens, what_we_check, is_it_safe, prep_before_visit, quote_expectation, red_flags, order_index)
VALUES
('basic_maintenance', 'core', 'Routine maintenance',
  'We''ll confirm the right fluids and parts for your exact vehicle.',
  'Different engines require specific oil types and filters.',
  'Verify vehicle details, inspect fluids/filters, perform service.',
  'Safethis is preventative.',
  'Know your last service date/mileage. Park on level surface.',
  'Usually fixed-price services.',
  'If warning lights are on, we''ll advise next steps.',
  1),

('battery_issue', 'core', 'Battery keeps dying',
  'We''ll test the battery and charging system.',
  'Old battery, alternator output, parasitic drain, or loose connections.',
  'Battery test, alternator test, terminal inspection, draw check if needed.',
  'Usually safe short trips, but you might get stranded.',
  'Know battery age. Mention any recent jump-starts.',
  'Often diagnostic-first, then fixed price after findings.',
  'Battery hot/swollen or rotten-egg smelldo not touch. Get help.',
  1),

('brake_issue', 'core', 'Brakes feel unsafe',
  'Brakes are safety-critical. We''ll inspect before quoting.',
  'Worn pads/rotors, seized calipers, air in lines, or leaks.',
  'Pad/rotor thickness, caliper movement, fluid level, lines/hoses.',
  'If grinding loudly or pulling hardavoid driving.',
  'Tell us the exact feel and where the car is parked.',
  'Often a range quote after inspection.',
  'Pedal to the floor or metal-on-metal grindingdo not drive.',
  1),

('fluid_leak', 'core', 'Fluid leaking under car',
  'Color and location help diagnose quickly.',
  'Oil, coolant, brake fluid, and transmission fluid can look similar at first glance.',
  'Identify fluid type, check levels, inspect hoses/gaskets/seals.',
  'Brake fluid or overheating coolantdo not drive.',
  'Photo the puddle and note color/smell. Put cardboard under the leak if possible.',
  'Inspection-first, then repair price.',
  'Rapid leak, overheating, or warning lightsstop safely.',
  1),

('no_start_no_crank', 'core', 'Car won''t start',
  'Often battery, connection, starter, or security issue.',
  'Weak battery, loose terminals, starter relay, or immobilizer.',
  'Battery voltage, terminal condition, starter signal, code scan if needed.',
  'Safe to stay parked. Avoid repeated start attempts.',
  'Have keys ready, pop hood, tell us what you heard/saw on the dash.',
  'Starts with diagnostic. Repair price depends on findings.',
  'Burning smell, smoke, or hot cableskeep distance.',
  1),

('strange_noise', 'core', 'Strange noise while driving',
  'We''ll narrow it down quickly with a few questions and a targeted inspection.',
  'Brakes, suspension, bearings, belts, exhaust, or loose hardware.',
  'When/where it happens + inspection of likely systems.',
  'If shaking hard or steering feels unsafeavoid driving.',
  'Record video/audio and note when it happens (speed, turning, bumps).',
  'Often inspection-required.',
  'Loud clunk + loss of controlstop driving.',
  1),

('warning_light', 'core', 'Dashboard warning light',
  'We''ll scan and explain in plain English.',
  'A sensor or system detected something out of range and stored a code.',
  'Code scan + quick checks to confirm root cause.',
  'Red = stop soon. Yellow = usually okay short-term (depends on symptoms).',
  'Photo the light and note any driving changes (rough idle, limp mode).',
  'Best handled as diagnostic-first.',
  'Flashing check-engine lightpull over safely.',
  1)
ON CONFLICT (symptom_key, card_key) DO UPDATE SET
  title = EXCLUDED.title,
  summary = EXCLUDED.summary,
  why_it_happens = EXCLUDED.why_it_happens,
  what_we_check = EXCLUDED.what_we_check,
  is_it_safe = EXCLUDED.is_it_safe,
  prep_before_visit = EXCLUDED.prep_before_visit,
  quote_expectation = EXCLUDED.quote_expectation,
  red_flags = EXCLUDED.red_flags,
  order_index = EXCLUDED.order_index;

-- =====================================================
-- 7) SYMPTOM_EDUCATION
-- =====================================================
INSERT INTO public.symptom_education
(symptom_key, title, summary, is_it_safe, what_we_check, how_quotes_work)
VALUES
('basic_maintenance', 'Routine Maintenance',
  'Regular service keeps your car running smoothly and prevents bigger repairs.',
  'Completely safe. This is preventative care.',
  'We verify vehicle details, check fluids, inspect filters, belts, and key wear items.',
  'Most maintenance has fixed prices. Oil changes often range $40$80 (market dependent).'),

('battery_issue', 'Battery Problems',
  'Slow crank or no-start is usually battery, connections, alternator, or parasitic drain.',
  'Usually safe short trips. If the battery is hot/swollendon''t touch it.',
  'We test voltage, alternator output, terminals/grounds, and draw if needed.',
  'Battery testing is often free or ~$20$30. New battery commonly $100$200.'),

('brake_issue', 'Brake Problems',
  'Any change in stopping power, noise, or pedal feel needs attention.',
  'Grinding or pedal to floor = DO NOT DRIVE.',
  'We measure pad thickness, check rotors, test calipers, and inspect lines/fluid.',
  'Front pads often $150$300. Rotors can add $200$400 depending on vehicle.'),

('fluid_leak', 'Fluid Leaking',
  'Different fluids mean different problems; identifying the fluid is step one.',
  'Oil leaks can be okay short-term. Brake/coolant issues can be unsafedon''t drive.',
  'We identify the fluid, check levels, inspect hoses/gaskets/seals, and confirm source.',
  'Small leaks often $200$400. Larger leaks can be $400$800+ depending on access.'),

('no_start_no_crank', 'Won''t Start',
  'Often electrical: battery, terminals/grounds, starter circuit, or security system.',
  'Safe parked. Don''t keep tryingrepeated attempts can drain the battery.',
  'We check battery health/voltage, connections, starter signal, and scan if needed.',
  'Diagnosis often $50$100. Battery $100$200. Starter commonly $300$600.'),

('strange_noise', 'Strange Noise',
  'Noises can come from brakes, suspension, engine, bearings, belts, or exhaust.',
  'If it shakes hard or feels unsafestop driving.',
  'We reproduce the noise (when possible) and inspect the most likely systems first.',
  'Diagnosis often $50$100. Repairs range widely from $100 to $1,000+.'),

('warning_light', 'Check Engine Light',
  'The vehicle stored a diagnostic trouble code pointing to a system to inspect.',
  'Solid light = often safe short distances. FLASHING = pull over safely.',
  'We scan codes, review freeze frame, do quick verification checks, then advise.',
  'Code scanning often $50$100. Common fixes vary widely (e.g., sensors $200$400).')
ON CONFLICT (symptom_key) DO UPDATE SET
  title = EXCLUDED.title,
  summary = EXCLUDED.summary,
  is_it_safe = EXCLUDED.is_it_safe,
  what_we_check = EXCLUDED.what_we_check,
  how_quotes_work = EXCLUDED.how_quotes_work;

-- =====================================================
-- 8) SYMPTOM_QUESTIONS
-- =====================================================
INSERT INTO public.symptom_questions
(symptom_key, question_key, question_text, question_type, options, affects_safety, affects_quote, display_order)
VALUES
('battery_issue', 'how_old_battery', 'How old is your battery?', 'single_choice',
  '["Less than 2 years","2-4 years","4+ years","Don''t know"]'::jsonb, false, true, 1),
('battery_issue', 'jump_start_needed', 'Have you needed a jump start recently?', 'yes_no',
  NULL, false, true, 2),
('battery_issue', 'lights_dim', 'Do your headlights or interior lights dim?', 'yes_no',
  NULL, false, false, 3),

('brake_issue', 'brake_noise_type', 'What kind of noise do you hear?', 'single_choice',
  '["Squealing","Grinding","Clicking","No noise"]'::jsonb, true, true, 1),
('brake_issue', 'pedal_feel', 'How does the brake pedal feel?', 'single_choice',
  '["Normal","Soft/spongy","Hard/stiff","Goes to floor"]'::jsonb, true, true, 2),
('brake_issue', 'vibration', 'Do you feel vibration when braking?', 'yes_no',
  NULL, false, true, 3),

('fluid_leak', 'fluid_color', 'What color is the fluid?', 'single_choice',
  '["Clear/water","Brown/black (oil)","Green/orange (coolant)","Red (transmission)","Yellow/brown (brake)"]'::jsonb, true, true, 1),
('fluid_leak', 'leak_size', 'How much fluid is leaking?', 'single_choice',
  '["Few drops","Small puddle","Large puddle","Constant drip"]'::jsonb, true, true, 2),

('no_start_no_crank', 'what_happens', 'What happens when you turn the key?', 'single_choice',
  '["Nothing at all","Clicking sound","Lights dim","Accessories work"]'::jsonb, false, true, 1),
('no_start_no_crank', 'battery_age', 'How old is your battery?', 'single_choice',
  '["Less than 2 years","2-4 years","4+ years","Don''t know"]'::jsonb, false, true, 2),

('strange_noise', 'when_noise', 'When do you hear the noise?', 'multi_choice',
  '["While driving","When turning","When braking","Over bumps","At idle"]'::jsonb, false, true, 1),
('strange_noise', 'noise_type', 'What does it sound like?', 'single_choice',
  '["Squealing","Grinding","Clunking","Rattling","Ticking"]'::jsonb, false, true, 2),

('warning_light', 'light_color', 'What color is the warning light?', 'single_choice',
  '["Yellow/orange","Red","Blue","Don''t know"]'::jsonb, true, false, 1),
('warning_light', 'light_behavior', 'Is the light solid or flashing?', 'single_choice',
  '["Solid/steady","Flashing","Comes and goes"]'::jsonb, true, true, 2),

('basic_maintenance', 'service_type', 'What service do you need?', 'multi_choice',
  '["Oil change","Air filter","Cabin filter","Tire rotation","Other"]'::jsonb, false, true, 1),
('basic_maintenance', 'last_service', 'When was your last service?', 'single_choice',
  '["Less than 3 months","3-6 months","6-12 months","Over a year"]'::jsonb, false, false, 2)
ON CONFLICT (symptom_key, question_key) DO UPDATE SET
  question_text = EXCLUDED.question_text,
  question_type = EXCLUDED.question_type,
  options = EXCLUDED.options,
  affects_safety = EXCLUDED.affects_safety,
  affects_quote = EXCLUDED.affects_quote,
  display_order = EXCLUDED.display_order,
  updated_at = NOW();

-- =====================================================
-- 9) MEDIA_ASSETS (App videos/images)
-- =====================================================
INSERT INTO public.media_assets (key, bucket, path, public_url, content_type) VALUES
  ('logo_video', 'media', 'logovideo.mp4', 'https://komsqqxqirvfgforixxq.supabase.co/storage/v1/object/public/media/logovideo.mp4', 'video/mp4'),
  ('wrenchgo_ad_1', 'media', 'wrenchGoAd.mp4', 'https://komsqqxqirvfgforixxq.supabase.co/storage/v1/object/public/media/wrenchGoAd.mp4', 'video/mp4'),
  ('wrenchgo_ad_2', 'media', 'wrenchGoAd2.mp4', 'https://komsqqxqirvfgforixxq.supabase.co/storage/v1/object/public/media/wrenchGoAd2.mp4', 'video/mp4'),
  ('wrenchgo_ad_3', 'media', 'wrenchGoAd3.mp4', 'https://komsqqxqirvfgforixxq.supabase.co/storage/v1/object/public/media/wrenchGoAd3.mp4', 'video/mp4')
ON CONFLICT (key) DO UPDATE SET
  bucket = EXCLUDED.bucket,
  path = EXCLUDED.path,
  public_url = EXCLUDED.public_url,
  content_type = EXCLUDED.content_type;

COMMIT;
\n-- ===================================================================
-- END: 0014_seed_data.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0015_job_lifecycle_rls.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0007: RLS POLICIES FOR JOB LIFECYCLE
-- =====================================================
-- Purpose: Row Level Security for job lifecycle tables
-- =====================================================

BEGIN;

-- =====================================================
-- ENABLE RLS
-- =====================================================

ALTER TABLE public.job_contracts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.invoice_line_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.job_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.job_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.disputes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payouts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.job_media ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- job_contracts POLICIES
-- =====================================================

-- Customers can view their own contracts
CREATE POLICY "Customers can view own contracts" ON public.job_contracts
  FOR SELECT USING (auth.uid() = customer_id);

-- Mechanics can view contracts they're part of
CREATE POLICY "Mechanics can view own contracts" ON public.job_contracts
  FOR SELECT USING (auth.uid() = mechanic_id);

-- Only system/functions can insert contracts (via accept_quote function)
CREATE POLICY "System can insert contracts" ON public.job_contracts
  FOR INSERT WITH CHECK (true);

-- Only system can update contracts
CREATE POLICY "System can update contracts" ON public.job_contracts
  FOR UPDATE USING (true);

-- =====================================================
-- invoice_line_items POLICIES
-- =====================================================

-- View: both parties can see line items for their contracts
CREATE POLICY "Contract parties can view line items" ON public.invoice_line_items
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.job_contracts c
      WHERE c.id = invoice_line_items.contract_id
      AND (c.customer_id = auth.uid() OR c.mechanic_id = auth.uid())
    )
  );

-- Insert: mechanic can add line items to their contracts
CREATE POLICY "Mechanics can add line items" ON public.invoice_line_items
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.job_contracts c
      WHERE c.id = invoice_line_items.contract_id
      AND c.mechanic_id = auth.uid()
      AND c.status = 'active'
    )
    AND added_by = auth.uid()
  );

-- Update: mechanics can update pending items, customers can approve/reject
CREATE POLICY "Mechanics can update pending items" ON public.invoice_line_items
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM public.job_contracts c
      WHERE c.id = invoice_line_items.contract_id
      AND c.mechanic_id = auth.uid()
    )
    AND approval_status = 'pending'
  );

CREATE POLICY "Customers can approve/reject items" ON public.invoice_line_items
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM public.job_contracts c
      WHERE c.id = invoice_line_items.contract_id
      AND c.customer_id = auth.uid()
    )
  );

-- =====================================================
-- job_events POLICIES
-- =====================================================

-- View: parties can see events visible to them
CREATE POLICY "Customers can view visible events" ON public.job_events
  FOR SELECT USING (
    visible_to_customer = true
    AND EXISTS (
      SELECT 1 FROM public.jobs j
      WHERE j.id = job_events.job_id
      AND j.customer_id = auth.uid()
    )
  );

CREATE POLICY "Mechanics can view visible events" ON public.job_events
  FOR SELECT USING (
    visible_to_mechanic = true
    AND EXISTS (
      SELECT 1 FROM public.jobs j
      WHERE j.id = job_events.job_id
      AND j.accepted_mechanic_id = auth.uid()
    )
  );

-- Insert: system and participants can add events
CREATE POLICY "Participants can add events" ON public.job_events
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.jobs j
      WHERE j.id = job_events.job_id
      AND (j.customer_id = auth.uid() OR j.accepted_mechanic_id = auth.uid())
    )
  );

-- Events are immutable - no update policy

-- =====================================================
-- job_progress POLICIES
-- =====================================================

-- View: both parties can view
CREATE POLICY "Job parties can view progress" ON public.job_progress
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.jobs j
      WHERE j.id = job_progress.job_id
      AND (j.customer_id = auth.uid() OR j.accepted_mechanic_id = auth.uid())
    )
  );

-- Insert: system creates on contract creation
CREATE POLICY "System can insert progress" ON public.job_progress
  FOR INSERT WITH CHECK (true);

-- Update: both parties can update their relevant fields
CREATE POLICY "Mechanics can update progress" ON public.job_progress
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM public.jobs j
      WHERE j.id = job_progress.job_id
      AND j.accepted_mechanic_id = auth.uid()
    )
  );

CREATE POLICY "Customers can update progress" ON public.job_progress
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM public.jobs j
      WHERE j.id = job_progress.job_id
      AND j.customer_id = auth.uid()
    )
  );

-- =====================================================
-- disputes POLICIES
-- =====================================================

-- View: parties can see disputes they're involved in
CREATE POLICY "Parties can view own disputes" ON public.disputes
  FOR SELECT USING (
    filed_by = auth.uid() OR filed_against = auth.uid()
  );

-- Insert: either party can file dispute
CREATE POLICY "Users can file disputes" ON public.disputes
  FOR INSERT WITH CHECK (
    filed_by = auth.uid()
    AND EXISTS (
      SELECT 1 FROM public.jobs j
      WHERE j.id = disputes.job_id
      AND (j.customer_id = auth.uid() OR j.accepted_mechanic_id = auth.uid())
    )
  );

-- Update: only filer can add evidence (platform updates via service role)
CREATE POLICY "Filers can update disputes" ON public.disputes
  FOR UPDATE USING (filed_by = auth.uid());

-- =====================================================
-- payouts POLICIES
-- =====================================================

-- View: mechanics can see their own payouts
CREATE POLICY "Mechanics can view own payouts" ON public.payouts
  FOR SELECT USING (mechanic_id = auth.uid());

-- Insert/Update: only system (handled by functions)
CREATE POLICY "System can manage payouts" ON public.payouts
  FOR ALL USING (true);

-- =====================================================
-- job_media POLICIES
-- =====================================================

-- View: both parties can see job media
CREATE POLICY "Job parties can view media" ON public.job_media
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.jobs j
      WHERE j.id = job_media.job_id
      AND (j.customer_id = auth.uid() OR j.accepted_mechanic_id = auth.uid())
    )
  );

-- Insert: participants can upload
CREATE POLICY "Participants can upload media" ON public.job_media
  FOR INSERT WITH CHECK (
    uploaded_by = auth.uid()
    AND EXISTS (
      SELECT 1 FROM public.jobs j
      WHERE j.id = job_media.job_id
      AND (j.customer_id = auth.uid() OR j.accepted_mechanic_id = auth.uid())
    )
  );

-- Delete: only uploader can delete
CREATE POLICY "Uploaders can delete own media" ON public.job_media
  FOR DELETE USING (uploaded_by = auth.uid());

-- =====================================================
-- GRANTS
-- =====================================================

GRANT SELECT, INSERT, UPDATE ON public.job_contracts TO authenticated;
GRANT SELECT, INSERT, UPDATE ON public.invoice_line_items TO authenticated;
GRANT SELECT, INSERT ON public.job_events TO authenticated;
GRANT SELECT, INSERT, UPDATE ON public.job_progress TO authenticated;
GRANT SELECT, INSERT, UPDATE ON public.disputes TO authenticated;
GRANT SELECT ON public.payouts TO authenticated;
GRANT SELECT, INSERT, DELETE ON public.job_media TO authenticated;

-- Service role gets full access
GRANT ALL ON public.job_contracts TO service_role;
GRANT ALL ON public.invoice_line_items TO service_role;
GRANT ALL ON public.job_events TO service_role;
GRANT ALL ON public.job_progress TO service_role;
GRANT ALL ON public.disputes TO service_role;
GRANT ALL ON public.payouts TO service_role;
GRANT ALL ON public.job_media TO service_role;

COMMIT;
\n-- ===================================================================
-- END: 0015_job_lifecycle_rls.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0016_cleanup_and_validation.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0007: CLEANUP AND VALIDATION
-- =====================================================
-- Purpose: Final cleanup, validation, and storage setup
-- Depends on: All previous migrations
-- =====================================================

BEGIN;

-- =====================================================
-- GRANT EXECUTE ON FUNCTIONS
-- =====================================================
GRANT EXECUTE ON FUNCTION public.handle_new_user() TO service_role;
GRANT EXECUTE ON FUNCTION public.set_user_role(public.user_role) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_my_role() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_my_profile() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_mechanic_leads(uuid, text, numeric, numeric, numeric, integer, integer, text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_mechanic_profile_full(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.save_theme_preference(public.theme_mode) TO authenticated;
GRANT EXECUTE ON FUNCTION public.create_stripe_connect_account() TO authenticated;
GRANT EXECUTE ON FUNCTION public.save_stripe_account(text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_stripe_account_status() TO authenticated;
GRANT EXECUTE ON FUNCTION public.create_payment_intent(uuid, int, text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.update_stripe_account_status(text, boolean, boolean, boolean) TO service_role;
GRANT EXECUTE ON FUNCTION public.update_payment_status(text, public.payment_status, timestamptz) TO service_role;

-- =====================================================
-- REALTIME SUBSCRIPTIONS
-- =====================================================
ALTER PUBLICATION supabase_realtime ADD TABLE public.messages;
ALTER PUBLICATION supabase_realtime ADD TABLE public.notifications;
ALTER PUBLICATION supabase_realtime ADD TABLE public.jobs;
ALTER PUBLICATION supabase_realtime ADD TABLE public.quote_requests;

-- =====================================================
-- VALIDATION QUERIES (will fail if schema is wrong)
-- =====================================================
DO $$
DECLARE
  v_count int;
BEGIN
  -- Verify all tables exist
  SELECT COUNT(*) INTO v_count FROM information_schema.tables 
  WHERE table_schema = 'public' AND table_name IN (
    'profiles', 'vehicles', 'jobs', 'quote_requests', 'reviews',
    'mechanic_profiles', 'skills', 'tools', 'safety_measures',
    'mechanic_skills', 'mechanic_tools', 'mechanic_safety',
    'symptoms', 'symptom_mappings', 'education_cards', 'symptom_education', 'symptom_questions',
    'messages', 'notifications', 'media_assets',
    'mechanic_stripe_accounts', 'customer_payment_methods', 'payments'
  );
  
  IF v_count < 22 THEN
    RAISE EXCEPTION 'Schema validation failed: Expected 22 tables, found %', v_count;
  END IF;
  
  -- Verify all enums exist
  SELECT COUNT(*) INTO v_count FROM pg_type 
  WHERE typname IN ('user_role', 'theme_mode', 'job_status', 'quote_status', 'payment_status');
  
  IF v_count < 5 THEN
    RAISE EXCEPTION 'Schema validation failed: Expected 5 enums, found %', v_count;
  END IF;
  
  -- Verify critical columns exist
  SELECT COUNT(*) INTO v_count FROM information_schema.columns
  WHERE table_schema = 'public' AND table_name = 'profiles' 
  AND column_name IN ('id', 'email', 'role', 'theme_preference', 'city', 'state');
  
  IF v_count < 6 THEN
    RAISE EXCEPTION 'Schema validation failed: profiles table missing columns';
  END IF;
  
  SELECT COUNT(*) INTO v_count FROM information_schema.columns
  WHERE table_schema = 'public' AND table_name = 'jobs' 
  AND column_name IN ('id', 'customer_id', 'status', 'preferred_time', 'location_lat', 'location_lng');
  
  IF v_count < 6 THEN
    RAISE EXCEPTION 'Schema validation failed: jobs table missing columns';
  END IF;
  
  SELECT COUNT(*) INTO v_count FROM information_schema.columns
  WHERE table_schema = 'public' AND table_name = 'notifications' 
  AND column_name IN ('id', 'user_id', 'type', 'entity_type', 'entity_id', 'is_read');
  
  IF v_count < 6 THEN
    RAISE EXCEPTION 'Schema validation failed: notifications table missing columns';
  END IF;
  
  SELECT COUNT(*) INTO v_count FROM information_schema.columns
  WHERE table_schema = 'public' AND table_name = 'media_assets' 
  AND column_name IN ('id', 'key', 'public_url', 'bucket', 'path');
  
  IF v_count < 5 THEN
    RAISE EXCEPTION 'Schema validation failed: media_assets table missing columns';
  END IF;
  
  RAISE NOTICE 'Schema validation passed: All tables, enums, and columns verified';
END $$;

-- =====================================================
-- NOTIFY POSTGREST TO REFRESH SCHEMA CACHE
-- =====================================================
NOTIFY pgrst, 'reload schema';

COMMIT;
\n-- ===================================================================
-- END: 0016_cleanup_and_validation.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0017_fix_duplicate_contract_and_cancel_quote.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0017: FIX DUPLICATE CONTRACT & CANCEL QUOTE
-- =====================================================
-- Purpose: 
--   1. Fix duplicate key constraint on job_contracts by checking existence
--   2. Add missing cancel_quote_by_customer function
-- Depends on: 0007_job_lifecycle_functions.sql
-- =====================================================

BEGIN;

-- =====================================================
-- FIX: accept_quote_and_create_contract
-- Add check for existing contract before insert
-- =====================================================

CREATE OR REPLACE FUNCTION accept_quote_and_create_contract(
  p_quote_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_quote RECORD;
  v_job RECORD;
  v_contract_id uuid;
  v_existing_contract_id uuid;
  v_progress_id uuid;
  v_platform_fee_cents int := 1500;  -- $15
  v_commission_cents int;
  v_total_customer_cents int;
  v_mechanic_payout_cents int;
  v_line_item_id uuid;
BEGIN
  -- Get quote with lock
  SELECT q.*, j.customer_id as job_customer_id, j.status as job_status
  INTO v_quote
  FROM public.quotes q
  JOIN public.jobs j ON j.id = q.job_id
  WHERE q.id = p_quote_id
  FOR UPDATE OF q, j;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote not found');
  END IF;
  
  -- Validate customer owns the job
  IF v_quote.job_customer_id != p_customer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  -- Check if contract already exists for this job
  SELECT id INTO v_existing_contract_id
  FROM public.job_contracts
  WHERE job_id = v_quote.job_id;

  IF v_existing_contract_id IS NOT NULL THEN
    RETURN jsonb_build_object('success', true, 'contract_id', v_existing_contract_id, 'message', 'Contract already exists');
  END IF;

  -- Allow both 'pending' and 'accepted' quotes (accepted without contract = inconsistent state, recover it)
  IF v_quote.status NOT IN ('pending', 'accepted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote is no longer available');
  END IF;

  -- Validate job is in correct state (allow accepted too for recovery)
  IF v_quote.job_status NOT IN ('searching', 'quoted', 'accepted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job is no longer accepting quotes');
  END IF;
  
  -- Calculate fees
  v_commission_cents := calculate_mechanic_commission(v_quote.price_cents);
  v_total_customer_cents := v_quote.price_cents + v_platform_fee_cents;
  v_mechanic_payout_cents := v_quote.price_cents - v_commission_cents;
  
  -- Create contract
  INSERT INTO public.job_contracts (
    job_id, quote_id, customer_id, mechanic_id,
    status, quoted_price_cents, platform_fee_cents, estimated_hours,
    subtotal_cents, total_customer_cents, mechanic_commission_cents, mechanic_payout_cents
  ) VALUES (
    v_quote.job_id, p_quote_id, p_customer_id, v_quote.mechanic_id,
    'active', v_quote.price_cents, v_platform_fee_cents, v_quote.estimated_hours,
    v_quote.price_cents, v_total_customer_cents, v_commission_cents, v_mechanic_payout_cents
  )
  RETURNING id INTO v_contract_id;
  
  -- Create initial line item for base labor
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'base_labor', 'Service as quoted', 1, v_quote.price_cents, v_quote.price_cents,
    'approved', false, v_quote.mechanic_id, 'mechanic', 0
  )
  RETURNING id INTO v_line_item_id;
  
  -- Create platform fee line item
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'platform_fee', 'WrenchGo platform fee', 1, v_platform_fee_cents, v_platform_fee_cents,
    'approved', false, p_customer_id, 'customer', 100
  );
  
  -- Create job progress record
  INSERT INTO public.job_progress (job_id, contract_id)
  VALUES (v_quote.job_id, v_contract_id)
  RETURNING id INTO v_progress_id;
  
  -- Update quote status
  UPDATE public.quotes
  SET status = 'accepted', updated_at = now()
  WHERE id = p_quote_id;
  
  -- Reject all other quotes for this job
  UPDATE public.quotes
  SET status = 'rejected', updated_at = now()
  WHERE job_id = v_quote.job_id AND id != p_quote_id;
  
  -- Update job status
  UPDATE public.jobs
  SET 
    status = 'accepted',
    accepted_mechanic_id = v_quote.mechanic_id,
    updated_at = now()
  WHERE id = v_quote.job_id;
  
  -- Log event
  PERFORM log_job_event(
    v_quote.job_id, v_contract_id, 'contract_created',
    p_customer_id, 'customer',
    'Contract created',
    'Quote accepted and contract created',
    jsonb_build_object(
      'quote_id', p_quote_id,
      'quoted_price_cents', v_quote.price_cents,
      'platform_fee_cents', v_platform_fee_cents,
      'total_customer_cents', v_total_customer_cents
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'contract_id', v_contract_id,
    'progress_id', v_progress_id,
    'total_customer_cents', v_total_customer_cents
  );
END;
$$;

-- =====================================================
-- ADD: cancel_quote_by_customer function
-- =====================================================

CREATE OR REPLACE FUNCTION public.cancel_quote_by_customer(
  p_quote_id uuid,
  p_reason text,
  p_note text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_customer_id uuid;
  v_quote_customer_id uuid;
BEGIN
  v_customer_id := auth.uid();

  SELECT customer_id INTO v_quote_customer_id
  FROM public.quote_requests
  WHERE id = p_quote_id;

  IF v_quote_customer_id IS NULL THEN
    RAISE EXCEPTION 'Quote not found';
  END IF;

  IF v_quote_customer_id != v_customer_id THEN
    RAISE EXCEPTION 'Not authorized to cancel this quote';
  END IF;

  UPDATE public.quote_requests
  SET
    status = 'cancelled',
    canceled_at = NOW(),
    canceled_by = 'customer',
    cancel_reason = p_reason,
    cancel_note = p_note,
    updated_at = NOW()
  WHERE id = p_quote_id;

  RETURN jsonb_build_object('success', true, 'quote_id', p_quote_id);
END;
$$;

GRANT EXECUTE ON FUNCTION public.cancel_quote_by_customer(uuid, text, text) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 0017_fix_duplicate_contract_and_cancel_quote.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0018_job_lifecycle_triggers.sql
-- ===================================================================\n
-- =====================================================
-- Job Lifecycle Integrity: Automatic Status Transitions
-- =====================================================

-- Trigger: When a quote is inserted, update job status to 'quoted' if still 'searching'
CREATE OR REPLACE FUNCTION public.on_quote_inserted()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.jobs
  SET status = 'quoted', updated_at = NOW()
  WHERE id = NEW.job_id
    AND status = 'searching';
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trg_quote_inserted ON public.quotes;
CREATE TRIGGER trg_quote_inserted
  AFTER INSERT ON public.quotes
  FOR EACH ROW
  EXECUTE FUNCTION public.on_quote_inserted();

-- Trigger: When a quote is accepted, update job status to 'accepted'
CREATE OR REPLACE FUNCTION public.on_quote_accepted()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'accepted' AND (OLD.status IS NULL OR OLD.status <> 'accepted') THEN
    UPDATE public.jobs
    SET 
      status = 'accepted',
      accepted_mechanic_id = NEW.mechanic_id,
      updated_at = NOW()
    WHERE id = NEW.job_id
      AND status IN ('searching', 'quoted');
    
    -- Reject all other pending quotes for this job
    UPDATE public.quotes
    SET status = 'rejected', updated_at = NOW()
    WHERE job_id = NEW.job_id
      AND id <> NEW.id
      AND status = 'pending';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trg_quote_accepted ON public.quotes;
CREATE TRIGGER trg_quote_accepted
  AFTER UPDATE ON public.quotes
  FOR EACH ROW
  EXECUTE FUNCTION public.on_quote_accepted();

-- Trigger: When a quote is withdrawn and no other pending quotes exist, revert to 'searching'
CREATE OR REPLACE FUNCTION public.on_quote_withdrawn()
RETURNS TRIGGER AS $$
DECLARE
  pending_count INT;
BEGIN
  IF NEW.status = 'withdrawn' AND OLD.status = 'pending' THEN
    SELECT COUNT(*) INTO pending_count
    FROM public.quotes
    WHERE job_id = NEW.job_id AND status = 'pending';
    
    IF pending_count = 0 THEN
      UPDATE public.jobs
      SET status = 'searching', updated_at = NOW()
      WHERE id = NEW.job_id AND status = 'quoted';
    END IF;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trg_quote_withdrawn ON public.quotes;
CREATE TRIGGER trg_quote_withdrawn
  AFTER UPDATE ON public.quotes
  FOR EACH ROW
  EXECUTE FUNCTION public.on_quote_withdrawn();

-- Trigger: When job is cancelled, withdraw all pending quotes
CREATE OR REPLACE FUNCTION public.on_job_cancelled()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'cancelled' AND OLD.status <> 'cancelled' THEN
    UPDATE public.quotes
    SET status = 'withdrawn', updated_at = NOW()
    WHERE job_id = NEW.id AND status = 'pending';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trg_job_cancelled ON public.jobs;
CREATE TRIGGER trg_job_cancelled
  AFTER UPDATE ON public.jobs
  FOR EACH ROW
  EXECUTE FUNCTION public.on_job_cancelled();

-- Function to get accurate job status (considers quotes)
CREATE OR REPLACE FUNCTION public.get_job_effective_status(p_job_id UUID)
RETURNS TEXT AS $$
DECLARE
  v_status TEXT;
  v_has_pending_quotes BOOLEAN;
  v_has_accepted_quote BOOLEAN;
BEGIN
  SELECT status INTO v_status FROM public.jobs WHERE id = p_job_id;
  
  IF v_status IS NULL THEN
    RETURN NULL;
  END IF;
  
  -- Check for accepted quotes
  SELECT EXISTS(
    SELECT 1 FROM public.quotes WHERE job_id = p_job_id AND status = 'accepted'
  ) INTO v_has_accepted_quote;
  
  IF v_has_accepted_quote AND v_status = 'searching' THEN
    -- Fix inconsistent state
    UPDATE public.jobs SET status = 'accepted', updated_at = NOW() WHERE id = p_job_id;
    RETURN 'accepted';
  END IF;
  
  -- Check for pending quotes
  SELECT EXISTS(
    SELECT 1 FROM public.quotes WHERE job_id = p_job_id AND status = 'pending'
  ) INTO v_has_pending_quotes;
  
  IF v_has_pending_quotes AND v_status = 'searching' THEN
    -- Fix inconsistent state
    UPDATE public.jobs SET status = 'quoted', updated_at = NOW() WHERE id = p_job_id;
    RETURN 'quoted';
  END IF;
  
  RETURN v_status;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.get_job_effective_status(UUID) TO authenticated;

-- One-time fix: Update any jobs stuck in 'searching' that have quotes
DO $$
BEGIN
  -- Fix jobs with pending quotes still showing as searching
  UPDATE public.jobs j
  SET status = 'quoted', updated_at = NOW()
  WHERE j.status = 'searching'
    AND EXISTS (
      SELECT 1 FROM public.quotes q 
      WHERE q.job_id = j.id AND q.status = 'pending'
    );
    
  -- Fix jobs with accepted quotes still showing as searching/quoted
  UPDATE public.jobs j
  SET status = 'accepted', updated_at = NOW()
  WHERE j.status IN ('searching', 'quoted')
    AND EXISTS (
      SELECT 1 FROM public.quotes q 
      WHERE q.job_id = j.id AND q.status = 'accepted'
    );
END $$;
\n-- ===================================================================
-- END: 0018_job_lifecycle_triggers.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0019_trust_system_enhancements.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0011: TRUST SYSTEM ENHANCEMENTS
-- =====================================================
-- Purpose: Add job-skill mapping, constraints for data integrity
-- =====================================================

BEGIN;

-- =====================================================
-- TABLE: job_skill_tags (explicit job-to-skill mapping)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.job_skill_tags (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  contract_id uuid REFERENCES public.job_contracts(id) ON DELETE CASCADE,
  skill_key text NOT NULL REFERENCES public.skills(key) ON DELETE CASCADE,
  tag_role text NOT NULL DEFAULT 'primary' CHECK (tag_role IN ('primary', 'secondary')),
  locked_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  
  UNIQUE(job_id, skill_key)
);

CREATE INDEX IF NOT EXISTS idx_job_skill_tags_job ON public.job_skill_tags(job_id);
CREATE INDEX IF NOT EXISTS idx_job_skill_tags_skill ON public.job_skill_tags(skill_key);
CREATE INDEX IF NOT EXISTS idx_job_skill_tags_contract ON public.job_skill_tags(contract_id);

COMMENT ON TABLE public.job_skill_tags IS 'Explicit job-to-skill mapping for skill verification';

-- =====================================================
-- CONSTRAINTS: Ensure data integrity
-- =====================================================

-- Ensure one review per reviewer per job
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint 
    WHERE conname = 'reviews_unique_reviewer_per_job'
  ) THEN
    ALTER TABLE public.reviews 
      ADD CONSTRAINT reviews_unique_reviewer_per_job 
      UNIQUE(job_id, reviewer_id);
  END IF;
END $$;

-- Ensure one active badge per user (dedupe existing if needed)
DO $$ BEGIN
  -- First, dedupe existing user_badges if there are duplicates
  WITH ranked_badges AS (
    SELECT 
      id,
      ROW_NUMBER() OVER (
        PARTITION BY user_id, badge_id 
        ORDER BY 
          CASE WHEN revoked_at IS NULL THEN 0 ELSE 1 END,
          awarded_at DESC
      ) as rn
    FROM public.user_badges
  )
  DELETE FROM public.user_badges
  WHERE id IN (
    SELECT id FROM ranked_badges WHERE rn > 1
  );
  
  -- Now add the constraint
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint 
    WHERE conname = 'user_badges_unique_active'
  ) THEN
    ALTER TABLE public.user_badges 
      ADD CONSTRAINT user_badges_unique_active 
      UNIQUE(user_id, badge_id);
  END IF;
END $$;

COMMIT;
\n-- ===================================================================
-- END: 0019_trust_system_enhancements.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0020_trust_system_functions.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0012: TRUST SYSTEM BUSINESS LOGIC
-- =====================================================
-- Purpose: RPCs and triggers for blind reviews, badges, 
--          skill verification, and trust scoring
-- =====================================================

BEGIN;

-- =====================================================
-- FUNCTION: create_review_prompts
-- =====================================================
-- Called when job is finalized to prompt both parties for reviews
CREATE OR REPLACE FUNCTION public.create_review_prompts(
  p_job_id uuid,
  p_customer_id uuid,
  p_mechanic_id uuid
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_expires_at timestamptz;
BEGIN
  v_expires_at := now() + interval '7 days';
  
  -- Create prompt for customer to review mechanic
  INSERT INTO public.review_prompts (
    job_id, user_id, target_user_id, user_role, expires_at
  ) VALUES (
    p_job_id, p_customer_id, p_mechanic_id, 'customer', v_expires_at
  )
  ON CONFLICT (job_id, user_id) DO NOTHING;
  
  -- Create prompt for mechanic to review customer
  INSERT INTO public.review_prompts (
    job_id, user_id, target_user_id, user_role, expires_at
  ) VALUES (
    p_job_id, p_mechanic_id, p_customer_id, 'mechanic', v_expires_at
  )
  ON CONFLICT (job_id, user_id) DO NOTHING;
END;
$$;

-- =====================================================
-- FUNCTION: submit_review
-- =====================================================
-- Submit a review with blind period logic
CREATE OR REPLACE FUNCTION public.submit_review(
  p_job_id uuid,
  p_reviewer_id uuid,
  p_reviewee_id uuid,
  p_rating int,
  p_comment text DEFAULT NULL,
  p_professionalism_rating int DEFAULT NULL,
  p_communication_rating int DEFAULT NULL,
  p_would_recommend boolean DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_review_id uuid;
  v_blind_deadline timestamptz;
  v_other_review_exists boolean;
  v_should_publish boolean := false;
  v_job_finalized_at timestamptz;
BEGIN
  -- Get job finalized timestamp
  SELECT jp.finalized_at INTO v_job_finalized_at
  FROM public.job_progress jp
  WHERE jp.job_id = p_job_id;
  
  IF v_job_finalized_at IS NULL THEN
    RAISE EXCEPTION 'Job not finalized yet';
  END IF;
  
  -- Set blind deadline to 7 days after job finalization
  v_blind_deadline := v_job_finalized_at + interval '7 days';
  
  -- Check if other party has already reviewed
  SELECT EXISTS(
    SELECT 1 FROM public.reviews
    WHERE job_id = p_job_id
      AND reviewer_id = p_reviewee_id
      AND reviewee_id = p_reviewer_id
  ) INTO v_other_review_exists;
  
  -- If both reviews exist, publish both immediately
  v_should_publish := v_other_review_exists;
  
  -- Insert or update review
  INSERT INTO public.reviews (
    job_id,
    reviewer_id,
    reviewee_id,
    overall_rating,
    comment,
    professionalism_rating,
    communication_rating,
    would_recommend,
    visibility,
    blind_deadline,
    created_at,
    updated_at
  ) VALUES (
    p_job_id,
    p_reviewer_id,
    p_reviewee_id,
    p_rating,
    p_comment,
    p_professionalism_rating,
    p_communication_rating,
    p_would_recommend,
    CASE WHEN v_should_publish THEN 'visible'::review_visibility ELSE 'hidden'::review_visibility END,
    v_blind_deadline,
    now(),
    now()
  )
  ON CONFLICT (job_id, reviewer_id)
  DO UPDATE SET
    overall_rating = EXCLUDED.overall_rating,
    comment = EXCLUDED.comment,
    professionalism_rating = EXCLUDED.professionalism_rating,
    communication_rating = EXCLUDED.communication_rating,
    would_recommend = EXCLUDED.would_recommend,
    updated_at = now()
  RETURNING id INTO v_review_id;
  
  -- If both reviews exist, publish both
  IF v_should_publish THEN
    UPDATE public.reviews
    SET 
      visibility = 'visible',
      made_visible_at = now(),
      visibility_reason = 'both_submitted'
    WHERE job_id = p_job_id
      AND visibility = 'hidden';
  END IF;
  
  -- Mark prompt as completed
  UPDATE public.review_prompts
  SET completed_at = now()
  WHERE job_id = p_job_id
    AND user_id = p_reviewer_id;
  
  RETURN jsonb_build_object(
    'review_id', v_review_id,
    'published', v_should_publish,
    'blind_deadline', v_blind_deadline
  );
END;
$$;

-- =====================================================
-- FUNCTION: publish_expired_reviews
-- =====================================================
-- Publish reviews that have passed blind deadline
CREATE OR REPLACE FUNCTION public.publish_expired_reviews()
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_count int;
BEGIN
  UPDATE public.reviews
  SET 
    visibility = 'visible',
    made_visible_at = now(),
    visibility_reason = 'blind_deadline_expired'
  WHERE visibility = 'hidden'
    AND blind_deadline IS NOT NULL
    AND blind_deadline < now();
  
  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;

-- =====================================================
-- FUNCTION: tag_job_skills
-- =====================================================
-- Tag a job with skills (called at quote acceptance or job start)
CREATE OR REPLACE FUNCTION public.tag_job_skills(
  p_job_id uuid,
  p_contract_id uuid,
  p_skill_keys text[],
  p_lock_immediately boolean DEFAULT false
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_skill_key text;
  v_is_first boolean := true;
BEGIN
  FOREACH v_skill_key IN ARRAY p_skill_keys
  LOOP
    INSERT INTO public.job_skill_tags (
      job_id,
      contract_id,
      skill_key,
      tag_role,
      locked_at
    ) VALUES (
      p_job_id,
      p_contract_id,
      v_skill_key,
      CASE WHEN v_is_first THEN 'primary' ELSE 'secondary' END,
      CASE WHEN p_lock_immediately THEN now() ELSE NULL END
    )
    ON CONFLICT (job_id, skill_key) DO NOTHING;
    
    v_is_first := false;
  END LOOP;
END;
$$;

-- =====================================================
-- FUNCTION: lock_job_skills
-- =====================================================
-- Lock job skills (called when work starts)
CREATE OR REPLACE FUNCTION public.lock_job_skills(p_job_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE public.job_skill_tags
  SET locked_at = now()
  WHERE job_id = p_job_id
    AND locked_at IS NULL;
END;
$$;

-- =====================================================
-- FUNCTION: process_skill_verifications
-- =====================================================
-- Process skill verifications after review is published
CREATE OR REPLACE FUNCTION public.process_skill_verifications(
  p_job_id uuid,
  p_mechanic_id uuid,
  p_customer_rating int
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_skill_record RECORD;
  v_weight numeric;
  v_rating_modifier numeric;
  v_complexity_modifier numeric := 1.0;
BEGIN
  -- Calculate rating modifier
  v_rating_modifier := CASE
    WHEN p_customer_rating = 5 THEN 1.2
    WHEN p_customer_rating = 4 THEN 1.0
    ELSE 0.5
  END;
  
  -- Process each skill tag for this job
  FOR v_skill_record IN
    SELECT skill_key
    FROM public.job_skill_tags
    WHERE job_id = p_job_id
      AND locked_at IS NOT NULL
  LOOP
    -- Calculate weight
    v_weight := 1.0 * v_rating_modifier * v_complexity_modifier;
    
    -- Insert skill verification record
    INSERT INTO public.skill_verifications (
      mechanic_id,
      skill_key,
      job_id,
      customer_rating,
      verification_weight,
      verified_at
    ) VALUES (
      p_mechanic_id,
      v_skill_record.skill_key,
      p_job_id,
      p_customer_rating,
      v_weight,
      now()
    )
    ON CONFLICT (mechanic_id, skill_key, job_id) DO NOTHING;
    
    -- Update mechanic_skills aggregates
    WITH skill_stats AS (
      SELECT
        COUNT(*) as job_count,
        AVG(customer_rating) as avg_rating,
        MAX(verified_at) as last_verified
      FROM public.skill_verifications
      WHERE mechanic_id = p_mechanic_id
        AND skill_key = v_skill_record.skill_key
    )
    UPDATE public.mechanic_skills ms
    SET
      verified_job_count = COALESCE(ss.job_count, 0),
      avg_job_rating = ss.avg_rating,
      last_verified_at = ss.last_verified,
      is_verified = COALESCE(ss.job_count, 0) >= 3
    FROM skill_stats ss
    WHERE ms.mechanic_id = p_mechanic_id
      AND ms.skill_key = v_skill_record.skill_key;
  END LOOP;
END;
$$;

-- =====================================================
-- FUNCTION: calculate_trust_score
-- =====================================================
-- Calculate comprehensive trust score for a user
CREATE OR REPLACE FUNCTION public.calculate_trust_score(p_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_role text;
  v_rating_score int := 50;
  v_completion_score int := 100;
  v_reliability_score int := 50;
  v_badge_score int := 0;
  v_tenure_score int := 0;
  v_overall_score int;
  
  v_total_jobs int := 0;
  v_completed_jobs int := 0;
  v_cancelled_jobs int := 0;
  v_disputed_jobs int := 0;
  v_no_show_count int := 0;
  
  v_reviews_given int := 0;
  v_reviews_received int := 0;
  v_avg_rating_given numeric;
  v_avg_rating_received numeric;
  
  v_account_age_days int;
  v_completion_rate numeric;
  v_on_time_rate numeric;
BEGIN
  -- Get user role
  SELECT role INTO v_user_role
  FROM public.profiles
  WHERE id = p_user_id;
  
  -- Calculate job stats
  IF v_user_role = 'mechanic' THEN
    SELECT
      COUNT(*) FILTER (WHERE jc.status IN ('active', 'completed')) as total,
      COUNT(*) FILTER (WHERE jc.status = 'completed') as completed,
      COUNT(*) FILTER (WHERE jc.status = 'cancelled') as cancelled,
      COUNT(*) FILTER (WHERE jc.status = 'disputed') as disputed
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs, v_disputed_jobs
    FROM public.job_contracts jc
    WHERE jc.mechanic_id = p_user_id;
  ELSE
    SELECT
      COUNT(*) FILTER (WHERE j.status IN ('in_progress', 'work_in_progress', 'completed')) as total,
      COUNT(*) FILTER (WHERE j.status = 'completed') as completed,
      COUNT(*) FILTER (WHERE j.status = 'cancelled') as cancelled
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs
    FROM public.jobs j
    WHERE j.customer_id = p_user_id;
  END IF;
  
  -- Calculate review stats
  SELECT
    COUNT(*) FILTER (WHERE reviewer_id = p_user_id) as given,
    COUNT(*) FILTER (WHERE reviewee_id = p_user_id) as received,
    AVG(overall_rating) FILTER (WHERE reviewer_id = p_user_id) as avg_given,
    AVG(overall_rating) FILTER (WHERE reviewee_id = p_user_id) as avg_received
  INTO v_reviews_given, v_reviews_received, v_avg_rating_given, v_avg_rating_received
  FROM public.reviews
  WHERE (reviewer_id = p_user_id OR reviewee_id = p_user_id)
    AND visibility = 'visible';
  
  -- Calculate rating score (0-100)
  IF v_reviews_received > 0 THEN
    v_rating_score := LEAST(100, GREATEST(0, 
      ((v_avg_rating_received - 1) / 4.0 * 100)::int
    ));
  END IF;
  
  -- Calculate completion score (0-100)
  IF v_total_jobs > 0 THEN
    v_completion_rate := v_completed_jobs::numeric / v_total_jobs;
    v_completion_score := LEAST(100, (v_completion_rate * 100)::int);
  END IF;
  
  -- Calculate reliability score (0-100)
  -- Based on on-time arrivals, cancellation rate
  IF v_user_role = 'mechanic' THEN
    SELECT
      COUNT(*) FILTER (WHERE jp.customer_confirmed_arrival_at IS NOT NULL) as confirmed,
      COUNT(*) as total
    INTO v_on_time_rate, v_total_jobs
    FROM public.job_progress jp
    JOIN public.job_contracts jc ON jc.job_id = jp.job_id
    WHERE jc.mechanic_id = p_user_id;
    
    IF v_total_jobs > 0 THEN
      v_on_time_rate := v_on_time_rate::numeric / v_total_jobs;
      v_reliability_score := LEAST(100, (v_on_time_rate * 100)::int);
    END IF;
  ELSE
    v_reliability_score := 50;
  END IF;
  
  -- Calculate badge score (0-100)
  SELECT COALESCE(SUM(
    CASE b.tier
      WHEN 1 THEN 5
      WHEN 2 THEN 10
      WHEN 3 THEN 20
      ELSE 0
    END
  ), 0)::int
  INTO v_badge_score
  FROM public.user_badges ub
  JOIN public.badges b ON b.id = ub.badge_id
  WHERE ub.user_id = p_user_id
    AND ub.revoked_at IS NULL
    AND b.is_active = true;
  
  v_badge_score := LEAST(100, v_badge_score);
  
  -- Calculate tenure score (0-100)
  SELECT EXTRACT(DAY FROM now() - created_at)::int
  INTO v_account_age_days
  FROM public.profiles
  WHERE id = p_user_id;
  
  v_tenure_score := LEAST(100, (v_account_age_days / 365.0 * 100)::int);
  
  -- Calculate overall score (weighted average)
  v_overall_score := (
    v_rating_score * 0.35 +
    v_completion_score * 0.25 +
    v_reliability_score * 0.20 +
    v_badge_score * 0.10 +
    v_tenure_score * 0.10
  )::int;
  
  -- Upsert trust score
  INSERT INTO public.trust_scores (
    user_id,
    overall_score,
    rating_score,
    completion_score,
    reliability_score,
    badge_score,
    tenure_score,
    total_jobs,
    completed_jobs,
    cancelled_jobs,
    disputed_jobs,
    no_show_count,
    reviews_given,
    reviews_received,
    avg_rating_given,
    avg_rating_received,
    last_calculated_at,
    updated_at
  ) VALUES (
    p_user_id,
    v_overall_score,
    v_rating_score,
    v_completion_score,
    v_reliability_score,
    v_badge_score,
    v_tenure_score,
    v_total_jobs,
    v_completed_jobs,
    v_cancelled_jobs,
    v_disputed_jobs,
    v_no_show_count,
    v_reviews_given,
    v_reviews_received,
    v_avg_rating_given,
    v_avg_rating_received,
    now(),
    now()
  )
  ON CONFLICT (user_id) DO UPDATE SET
    overall_score = EXCLUDED.overall_score,
    rating_score = EXCLUDED.rating_score,
    completion_score = EXCLUDED.completion_score,
    reliability_score = EXCLUDED.reliability_score,
    badge_score = EXCLUDED.badge_score,
    tenure_score = EXCLUDED.tenure_score,
    total_jobs = EXCLUDED.total_jobs,
    completed_jobs = EXCLUDED.completed_jobs,
    cancelled_jobs = EXCLUDED.cancelled_jobs,
    disputed_jobs = EXCLUDED.disputed_jobs,
    no_show_count = EXCLUDED.no_show_count,
    reviews_given = EXCLUDED.reviews_given,
    reviews_received = EXCLUDED.reviews_received,
    avg_rating_given = EXCLUDED.avg_rating_given,
    avg_rating_received = EXCLUDED.avg_rating_received,
    last_calculated_at = now(),
    updated_at = now();
  
  -- Create history snapshot
  INSERT INTO public.trust_score_history (
    user_id,
    overall_score,
    rating_score,
    completion_score,
    reliability_score,
    badge_score,
    tenure_score,
    snapshot_reason
  ) VALUES (
    p_user_id,
    v_overall_score,
    v_rating_score,
    v_completion_score,
    v_reliability_score,
    v_badge_score,
    v_tenure_score,
    'manual_calculation'
  );
  
  RETURN jsonb_build_object(
    'overall_score', v_overall_score,
    'rating_score', v_rating_score,
    'completion_score', v_completion_score,
    'reliability_score', v_reliability_score,
    'badge_score', v_badge_score,
    'tenure_score', v_tenure_score
  );
END;
$$;

COMMIT;
\n-- ===================================================================
-- END: 0020_trust_system_functions.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0021_badge_awarding_system.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0013: BADGE AWARDING SYSTEM
-- =====================================================
-- Purpose: Automatic badge awarding and revocation logic
-- =====================================================

BEGIN;

-- =====================================================
-- FUNCTION: evaluate_and_award_badges
-- =====================================================
-- Evaluate all badge criteria for a user and award/revoke as needed
CREATE OR REPLACE FUNCTION public.evaluate_and_award_badges(
  p_user_id uuid,
  p_trigger_reason text DEFAULT 'manual',
  p_job_id uuid DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_badge_record RECORD;
  v_user_role text;
  v_meets_criteria boolean;
  v_current_value numeric;
  v_review_count int;
  v_badges_awarded int := 0;
  v_badges_revoked int := 0;
  v_has_badge boolean;
BEGIN
  -- Get user role
  SELECT role INTO v_user_role
  FROM public.profiles
  WHERE id = p_user_id;
  
  -- Loop through all active badges
  FOR v_badge_record IN
    SELECT * FROM public.badges
    WHERE is_active = true
    ORDER BY display_priority ASC
  LOOP
    v_meets_criteria := false;
    v_current_value := 0;
    
    -- Evaluate criteria based on type
    CASE v_badge_record.criteria_type
      
      -- Jobs completed milestone
      WHEN 'jobs_completed' THEN
        IF v_user_role = 'mechanic' THEN
          SELECT COUNT(*)
          INTO v_current_value
          FROM public.job_contracts
          WHERE mechanic_id = p_user_id
            AND status = 'completed';
          
          v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
        END IF;
      
      -- Average rating
      WHEN 'avg_rating' THEN
        SELECT COUNT(*)
        INTO v_review_count
        FROM public.reviews
        WHERE reviewee_id = p_user_id
          AND visibility = 'visible';

        -- Require minimum 5 reviews for rating badges
        IF v_review_count >= 5 THEN
          SELECT AVG(overall_rating)
          INTO v_current_value
          FROM public.reviews
          WHERE reviewee_id = p_user_id
            AND visibility = 'visible';

          v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
        END IF;
      
      -- Recommend rate
      WHEN 'recommend_rate' THEN
        WITH recommend_stats AS (
          SELECT
            COUNT(*) FILTER (WHERE would_recommend = true) as recommend_count,
            COUNT(*) as total_count
          FROM public.reviews
          WHERE reviewee_id = p_user_id
            AND visibility = 'visible'
            AND would_recommend IS NOT NULL
        )
        SELECT
          CASE WHEN total_count > 0 
            THEN (recommend_count::numeric / total_count * 100)
            ELSE 0
          END
        INTO v_current_value
        FROM recommend_stats;
        
        v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
      
      -- On-time arrival rate
      WHEN 'on_time_rate' THEN
        IF v_user_role = 'mechanic' THEN
          WITH on_time_stats AS (
            SELECT
              COUNT(*) FILTER (WHERE jp.customer_confirmed_arrival_at IS NOT NULL) as on_time_count,
              COUNT(*) as total_count
            FROM public.job_progress jp
            JOIN public.job_contracts jc ON jc.job_id = jp.job_id
            WHERE jc.mechanic_id = p_user_id
              AND jc.status IN ('active', 'completed')
          )
          SELECT
            CASE WHEN total_count > 0
              THEN (on_time_count::numeric / total_count * 100)
              ELSE 0
            END
          INTO v_current_value
          FROM on_time_stats;

          v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
        END IF;

      -- Completion rate
      WHEN 'completion_rate' THEN
        IF v_user_role = 'mechanic' THEN
          WITH completion_stats AS (
            SELECT
              COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
              COUNT(*) FILTER (WHERE status IN ('active', 'completed', 'cancelled')) as total_count
            FROM public.job_contracts
            WHERE mechanic_id = p_user_id
          )
          SELECT
            CASE WHEN total_count > 0
              THEN (completed_count::numeric / total_count * 100)
              ELSE 0
            END
          INTO v_current_value
          FROM completion_stats;

          v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
        END IF;

      -- Response time (average minutes to quote)
      WHEN 'response_time' THEN
        IF v_user_role = 'mechanic' THEN
          SELECT AVG(EXTRACT(EPOCH FROM (q.created_at - j.created_at)) / 60)
          INTO v_current_value
          FROM public.quotes q
          JOIN public.jobs j ON j.id = q.job_id
          WHERE q.mechanic_id = p_user_id
            AND q.created_at >= now() - interval '30 days';
          
          v_meets_criteria := v_current_value <= v_badge_record.criteria_threshold;
        END IF;
      
      -- Skill jobs (verified jobs for a skill)
      WHEN 'skill_jobs' THEN
        IF v_user_role = 'mechanic' THEN
          SELECT MAX(verified_job_count)
          INTO v_current_value
          FROM public.mechanic_skills
          WHERE mechanic_id = p_user_id;
          
          v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
        END IF;
      
      -- Verified skills count
      WHEN 'verified_skills' THEN
        IF v_user_role = 'mechanic' THEN
          SELECT COUNT(*)
          INTO v_current_value
          FROM public.mechanic_skills
          WHERE mechanic_id = p_user_id
            AND is_verified = true;
          
          v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
        END IF;
      
      -- Top percentile (requires additional context)
      WHEN 'top_percentile' THEN
        -- TODO: Implement regional ranking logic
        v_meets_criteria := false;
      
      -- Manual badges (admin-only)
      WHEN 'manual' THEN
        v_meets_criteria := false;
      
      ELSE
        v_meets_criteria := false;
    END CASE;
    
    -- Check if user already has this badge
    SELECT EXISTS(
      SELECT 1 FROM public.user_badges
      WHERE user_id = p_user_id
        AND badge_id = v_badge_record.id
        AND revoked_at IS NULL
    ) INTO v_has_badge;
    
    -- Award or revoke badge
    IF v_meets_criteria AND NOT v_has_badge THEN
      -- Award badge
      INSERT INTO public.user_badges (
        user_id,
        badge_id,
        awarded_at,
        awarded_reason,
        job_id
      ) VALUES (
        p_user_id,
        v_badge_record.id,
        now(),
        p_trigger_reason,
        p_job_id
      )
      ON CONFLICT (user_id, badge_id) 
      DO UPDATE SET
        revoked_at = NULL,
        revoked_reason = NULL,
        awarded_at = now(),
        awarded_reason = p_trigger_reason;
      
      -- Log to history
      INSERT INTO public.badge_history (
        user_id,
        badge_id,
        action,
        reason,
        job_id,
        metadata
      ) VALUES (
        p_user_id,
        v_badge_record.id,
        'awarded',
        p_trigger_reason,
        p_job_id,
        jsonb_build_object('current_value', v_current_value, 'threshold', v_badge_record.criteria_threshold)
      );
      
      v_badges_awarded := v_badges_awarded + 1;
      
    ELSIF NOT v_meets_criteria AND v_has_badge THEN
      -- Revoke badge
      UPDATE public.user_badges
      SET
        revoked_at = now(),
        revoked_reason = 'criteria_no_longer_met'
      WHERE user_id = p_user_id
        AND badge_id = v_badge_record.id
        AND revoked_at IS NULL;
      
      -- Log to history
      INSERT INTO public.badge_history (
        user_id,
        badge_id,
        action,
        reason,
        metadata
      ) VALUES (
        p_user_id,
        v_badge_record.id,
        'revoked',
        'criteria_no_longer_met',
        jsonb_build_object('current_value', v_current_value, 'threshold', v_badge_record.criteria_threshold)
      );
      
      v_badges_revoked := v_badges_revoked + 1;
    END IF;
  END LOOP;
  
  RETURN jsonb_build_object(
    'badges_awarded', v_badges_awarded,
    'badges_revoked', v_badges_revoked
  );
END;
$$;

-- =====================================================
-- FUNCTION: manually_award_badge
-- =====================================================
-- Admin function to manually award a badge
CREATE OR REPLACE FUNCTION public.manually_award_badge(
  p_user_id uuid,
  p_badge_code text,
  p_reason text,
  p_admin_id uuid
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_badge_id uuid;
  v_user_badge_id uuid;
BEGIN
  -- Get badge ID
  SELECT id INTO v_badge_id
  FROM public.badges
  WHERE code = p_badge_code;
  
  IF v_badge_id IS NULL THEN
    RAISE EXCEPTION 'Badge not found: %', p_badge_code;
  END IF;
  
  -- Award badge
  INSERT INTO public.user_badges (
    user_id,
    badge_id,
    awarded_at,
    awarded_reason
  ) VALUES (
    p_user_id,
    v_badge_id,
    now(),
    p_reason
  )
  ON CONFLICT (user_id, badge_id) 
  DO UPDATE SET
    revoked_at = NULL,
    revoked_reason = NULL,
    awarded_at = now(),
    awarded_reason = p_reason
  RETURNING id INTO v_user_badge_id;
  
  -- Log to history
  INSERT INTO public.badge_history (
    user_id,
    badge_id,
    action,
    reason,
    triggered_by
  ) VALUES (
    p_user_id,
    v_badge_id,
    'awarded',
    p_reason,
    p_admin_id
  );
  
  RETURN v_user_badge_id;
END;
$$;

-- =====================================================
-- FUNCTION: manually_revoke_badge
-- =====================================================
-- Admin function to manually revoke a badge
CREATE OR REPLACE FUNCTION public.manually_revoke_badge(
  p_user_id uuid,
  p_badge_code text,
  p_reason text,
  p_admin_id uuid
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_badge_id uuid;
BEGIN
  -- Get badge ID
  SELECT id INTO v_badge_id
  FROM public.badges
  WHERE code = p_badge_code;
  
  IF v_badge_id IS NULL THEN
    RAISE EXCEPTION 'Badge not found: %', p_badge_code;
  END IF;
  
  -- Revoke badge
  UPDATE public.user_badges
  SET
    revoked_at = now(),
    revoked_reason = p_reason
  WHERE user_id = p_user_id
    AND badge_id = v_badge_id
    AND revoked_at IS NULL;
  
  -- Log to history
  INSERT INTO public.badge_history (
    user_id,
    badge_id,
    action,
    reason,
    triggered_by
  ) VALUES (
    p_user_id,
    v_badge_id,
    'revoked',
    p_reason,
    p_admin_id
  );
  
  RETURN true;
END;
$$;

COMMIT;
\n-- ===================================================================
-- END: 0021_badge_awarding_system.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0022_trust_system_triggers.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0014: TRUST SYSTEM TRIGGERS
-- =====================================================
-- Purpose: Automatic triggers for trust system workflows
-- =====================================================

BEGIN;

-- =====================================================
-- TRIGGER: After job finalized, create review prompts
-- =====================================================
CREATE OR REPLACE FUNCTION public.trigger_create_review_prompts()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_customer_id uuid;
  v_mechanic_id uuid;
BEGIN
  -- Only trigger when finalized_at is set for the first time
  IF NEW.finalized_at IS NOT NULL AND (OLD.finalized_at IS NULL OR OLD.finalized_at IS DISTINCT FROM NEW.finalized_at) THEN
    -- Get customer and mechanic IDs
    SELECT j.customer_id, jc.mechanic_id
    INTO v_customer_id, v_mechanic_id
    FROM public.jobs j
    JOIN public.job_contracts jc ON jc.job_id = j.id
    WHERE j.id = NEW.job_id
    LIMIT 1;
    
    IF v_customer_id IS NOT NULL AND v_mechanic_id IS NOT NULL THEN
      PERFORM public.create_review_prompts(NEW.job_id, v_customer_id, v_mechanic_id);
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trigger_create_review_prompts_on_finalize ON public.job_progress;
CREATE TRIGGER trigger_create_review_prompts_on_finalize
  AFTER UPDATE ON public.job_progress
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_create_review_prompts();

-- =====================================================
-- TRIGGER: After review published, process skill verifications
-- =====================================================
CREATE OR REPLACE FUNCTION public.trigger_process_skill_verifications()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_mechanic_id uuid;
  v_customer_rating int;
BEGIN
  -- Only trigger when review becomes visible
  IF NEW.visibility = 'visible' AND (OLD.visibility IS NULL OR OLD.visibility != 'visible') THEN
    -- Check if this is a customer reviewing a mechanic
    SELECT p.id, NEW.overall_rating
    INTO v_mechanic_id, v_customer_rating
    FROM public.profiles p
    WHERE p.id = NEW.reviewee_id
      AND p.role = 'mechanic';
    
    IF v_mechanic_id IS NOT NULL THEN
      PERFORM public.process_skill_verifications(NEW.job_id, v_mechanic_id, v_customer_rating);
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trigger_process_skill_verifications_on_review ON public.reviews;
CREATE TRIGGER trigger_process_skill_verifications_on_review
  AFTER UPDATE ON public.reviews
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_process_skill_verifications();

-- =====================================================
-- TRIGGER: After review published, evaluate badges
-- =====================================================
CREATE OR REPLACE FUNCTION public.trigger_evaluate_badges_on_review()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Only trigger when review becomes visible
  IF NEW.visibility = 'visible' AND (OLD.visibility IS NULL OR OLD.visibility != 'visible') THEN
    -- Evaluate badges for both reviewer and reviewee
    PERFORM public.evaluate_and_award_badges(NEW.reviewer_id, 'review_published', NEW.job_id);
    PERFORM public.evaluate_and_award_badges(NEW.reviewee_id, 'review_published', NEW.job_id);
    
    -- Recalculate trust scores
    PERFORM public.calculate_trust_score(NEW.reviewer_id);
    PERFORM public.calculate_trust_score(NEW.reviewee_id);
  END IF;
  
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trigger_evaluate_badges_on_review ON public.reviews;
CREATE TRIGGER trigger_evaluate_badges_on_review
  AFTER UPDATE ON public.reviews
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_evaluate_badges_on_review();

-- =====================================================
-- TRIGGER: After job completed, evaluate badges
-- =====================================================
CREATE OR REPLACE FUNCTION public.trigger_evaluate_badges_on_job_complete()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Only trigger when status changes to completed
  IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
    -- Evaluate badges for mechanic
    PERFORM public.evaluate_and_award_badges(NEW.mechanic_id, 'job_completed', NEW.job_id);
    
    -- Recalculate trust score
    PERFORM public.calculate_trust_score(NEW.mechanic_id);
  END IF;
  
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trigger_evaluate_badges_on_job_complete ON public.job_contracts;
CREATE TRIGGER trigger_evaluate_badges_on_job_complete
  AFTER UPDATE ON public.job_contracts
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_evaluate_badges_on_job_complete();

-- =====================================================
-- TRIGGER: Lock job skills when work starts
-- =====================================================
CREATE OR REPLACE FUNCTION public.trigger_lock_job_skills()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Lock skills when work_started_at is set
  IF NEW.work_started_at IS NOT NULL AND (OLD.work_started_at IS NULL OR OLD.work_started_at IS DISTINCT FROM NEW.work_started_at) THEN
    PERFORM public.lock_job_skills(NEW.job_id);
  END IF;
  
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trigger_lock_job_skills_on_work_start ON public.job_progress;
CREATE TRIGGER trigger_lock_job_skills_on_work_start
  AFTER UPDATE ON public.job_progress
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_lock_job_skills();

COMMIT;
\n-- ===================================================================
-- END: 0022_trust_system_triggers.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0023_financial_visibility_system.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0023: FINANCIAL VISIBILITY SYSTEM
-- =====================================================
-- Purpose: Production-grade financial ledger, invoices, and audit trail
-- =====================================================

BEGIN;

-- =====================================================
-- ENUM: Ledger entry types
-- =====================================================
DO $$ BEGIN
  CREATE TYPE public.ledger_entry_type AS ENUM (
    'job_payment',           -- Customer payment for job
    'platform_fee',          -- Platform fee charged
    'mechanic_commission',   -- Commission deducted from mechanic
    'mechanic_payout',       -- Payout to mechanic
    'travel_fee',            -- Travel/arrival fee
    'parts_charge',          -- Parts charges
    'labor_charge',          -- Labor charges
    'addon_charge',          -- Add-on charges
    'tax',                   -- Tax charges
    'refund',                -- Refund to customer
    'adjustment',            -- Manual adjustment
    'cancellation_fee',      -- Cancellation fee
    'no_show_fee',           -- No-show fee
    'dispute_hold',          -- Amount held for dispute
    'dispute_release',       -- Amount released after dispute
    'dispute_deduction'      -- Amount deducted due to dispute
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  CREATE TYPE public.invoice_status AS ENUM (
    'draft',
    'finalized',
    'paid',
    'partially_refunded',
    'fully_refunded',
    'voided'
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  CREATE TYPE public.invoice_type AS ENUM (
    'customer_invoice',
    'mechanic_statement'
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- =====================================================
-- TABLE: financial_ledger
-- =====================================================
-- Immutable audit trail of all financial transactions
CREATE TABLE IF NOT EXISTS public.financial_ledger (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- References
  job_id uuid REFERENCES public.jobs(id) ON DELETE SET NULL,
  contract_id uuid REFERENCES public.job_contracts(id) ON DELETE SET NULL,
  payout_id uuid REFERENCES public.payouts(id) ON DELETE SET NULL,
  
  -- Parties
  from_party_id uuid REFERENCES public.profiles(id),  -- Who paid
  to_party_id uuid REFERENCES public.profiles(id),    -- Who received
  from_party_type text,  -- 'customer', 'mechanic', 'platform'
  to_party_type text,    -- 'customer', 'mechanic', 'platform'
  
  -- Transaction details
  entry_type public.ledger_entry_type NOT NULL,
  amount_cents int NOT NULL,  -- Always positive, direction determined by from/to
  currency text DEFAULT 'USD' NOT NULL,
  
  -- Description
  description text NOT NULL,
  reference_id text,  -- External reference (Stripe ID, etc.)
  
  -- Metadata
  metadata jsonb DEFAULT '{}',
  
  -- Immutability
  is_immutable boolean DEFAULT true NOT NULL,
  superseded_by uuid REFERENCES public.financial_ledger(id),
  supersedes uuid REFERENCES public.financial_ledger(id),
  
  -- Timestamps
  created_at timestamptz DEFAULT now() NOT NULL,
  effective_at timestamptz DEFAULT now() NOT NULL,
  
  -- Audit
  created_by uuid REFERENCES public.profiles(id),
  
  CONSTRAINT positive_amount CHECK (amount_cents >= 0)
);

COMMENT ON TABLE public.financial_ledger IS 'Immutable financial audit trail';

-- =====================================================
-- TABLE: invoices
-- =====================================================
CREATE TABLE IF NOT EXISTS public.invoices (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Invoice number (human readable)
  invoice_number text UNIQUE NOT NULL,
  
  -- References
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  contract_id uuid REFERENCES public.job_contracts(id) ON DELETE SET NULL,
  
  -- Type and parties
  invoice_type public.invoice_type NOT NULL,
  issuer_id uuid NOT NULL REFERENCES public.profiles(id),  -- Platform or mechanic
  recipient_id uuid NOT NULL REFERENCES public.profiles(id),  -- Customer or mechanic
  
  -- Status
  status public.invoice_status DEFAULT 'draft' NOT NULL,
  
  -- Amounts (all in cents)
  subtotal_cents int NOT NULL DEFAULT 0,
  platform_fee_cents int NOT NULL DEFAULT 0,
  travel_fee_cents int NOT NULL DEFAULT 0,
  tax_cents int NOT NULL DEFAULT 0,
  discount_cents int NOT NULL DEFAULT 0,
  total_cents int NOT NULL DEFAULT 0,
  
  -- For mechanic statements
  gross_earnings_cents int DEFAULT 0,
  commission_deducted_cents int DEFAULT 0,
  adjustments_cents int DEFAULT 0,
  net_payout_cents int DEFAULT 0,
  
  -- Payment info
  payment_method text,
  payment_reference text,
  paid_at timestamptz,
  
  -- Versioning for adjustments
  version int DEFAULT 1 NOT NULL,
  previous_version_id uuid REFERENCES public.invoices(id),
  adjustment_reason text,
  
  -- Timestamps
  created_at timestamptz DEFAULT now() NOT NULL,
  finalized_at timestamptz,
  updated_at timestamptz DEFAULT now() NOT NULL,
  
  -- Metadata
  metadata jsonb DEFAULT '{}',
  
  CONSTRAINT valid_amounts CHECK (
    subtotal_cents >= 0 AND
    platform_fee_cents >= 0 AND
    travel_fee_cents >= 0 AND
    tax_cents >= 0 AND
    discount_cents >= 0 AND
    total_cents >= 0
  )
);

COMMENT ON TABLE public.invoices IS 'Customer invoices and mechanic statements';

-- =====================================================
-- TABLE: invoice_items
-- =====================================================
CREATE TABLE IF NOT EXISTS public.invoice_items (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  invoice_id uuid NOT NULL REFERENCES public.invoices(id) ON DELETE CASCADE,
  
  -- Item details
  item_type text NOT NULL,  -- 'labor', 'parts', 'travel', 'platform_fee', 'tax', etc.
  description text NOT NULL,
  quantity numeric DEFAULT 1 NOT NULL,
  unit_price_cents int NOT NULL,
  total_cents int NOT NULL,
  
  -- For parts
  part_number text,
  part_source text,
  
  -- Ordering
  sort_order int DEFAULT 0,
  
  -- Timestamps
  created_at timestamptz DEFAULT now() NOT NULL,
  
  CONSTRAINT positive_item_amounts CHECK (
    quantity > 0 AND
    unit_price_cents >= 0 AND
    total_cents >= 0
  )
);

COMMENT ON TABLE public.invoice_items IS 'Line items on invoices';

-- =====================================================
-- TABLE: financial_summaries (materialized view alternative)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.financial_summaries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  user_role text NOT NULL,  -- 'customer' or 'mechanic'
  
  -- Period
  period_type text NOT NULL,  -- 'all_time', 'year', 'month', 'week'
  period_start date,
  period_end date,
  
  -- Aggregates
  total_jobs int DEFAULT 0,
  total_amount_cents bigint DEFAULT 0,
  total_fees_cents bigint DEFAULT 0,
  total_payouts_cents bigint DEFAULT 0,
  pending_payouts_cents bigint DEFAULT 0,
  
  -- Last updated
  calculated_at timestamptz DEFAULT now() NOT NULL,
  
  UNIQUE(user_id, period_type, period_start)
);

COMMENT ON TABLE public.financial_summaries IS 'Pre-calculated financial summaries';

-- =====================================================
-- INDEXES
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_financial_ledger_job_id ON public.financial_ledger(job_id);
CREATE INDEX IF NOT EXISTS idx_financial_ledger_contract_id ON public.financial_ledger(contract_id);
CREATE INDEX IF NOT EXISTS idx_financial_ledger_from_party ON public.financial_ledger(from_party_id);
CREATE INDEX IF NOT EXISTS idx_financial_ledger_to_party ON public.financial_ledger(to_party_id);
CREATE INDEX IF NOT EXISTS idx_financial_ledger_entry_type ON public.financial_ledger(entry_type);
CREATE INDEX IF NOT EXISTS idx_financial_ledger_effective_at ON public.financial_ledger(effective_at);

CREATE INDEX IF NOT EXISTS idx_invoices_job_id ON public.invoices(job_id);
CREATE INDEX IF NOT EXISTS idx_invoices_recipient_id ON public.invoices(recipient_id);
CREATE INDEX IF NOT EXISTS idx_invoices_status ON public.invoices(status);
CREATE INDEX IF NOT EXISTS idx_invoices_type ON public.invoices(invoice_type);

CREATE INDEX IF NOT EXISTS idx_invoice_items_invoice_id ON public.invoice_items(invoice_id);

CREATE INDEX IF NOT EXISTS idx_financial_summaries_user_id ON public.financial_summaries(user_id);

-- =====================================================
-- FUNCTION: Generate invoice number
-- =====================================================
CREATE OR REPLACE FUNCTION public.generate_invoice_number(p_type public.invoice_type)
RETURNS text
LANGUAGE plpgsql
AS $$
DECLARE
  v_prefix text;
  v_seq int;
  v_year text;
BEGIN
  v_year := to_char(now(), 'YY');
  
  IF p_type = 'customer_invoice' THEN
    v_prefix := 'INV';
  ELSE
    v_prefix := 'STM';
  END IF;
  
  SELECT COALESCE(MAX(
    CASE 
      WHEN invoice_number ~ ('^' || v_prefix || '-' || v_year || '-[0-9]+$')
      THEN CAST(split_part(invoice_number, '-', 3) AS int)
      ELSE 0
    END
  ), 0) + 1
  INTO v_seq
  FROM public.invoices
  WHERE invoice_type = p_type;
  
  RETURN v_prefix || '-' || v_year || '-' || LPAD(v_seq::text, 6, '0');
END;
$$;

-- =====================================================
-- FUNCTION: Create ledger entry
-- =====================================================
CREATE OR REPLACE FUNCTION public.create_ledger_entry(
  p_job_id uuid,
  p_contract_id uuid,
  p_entry_type public.ledger_entry_type,
  p_amount_cents int,
  p_from_party_id uuid,
  p_from_party_type text,
  p_to_party_id uuid,
  p_to_party_type text,
  p_description text,
  p_reference_id text DEFAULT NULL,
  p_metadata jsonb DEFAULT '{}'
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_entry_id uuid;
BEGIN
  INSERT INTO public.financial_ledger (
    job_id, contract_id, entry_type, amount_cents,
    from_party_id, from_party_type, to_party_id, to_party_type,
    description, reference_id, metadata, created_by
  ) VALUES (
    p_job_id, p_contract_id, p_entry_type, p_amount_cents,
    p_from_party_id, p_from_party_type, p_to_party_id, p_to_party_type,
    p_description, p_reference_id, p_metadata, auth.uid()
  )
  RETURNING id INTO v_entry_id;
  
  RETURN v_entry_id;
END;
$$;

-- =====================================================
-- FUNCTION: Generate invoices for completed job
-- =====================================================
CREATE OR REPLACE FUNCTION public.generate_job_invoices(p_job_id uuid)
RETURNS TABLE(customer_invoice_id uuid, mechanic_statement_id uuid)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_job record;
  v_contract record;
  v_customer_invoice_id uuid;
  v_mechanic_statement_id uuid;
  v_line_item record;
  v_platform_id uuid;
BEGIN
  -- Get job and contract details
  SELECT j.*, c.id as contract_id, c.quoted_price_cents, c.platform_fee_cents,
         c.subtotal_cents, c.total_customer_cents, c.mechanic_commission_cents,
         c.mechanic_payout_cents, c.stripe_payment_intent_id
  INTO v_job
  FROM public.jobs j
  JOIN public.job_contracts c ON c.job_id = j.id
  WHERE j.id = p_job_id;
  
  IF v_job IS NULL THEN
    RAISE EXCEPTION 'Job or contract not found';
  END IF;
  
  -- Platform ID is NULL (system-level entity, no user profile)
  v_platform_id := NULL;
  
  -- Create customer invoice
  INSERT INTO public.invoices (
    invoice_number, job_id, contract_id, invoice_type,
    issuer_id, recipient_id, status,
    subtotal_cents, platform_fee_cents, total_cents,
    payment_method, payment_reference, paid_at, finalized_at
  ) VALUES (
    public.generate_invoice_number('customer_invoice'),
    p_job_id, v_job.contract_id, 'customer_invoice',
    COALESCE(v_platform_id, v_job.accepted_mechanic_id), v_job.customer_id, 'paid',
    v_job.subtotal_cents, v_job.platform_fee_cents, v_job.total_customer_cents,
    'card', v_job.stripe_payment_intent_id, now(), now()
  )
  RETURNING id INTO v_customer_invoice_id;
  
  -- Add line items from contract
  FOR v_line_item IN
    SELECT * FROM public.invoice_line_items
    WHERE contract_id = v_job.contract_id
    AND approval_status = 'approved'
    ORDER BY sort_order
  LOOP
    INSERT INTO public.invoice_items (
      invoice_id, item_type, description, quantity,
      unit_price_cents, total_cents, part_number, part_source, sort_order
    ) VALUES (
      v_customer_invoice_id, v_line_item.item_type::text, v_line_item.description,
      v_line_item.quantity, v_line_item.unit_price_cents, v_line_item.total_cents,
      v_line_item.part_number, v_line_item.part_source, v_line_item.sort_order
    );
  END LOOP;
  
  -- Add platform fee as line item
  IF v_job.platform_fee_cents > 0 THEN
    INSERT INTO public.invoice_items (
      invoice_id, item_type, description, quantity,
      unit_price_cents, total_cents, sort_order
    ) VALUES (
      v_customer_invoice_id, 'platform_fee', 'Service Fee', 1,
      v_job.platform_fee_cents, v_job.platform_fee_cents, 9999
    );
  END IF;
  
  -- Create mechanic statement
  INSERT INTO public.invoices (
    invoice_number, job_id, contract_id, invoice_type,
    issuer_id, recipient_id, status,
    gross_earnings_cents, commission_deducted_cents, net_payout_cents,
    finalized_at
  ) VALUES (
    public.generate_invoice_number('mechanic_statement'),
    p_job_id, v_job.contract_id, 'mechanic_statement',
    COALESCE(v_platform_id, v_job.accepted_mechanic_id), v_job.accepted_mechanic_id, 'finalized',
    v_job.subtotal_cents, v_job.mechanic_commission_cents, v_job.mechanic_payout_cents,
    now()
  )
  RETURNING id INTO v_mechanic_statement_id;
  
  -- Add earnings breakdown to mechanic statement
  INSERT INTO public.invoice_items (
    invoice_id, item_type, description, quantity,
    unit_price_cents, total_cents, sort_order
  ) VALUES 
    (v_mechanic_statement_id, 'gross_earnings', 'Gross Job Earnings', 1, v_job.subtotal_cents, v_job.subtotal_cents, 1),
    (v_mechanic_statement_id, 'commission', 'Platform Commission (12%, max $50)', 1, -v_job.mechanic_commission_cents, -v_job.mechanic_commission_cents, 2),
    (v_mechanic_statement_id, 'net_payout', 'Net Payout', 1, v_job.mechanic_payout_cents, v_job.mechanic_payout_cents, 3);
  
  -- Create ledger entries
  -- Customer payment
  PERFORM public.create_ledger_entry(
    p_job_id, v_job.contract_id, 'job_payment', v_job.total_customer_cents,
    v_job.customer_id, 'customer', NULL, 'platform',
    'Payment for job ' || p_job_id::text,
    v_job.stripe_payment_intent_id
  );
  
  -- Platform fee
  IF v_job.platform_fee_cents > 0 THEN
    PERFORM public.create_ledger_entry(
      p_job_id, v_job.contract_id, 'platform_fee', v_job.platform_fee_cents,
      v_job.customer_id, 'customer', NULL, 'platform',
      'Platform service fee'
    );
  END IF;
  
  -- Mechanic commission
  IF v_job.mechanic_commission_cents > 0 THEN
    PERFORM public.create_ledger_entry(
      p_job_id, v_job.contract_id, 'mechanic_commission', v_job.mechanic_commission_cents,
      v_job.accepted_mechanic_id, 'mechanic', NULL, 'platform',
      'Platform commission (12%, max $50)'
    );
  END IF;
  
  RETURN QUERY SELECT v_customer_invoice_id, v_mechanic_statement_id;
END;
$$;

-- =====================================================
-- FUNCTION: Get job financial breakdown (customer view)
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_customer_job_financials(p_job_id uuid, p_customer_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result jsonb;
BEGIN
  SELECT jsonb_build_object(
    'job_id', j.id,
    'quote_amount_cents', c.quoted_price_cents,
    'subtotal_cents', c.subtotal_cents,
    'platform_fee_cents', c.platform_fee_cents,
    'total_cents', c.total_customer_cents,
    'payment_status', CASE WHEN c.payment_captured_at IS NOT NULL THEN 'paid' ELSE 'pending' END,
    'payment_method', 'card',
    'paid_at', c.payment_captured_at,
    'invoice', (
      SELECT jsonb_build_object(
        'id', i.id,
        'invoice_number', i.invoice_number,
        'status', i.status,
        'items', (
          SELECT jsonb_agg(jsonb_build_object(
            'type', ii.item_type,
            'description', ii.description,
            'quantity', ii.quantity,
            'unit_price_cents', ii.unit_price_cents,
            'total_cents', ii.total_cents
          ) ORDER BY ii.sort_order)
          FROM public.invoice_items ii
          WHERE ii.invoice_id = i.id
        )
      )
      FROM public.invoices i
      WHERE i.job_id = j.id AND i.invoice_type = 'customer_invoice'
      LIMIT 1
    ),
    'line_items', (
      SELECT jsonb_agg(jsonb_build_object(
        'type', ili.item_type,
        'description', ili.description,
        'quantity', ili.quantity,
        'unit_price_cents', ili.unit_price_cents,
        'total_cents', ili.total_cents,
        'status', ili.approval_status
      ) ORDER BY ili.sort_order)
      FROM public.invoice_line_items ili
      WHERE ili.contract_id = c.id
    )
  )
  INTO v_result
  FROM public.jobs j
  JOIN public.job_contracts c ON c.job_id = j.id
  WHERE j.id = p_job_id AND j.customer_id = p_customer_id;
  
  RETURN COALESCE(v_result, '{}'::jsonb);
END;
$$;

-- =====================================================
-- FUNCTION: Get job financial breakdown (mechanic view)
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_mechanic_job_financials(p_job_id uuid, p_mechanic_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result jsonb;
BEGIN
  SELECT jsonb_build_object(
    'job_id', j.id,
    'gross_amount_cents', c.subtotal_cents,
    'commission_cents', c.mechanic_commission_cents,
    'net_payout_cents', c.mechanic_payout_cents,
    'payout_status', COALESCE(p.status::text, 'pending'),
    'payout_id', p.id,
    'stripe_transfer_id', p.stripe_transfer_id,
    'statement', (
      SELECT jsonb_build_object(
        'id', i.id,
        'invoice_number', i.invoice_number,
        'status', i.status,
        'items', (
          SELECT jsonb_agg(jsonb_build_object(
            'type', ii.item_type,
            'description', ii.description,
            'total_cents', ii.total_cents
          ) ORDER BY ii.sort_order)
          FROM public.invoice_items ii
          WHERE ii.invoice_id = i.id
        )
      )
      FROM public.invoices i
      WHERE i.job_id = j.id AND i.invoice_type = 'mechanic_statement'
      LIMIT 1
    )
  )
  INTO v_result
  FROM public.jobs j
  JOIN public.job_contracts c ON c.job_id = j.id
  LEFT JOIN public.payouts p ON p.contract_id = c.id
  WHERE j.id = p_job_id AND j.accepted_mechanic_id = p_mechanic_id;
  
  RETURN COALESCE(v_result, '{}'::jsonb);
END;
$$;

-- =====================================================
-- FUNCTION: Get financial summary
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_financial_summary(
  p_user_id uuid,
  p_role text,
  p_period_type text DEFAULT 'all_time'
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result jsonb;
  v_start_date date;
BEGIN
  -- Calculate period start
  v_start_date := CASE p_period_type
    WHEN 'week' THEN CURRENT_DATE - INTERVAL '7 days'
    WHEN 'month' THEN CURRENT_DATE - INTERVAL '30 days'
    WHEN 'year' THEN CURRENT_DATE - INTERVAL '365 days'
    ELSE NULL
  END;
  
  IF p_role = 'mechanic' THEN
    SELECT jsonb_build_object(
      'total_jobs', COUNT(DISTINCT j.id),
      'total_earnings_cents', COALESCE(SUM(c.mechanic_payout_cents), 0),
      'total_commission_cents', COALESCE(SUM(c.mechanic_commission_cents), 0),
      'pending_payouts_cents', COALESCE(SUM(
        CASE WHEN p.status = 'pending' THEN p.net_amount_cents ELSE 0 END
      ), 0),
      'completed_payouts_cents', COALESCE(SUM(
        CASE WHEN p.status = 'completed' THEN p.net_amount_cents ELSE 0 END
      ), 0)
    )
    INTO v_result
    FROM public.jobs j
    JOIN public.job_contracts c ON c.job_id = j.id
    LEFT JOIN public.payouts p ON p.contract_id = c.id
    WHERE j.accepted_mechanic_id = p_user_id
      AND j.status = 'completed'
      AND (v_start_date IS NULL OR j.created_at >= v_start_date);
  ELSE
    SELECT jsonb_build_object(
      'total_jobs', COUNT(DISTINCT j.id),
      'total_spent_cents', COALESCE(SUM(c.total_customer_cents), 0),
      'total_fees_cents', COALESCE(SUM(c.platform_fee_cents), 0)
    )
    INTO v_result
    FROM public.jobs j
    JOIN public.job_contracts c ON c.job_id = j.id
    WHERE j.customer_id = p_user_id
      AND j.status = 'completed'
      AND (v_start_date IS NULL OR j.created_at >= v_start_date);
  END IF;
  
  RETURN COALESCE(v_result, '{}'::jsonb);
END;
$$;

-- =====================================================
-- FUNCTION: Process refund
-- =====================================================
CREATE OR REPLACE FUNCTION public.process_refund(
  p_job_id uuid,
  p_amount_cents int,
  p_reason text,
  p_initiated_by uuid
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_job record;
  v_entry_id uuid;
BEGIN
  SELECT j.*, c.id as contract_id, c.total_customer_cents
  INTO v_job
  FROM public.jobs j
  JOIN public.job_contracts c ON c.job_id = j.id
  WHERE j.id = p_job_id;
  
  IF v_job IS NULL THEN
    RAISE EXCEPTION 'Job not found';
  END IF;
  
  IF p_amount_cents > v_job.total_customer_cents THEN
    RAISE EXCEPTION 'Refund amount exceeds total paid';
  END IF;
  
  -- Create refund ledger entry
  v_entry_id := public.create_ledger_entry(
    p_job_id, v_job.contract_id, 'refund', p_amount_cents,
    NULL, 'platform', v_job.customer_id, 'customer',
    'Refund: ' || p_reason
  );
  
  -- Update invoice status
  UPDATE public.invoices
  SET status = CASE 
    WHEN p_amount_cents >= v_job.total_customer_cents THEN 'fully_refunded'
    ELSE 'partially_refunded'
  END,
  updated_at = now()
  WHERE job_id = p_job_id AND invoice_type = 'customer_invoice';
  
  RETURN v_entry_id;
END;
$$;

-- =====================================================
-- RLS POLICIES
-- =====================================================
ALTER TABLE public.financial_ledger ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.invoice_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.financial_summaries ENABLE ROW LEVEL SECURITY;

-- Financial ledger: users can see entries where they are a party
CREATE POLICY "Users can view their ledger entries"
  ON public.financial_ledger FOR SELECT
  USING (
    from_party_id = auth.uid() OR
    to_party_id = auth.uid()
  );

-- Invoices: users can see their own invoices
CREATE POLICY "Users can view their invoices"
  ON public.invoices FOR SELECT
  USING (
    recipient_id = auth.uid() OR
    issuer_id = auth.uid()
  );

-- Invoice items: through invoice access
CREATE POLICY "Users can view invoice items"
  ON public.invoice_items FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.invoices i
      WHERE i.id = invoice_id
      AND (i.recipient_id = auth.uid() OR i.issuer_id = auth.uid())
    )
  );

-- Financial summaries: users can see their own
CREATE POLICY "Users can view their summaries"
  ON public.financial_summaries FOR SELECT
  USING (user_id = auth.uid());

COMMIT;
\n-- ===================================================================
-- END: 0023_financial_visibility_system.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0024_job_lifecycle_hardening.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0024: Job Lifecycle Hardening
-- =====================================================
-- Purpose: Fix quote status bug, add race condition protection,
--          improve status reconciliation, clarify payment flow
-- =====================================================

BEGIN;

-- =====================================================
-- 1. FIX: Quote acceptance trigger (rejected  declined)
-- =====================================================
-- The 'rejected' status doesn't exist in quote_status enum
-- Valid values: pending, accepted, declined, expired, withdrawn

CREATE OR REPLACE FUNCTION public.on_quote_accepted()
RETURNS TRIGGER AS $$
BEGIN
  -- Only process if transitioning TO accepted from a non-accepted state
  IF NEW.status = 'accepted' AND (OLD.status IS NULL OR OLD.status <> 'accepted') THEN
    -- Ensure only pending quotes can be accepted
    IF OLD.status <> 'pending' THEN
      RAISE EXCEPTION 'Only pending quotes can be accepted. Current status: %', OLD.status;
    END IF;
    
    -- Update job status and assign mechanic
    UPDATE public.jobs
    SET 
      status = 'accepted',
      accepted_mechanic_id = NEW.mechanic_id,
      updated_at = NOW()
    WHERE id = NEW.job_id
      AND status IN ('searching', 'quoted');
    
    -- Decline all other pending quotes for this job (FIX: was 'rejected')
    UPDATE public.quotes
    SET status = 'declined', updated_at = NOW()
    WHERE job_id = NEW.job_id
      AND id <> NEW.id
      AND status = 'pending';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 2. CONSTRAINT: Only one accepted quote per job
-- =====================================================
-- Partial unique index prevents race conditions at DB level

CREATE UNIQUE INDEX IF NOT EXISTS uniq_one_accepted_quote_per_job
ON public.quotes(job_id)
WHERE status = 'accepted';

COMMENT ON INDEX uniq_one_accepted_quote_per_job IS 
  'Ensures only one quote can be accepted per job, preventing race conditions';

-- =====================================================
-- 3. IMPROVED: Job effective status reconciliation
-- =====================================================
-- Self-healing function that fixes inconsistent states
-- Safe to call from API layer, idempotent

CREATE OR REPLACE FUNCTION public.get_job_effective_status(p_job_id UUID)
RETURNS TEXT AS $$
DECLARE
  v_job RECORD;
  v_has_pending_quotes BOOLEAN;
  v_has_accepted_quote BOOLEAN;
  v_contract_status TEXT;
BEGIN
  -- Get current job state
  SELECT id, status INTO v_job FROM public.jobs WHERE id = p_job_id;
  
  IF v_job IS NULL THEN
    RETURN NULL;
  END IF;
  
  -- Never override cancelled status
  IF v_job.status = 'cancelled' THEN
    RETURN 'cancelled';
  END IF;
  
  -- Check for accepted quote
  SELECT EXISTS(
    SELECT 1 FROM public.quotes WHERE job_id = p_job_id AND status = 'accepted'
  ) INTO v_has_accepted_quote;
  
  -- If accepted quote exists, job must be accepted
  IF v_has_accepted_quote THEN
    IF v_job.status <> 'accepted' THEN
      UPDATE public.jobs 
      SET status = 'accepted', updated_at = NOW() 
      WHERE id = p_job_id;
    END IF;
    RETURN 'accepted';
  END IF;
  
  -- Check for pending quotes
  SELECT EXISTS(
    SELECT 1 FROM public.quotes WHERE job_id = p_job_id AND status = 'pending'
  ) INTO v_has_pending_quotes;
  
  -- If pending quotes exist and job is searching, upgrade to quoted
  IF v_has_pending_quotes AND v_job.status = 'searching' THEN
    UPDATE public.jobs 
    SET status = 'quoted', updated_at = NOW() 
    WHERE id = p_job_id;
    RETURN 'quoted';
  END IF;
  
  -- If job is quoted but no pending quotes, revert to searching
  IF NOT v_has_pending_quotes AND v_job.status = 'quoted' THEN
    UPDATE public.jobs 
    SET status = 'searching', updated_at = NOW() 
    WHERE id = p_job_id;
    RETURN 'searching';
  END IF;
  
  RETURN v_job.status;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 4. FUNCTION: Accept quote and create contract
-- =====================================================
-- Atomic operation: accept quote + create contract + authorize payment
-- Returns contract_id on success

CREATE OR REPLACE FUNCTION public.accept_quote_and_create_contract(
  p_quote_id UUID,
  p_stripe_payment_intent_id TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  v_quote RECORD;
  v_job RECORD;
  v_contract_id UUID;
  v_platform_fee_cents INT := 1500; -- $15 flat
  v_commission_rate NUMERIC := 0.12; -- 12%
  v_commission_cap_cents INT := 5000; -- $50 cap
  v_commission_cents INT;
  v_mechanic_payout_cents INT;
  v_total_customer_cents INT;
BEGIN
  -- Lock and fetch quote
  SELECT * INTO v_quote 
  FROM public.quotes 
  WHERE id = p_quote_id 
  FOR UPDATE;
  
  IF v_quote IS NULL THEN
    RAISE EXCEPTION 'Quote not found: %', p_quote_id;
  END IF;
  
  IF v_quote.status <> 'pending' THEN
    RAISE EXCEPTION 'Quote is not pending. Current status: %', v_quote.status;
  END IF;
  
  -- Lock and fetch job
  SELECT * INTO v_job 
  FROM public.jobs 
  WHERE id = v_quote.job_id 
  FOR UPDATE;
  
  IF v_job IS NULL THEN
    RAISE EXCEPTION 'Job not found: %', v_quote.job_id;
  END IF;
  
  IF v_job.status NOT IN ('searching', 'quoted') THEN
    RAISE EXCEPTION 'Job is not available for quote acceptance. Status: %', v_job.status;
  END IF;
  
  -- Check no other accepted quote exists (belt + suspenders with unique index)
  IF EXISTS (SELECT 1 FROM public.quotes WHERE job_id = v_job.id AND status = 'accepted') THEN
    RAISE EXCEPTION 'Another quote has already been accepted for this job';
  END IF;
  
  -- Calculate fees
  v_commission_cents := LEAST(
    FLOOR(v_quote.price_cents * v_commission_rate)::INT,
    v_commission_cap_cents
  );
  v_mechanic_payout_cents := v_quote.price_cents - v_commission_cents;
  v_total_customer_cents := v_quote.price_cents + v_platform_fee_cents;
  
  -- Accept the quote (triggers on_quote_accepted)
  UPDATE public.quotes
  SET status = 'accepted', updated_at = NOW()
  WHERE id = p_quote_id;
  
  -- Create contract
  INSERT INTO public.job_contracts (
    job_id,
    quote_id,
    customer_id,
    mechanic_id,
    status,
    quoted_price_cents,
    platform_fee_cents,
    estimated_hours,
    subtotal_cents,
    total_customer_cents,
    mechanic_commission_cents,
    mechanic_payout_cents,
    stripe_payment_intent_id,
    payment_authorized_at
  ) VALUES (
    v_job.id,
    p_quote_id,
    v_job.customer_id,
    v_quote.mechanic_id,
    CASE WHEN p_stripe_payment_intent_id IS NOT NULL THEN 'active'::contract_status ELSE 'pending_payment'::contract_status END,
    v_quote.price_cents,
    v_platform_fee_cents,
    v_quote.estimated_hours,
    v_quote.price_cents,
    v_total_customer_cents,
    v_commission_cents,
    v_mechanic_payout_cents,
    p_stripe_payment_intent_id,
    CASE WHEN p_stripe_payment_intent_id IS NOT NULL THEN NOW() ELSE NULL END
  )
  RETURNING id INTO v_contract_id;
  
  -- Create initial line item for quoted labor
  INSERT INTO public.invoice_line_items (
    contract_id,
    item_type,
    description,
    quantity,
    unit_price_cents,
    total_cents,
    approval_status,
    requires_approval,
    added_by,
    added_by_role
  ) VALUES (
    v_contract_id,
    'base_labor',
    COALESCE(v_quote.description, 'Labor as quoted'),
    1,
    v_quote.price_cents,
    v_quote.price_cents,
    'approved',
    false, -- Original quote doesn't need approval
    v_quote.mechanic_id,
    'mechanic'
  );
  
  -- Create job_progress record
  INSERT INTO public.job_progress (job_id, contract_id)
  VALUES (v_job.id, v_contract_id)
  ON CONFLICT (job_id) DO UPDATE SET contract_id = v_contract_id;
  
  -- Log event
  INSERT INTO public.job_events (
    job_id, contract_id, event_type, actor_id, actor_role,
    title, description, amount_cents
  ) VALUES (
    v_job.id, v_contract_id, 'quote_accepted', v_job.customer_id, 'customer',
    'Quote accepted',
    format('Customer accepted quote from mechanic for $%s', (v_quote.price_cents / 100.0)::TEXT),
    v_quote.price_cents
  );
  
  RETURN v_contract_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.accept_quote_and_create_contract(UUID, TEXT) TO authenticated;

-- =====================================================
-- 5. FUNCTION: Authorize payment on contract
-- =====================================================
-- Called after Stripe PaymentIntent is created/confirmed

CREATE OR REPLACE FUNCTION public.authorize_contract_payment(
  p_contract_id UUID,
  p_stripe_payment_intent_id TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
  v_contract RECORD;
BEGIN
  SELECT * INTO v_contract 
  FROM public.job_contracts 
  WHERE id = p_contract_id 
  FOR UPDATE;
  
  IF v_contract IS NULL THEN
    RAISE EXCEPTION 'Contract not found: %', p_contract_id;
  END IF;
  
  IF v_contract.status <> 'pending_payment' THEN
    RAISE EXCEPTION 'Contract is not pending payment. Status: %', v_contract.status;
  END IF;
  
  UPDATE public.job_contracts
  SET 
    status = 'active',
    stripe_payment_intent_id = p_stripe_payment_intent_id,
    payment_authorized_at = NOW(),
    updated_at = NOW()
  WHERE id = p_contract_id;
  
  -- Log event
  INSERT INTO public.job_events (
    job_id, contract_id, event_type, actor_id, actor_role,
    title, description, amount_cents
  ) VALUES (
    v_contract.job_id, p_contract_id, 'payment_authorized', v_contract.customer_id, 'customer',
    'Payment authorized',
    format('Card authorized for $%s (not charged yet)', (v_contract.total_customer_cents / 100.0)::TEXT),
    v_contract.total_customer_cents
  );
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.authorize_contract_payment(UUID, TEXT) TO authenticated;

-- =====================================================
-- 6. FUNCTION: Check if mechanic can depart
-- =====================================================

CREATE OR REPLACE FUNCTION public.can_mechanic_depart(p_contract_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
  v_contract RECORD;
BEGIN
  SELECT * INTO v_contract FROM public.job_contracts WHERE id = p_contract_id;
  
  IF v_contract IS NULL THEN
    RETURN FALSE;
  END IF;
  
  -- Must have payment authorized
  RETURN v_contract.payment_authorized_at IS NOT NULL 
     AND v_contract.status = 'active';
END;
$$ LANGUAGE plpgsql STABLE;

GRANT EXECUTE ON FUNCTION public.can_mechanic_depart(UUID) TO authenticated;

-- =====================================================
-- 7. FUNCTION: Recalculate contract totals
-- =====================================================
-- Only includes approved line items

CREATE OR REPLACE FUNCTION public.recalculate_contract_totals(p_contract_id UUID)
RETURNS VOID AS $$
DECLARE
  v_subtotal_cents INT;
  v_commission_cents INT;
  v_commission_rate NUMERIC := 0.12;
  v_commission_cap_cents INT := 5000;
  v_contract RECORD;
BEGIN
  SELECT * INTO v_contract FROM public.job_contracts WHERE id = p_contract_id;
  
  IF v_contract IS NULL THEN
    RAISE EXCEPTION 'Contract not found: %', p_contract_id;
  END IF;
  
  -- Sum only approved items (excluding platform_fee type)
  SELECT COALESCE(SUM(total_cents), 0) INTO v_subtotal_cents
  FROM public.invoice_line_items
  WHERE contract_id = p_contract_id
    AND approval_status = 'approved'
    AND item_type <> 'platform_fee';
  
  -- Recalculate commission
  v_commission_cents := LEAST(
    FLOOR(v_subtotal_cents * v_commission_rate)::INT,
    v_commission_cap_cents
  );
  
  UPDATE public.job_contracts
  SET 
    subtotal_cents = v_subtotal_cents,
    total_customer_cents = v_subtotal_cents + platform_fee_cents,
    mechanic_commission_cents = v_commission_cents,
    mechanic_payout_cents = v_subtotal_cents - v_commission_cents,
    updated_at = NOW()
  WHERE id = p_contract_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 8. TRIGGER: Recalculate on line item approval
-- =====================================================

CREATE OR REPLACE FUNCTION public.on_line_item_approved()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.approval_status = 'approved' AND OLD.approval_status <> 'approved' THEN
    PERFORM public.recalculate_contract_totals(NEW.contract_id);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trg_line_item_approved ON public.invoice_line_items;
CREATE TRIGGER trg_line_item_approved
  AFTER UPDATE ON public.invoice_line_items
  FOR EACH ROW
  EXECUTE FUNCTION public.on_line_item_approved();

-- =====================================================
-- 9. FUNCTION: Complete job and capture payment
-- =====================================================

CREATE OR REPLACE FUNCTION public.finalize_job_completion(
  p_contract_id UUID,
  p_actor_id UUID,
  p_actor_role user_role
)
RETURNS BOOLEAN AS $$
DECLARE
  v_contract RECORD;
  v_progress RECORD;
BEGIN
  SELECT * INTO v_contract 
  FROM public.job_contracts 
  WHERE id = p_contract_id 
  FOR UPDATE;
  
  IF v_contract IS NULL THEN
    RAISE EXCEPTION 'Contract not found';
  END IF;
  
  IF v_contract.status <> 'active' THEN
    RAISE EXCEPTION 'Contract is not active. Status: %', v_contract.status;
  END IF;
  
  SELECT * INTO v_progress FROM public.job_progress WHERE contract_id = p_contract_id;
  
  -- Update completion timestamp based on role
  IF p_actor_role = 'mechanic' THEN
    UPDATE public.job_progress
    SET mechanic_completed_at = NOW(), updated_at = NOW()
    WHERE contract_id = p_contract_id;
    
    -- Refresh
    SELECT * INTO v_progress FROM public.job_progress WHERE contract_id = p_contract_id;
  ELSIF p_actor_role = 'customer' THEN
    UPDATE public.job_progress
    SET customer_completed_at = NOW(), updated_at = NOW()
    WHERE contract_id = p_contract_id;
    
    -- Refresh
    SELECT * INTO v_progress FROM public.job_progress WHERE contract_id = p_contract_id;
  END IF;
  
  -- Check if both parties have confirmed
  IF v_progress.mechanic_completed_at IS NOT NULL AND v_progress.customer_completed_at IS NOT NULL THEN
    -- Finalize
    UPDATE public.job_progress
    SET finalized_at = NOW(), updated_at = NOW()
    WHERE contract_id = p_contract_id;
    
    -- Mark contract completed (payment capture happens via Stripe webhook)
    UPDATE public.job_contracts
    SET status = 'completed', updated_at = NOW()
    WHERE id = p_contract_id;
    
    -- Update job status
    UPDATE public.jobs
    SET status = 'completed', updated_at = NOW()
    WHERE id = v_contract.job_id;
    
    -- Create payout record (pending until Stripe processes)
    INSERT INTO public.payouts (
      contract_id,
      mechanic_id,
      gross_amount_cents,
      commission_cents,
      net_amount_cents,
      status
    ) VALUES (
      p_contract_id,
      v_contract.mechanic_id,
      v_contract.subtotal_cents,
      v_contract.mechanic_commission_cents,
      v_contract.mechanic_payout_cents,
      'pending'
    );
    
    -- Log finalization
    INSERT INTO public.job_events (
      job_id, contract_id, event_type, actor_id, actor_role,
      title, description, amount_cents
    ) VALUES (
      v_contract.job_id, p_contract_id, 'job_finalized', p_actor_id, p_actor_role,
      'Job completed',
      'Both parties confirmed completion. Payment will be captured.',
      v_contract.total_customer_cents
    );
    
    RETURN TRUE;
  END IF;
  
  -- Log partial completion
  INSERT INTO public.job_events (
    job_id, contract_id, event_type, actor_id, actor_role,
    title, description
  ) VALUES (
    v_contract.job_id, p_contract_id, 
    CASE WHEN p_actor_role = 'mechanic' THEN 'work_completed_mechanic' ELSE 'work_completed_customer' END,
    p_actor_id, p_actor_role,
    CASE WHEN p_actor_role = 'mechanic' THEN 'Mechanic marked complete' ELSE 'Customer confirmed completion' END,
    'Waiting for other party to confirm'
  );
  
  RETURN FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.finalize_job_completion(UUID, UUID, user_role) TO authenticated;

-- =====================================================
-- 10. DATA FIX: Convert any 'rejected' quotes to 'declined'
-- =====================================================
-- Safe no-op if no invalid data exists

DO $$
BEGIN
  -- This will fail silently if 'rejected' doesn't exist in enum
  -- which is expected - we're just being defensive
  UPDATE public.quotes
  SET status = 'declined'
  WHERE status::text = 'rejected';
EXCEPTION WHEN invalid_text_representation THEN
  -- 'rejected' is not a valid enum value, nothing to fix
  NULL;
END $$;

COMMIT;

-- =====================================================
-- CUSTOMER-FACING COPY (for UI implementation)
-- =====================================================
/*
QUOTE ACCEPTANCE SCREEN:
------------------------
Title: "Confirm Your Booking"

Body:
"By accepting this quote, you're authorizing a hold on your payment method.

 Your card will be AUTHORIZED, not charged
 The actual charge only happens after the job is completed
 You must approve any additional work before it affects your total
 You can cancel before the mechanic departs for a full refund

Authorization Amount: $[total_customer_cents / 100]
  - Service: $[subtotal_cents / 100]
  - Platform Fee: $[platform_fee_cents / 100]"

Button: "Authorize & Book"


PAYMENT AUTHORIZATION CONFIRMATION:
-----------------------------------
Title: "Booking Confirmed!"

Body:
"Your card has been authorized for $[amount].

What happens next:
1. Your mechanic will depart to your location
2. They'll complete the agreed work
3. You'll confirm the job is done
4. Only then will your card be charged

You're in control:
 Any additional work requires your approval
 You can message your mechanic anytime
 Cancel before departure for a full refund"


FINAL PAYMENT CAPTURE NOTIFICATION:
-----------------------------------
Title: "Payment Complete"

Body:
"Your job is complete! Here's your receipt:

Service Total: $[subtotal_cents / 100]
Platform Fee: $[platform_fee_cents / 100]

Total Charged: $[total_customer_cents / 100]

Thank you for using WrenchGo!"


ADDITIONAL WORK APPROVAL:
-------------------------
Title: "Additional Work Requested"

Body:
"[Mechanic Name] has identified additional work:

[item_description]
Cost: $[item_total_cents / 100]

This will increase your total from $[current_total] to $[new_total].

You can approve or decline this work. Declining won't affect your original service."

Buttons: "Approve" | "Decline"
*/
\n-- ===================================================================
-- END: 0024_job_lifecycle_hardening.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0025_fix_rating_column_references.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0025: FIX RATING COLUMN REFERENCES
-- =====================================================
-- Purpose: Fix functions that reference 'rating' instead of 'overall_rating'
-- =====================================================

BEGIN;

-- =====================================================
-- FIX: submit_review function
-- =====================================================
CREATE OR REPLACE FUNCTION public.submit_review(
  p_job_id uuid,
  p_reviewer_id uuid,
  p_reviewee_id uuid,
  p_rating int,
  p_comment text DEFAULT NULL,
  p_professionalism_rating int DEFAULT NULL,
  p_communication_rating int DEFAULT NULL,
  p_would_recommend boolean DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_review_id uuid;
  v_blind_deadline timestamptz;
  v_other_review_exists boolean;
  v_should_publish boolean := false;
  v_job_finalized_at timestamptz;
BEGIN
  -- Get job finalized timestamp
  SELECT jp.finalized_at INTO v_job_finalized_at
  FROM public.job_progress jp
  WHERE jp.job_id = p_job_id;
  
  IF v_job_finalized_at IS NULL THEN
    RAISE EXCEPTION 'Job not finalized yet';
  END IF;
  
  -- Set blind deadline to 7 days after job finalization
  v_blind_deadline := v_job_finalized_at + interval '7 days';
  
  -- Check if other party has already reviewed
  SELECT EXISTS(
    SELECT 1 FROM public.reviews
    WHERE job_id = p_job_id
      AND reviewer_id = p_reviewee_id
      AND reviewee_id = p_reviewer_id
  ) INTO v_other_review_exists;
  
  -- If both reviews exist, publish both immediately
  v_should_publish := v_other_review_exists;
  
  -- Insert or update review (using overall_rating column)
  INSERT INTO public.reviews (
    job_id,
    reviewer_id,
    reviewee_id,
    overall_rating,
    comment,
    professionalism_rating,
    communication_rating,
    would_recommend,
    visibility,
    blind_deadline,
    created_at,
    updated_at
  ) VALUES (
    p_job_id,
    p_reviewer_id,
    p_reviewee_id,
    p_rating,
    p_comment,
    p_professionalism_rating,
    p_communication_rating,
    p_would_recommend,
    CASE WHEN v_should_publish THEN 'visible'::review_visibility ELSE 'hidden'::review_visibility END,
    v_blind_deadline,
    now(),
    now()
  )
  ON CONFLICT (job_id, reviewer_id) 
  DO UPDATE SET
    overall_rating = EXCLUDED.overall_rating,
    comment = EXCLUDED.comment,
    professionalism_rating = EXCLUDED.professionalism_rating,
    communication_rating = EXCLUDED.communication_rating,
    would_recommend = EXCLUDED.would_recommend,
    updated_at = now()
  RETURNING id INTO v_review_id;
  
  -- If both reviews exist, publish both
  IF v_should_publish THEN
    UPDATE public.reviews
    SET 
      visibility = 'visible',
      made_visible_at = now(),
      visibility_reason = 'both_submitted'
    WHERE job_id = p_job_id
      AND visibility = 'hidden';
  END IF;
  
  -- Mark prompt as completed
  UPDATE public.review_prompts
  SET completed_at = now()
  WHERE job_id = p_job_id
    AND user_id = p_reviewer_id;
  
  RETURN jsonb_build_object(
    'review_id', v_review_id,
    'published', v_should_publish,
    'blind_deadline', v_blind_deadline
  );
END;
$$;

-- =====================================================
-- FIX: calculate_trust_score function
-- =====================================================
CREATE OR REPLACE FUNCTION public.calculate_trust_score(p_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_role text;
  v_rating_score int := 50;
  v_completion_score int := 100;
  v_reliability_score int := 50;
  v_badge_score int := 0;
  v_tenure_score int := 0;
  v_overall_score int;
  
  v_total_jobs int := 0;
  v_completed_jobs int := 0;
  v_cancelled_jobs int := 0;
  v_disputed_jobs int := 0;
  v_no_show_count int := 0;
  
  v_reviews_given int := 0;
  v_reviews_received int := 0;
  v_avg_rating_given numeric;
  v_avg_rating_received numeric;

  v_account_age_days int;
  v_completion_rate numeric;
  v_on_time_rate numeric;
BEGIN
  -- Get user role
  SELECT role INTO v_user_role
  FROM public.profiles
  WHERE id = p_user_id;

  -- Calculate job stats
  IF v_user_role = 'mechanic' THEN
    SELECT
      COUNT(*) FILTER (WHERE jc.status IN ('active', 'completed')) as total,
      COUNT(*) FILTER (WHERE jc.status = 'completed') as completed,
      COUNT(*) FILTER (WHERE jc.status = 'cancelled') as cancelled,
      COUNT(*) FILTER (WHERE jc.status = 'disputed') as disputed
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs, v_disputed_jobs
    FROM public.job_contracts jc
    WHERE jc.mechanic_id = p_user_id;
  ELSE
    SELECT
      COUNT(*) FILTER (WHERE j.status IN ('in_progress', 'work_in_progress', 'completed')) as total,
      COUNT(*) FILTER (WHERE j.status = 'completed') as completed,
      COUNT(*) FILTER (WHERE j.status = 'cancelled') as cancelled
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs
    FROM public.jobs j
    WHERE j.customer_id = p_user_id;
  END IF;
  
  -- Calculate review stats (using overall_rating column)
  SELECT
    COUNT(*) FILTER (WHERE reviewer_id = p_user_id) as given,
    COUNT(*) FILTER (WHERE reviewee_id = p_user_id) as received,
    AVG(overall_rating) FILTER (WHERE reviewer_id = p_user_id) as avg_given,
    AVG(overall_rating) FILTER (WHERE reviewee_id = p_user_id) as avg_received
  INTO v_reviews_given, v_reviews_received, v_avg_rating_given, v_avg_rating_received
  FROM public.reviews
  WHERE (reviewer_id = p_user_id OR reviewee_id = p_user_id)
    AND visibility = 'visible';
  
  -- Calculate rating score (0-100)
  IF v_reviews_received > 0 THEN
    v_rating_score := LEAST(100, GREATEST(0, 
      ((v_avg_rating_received - 1) / 4.0 * 100)::int
    ));
  END IF;
  
  -- Calculate completion score (0-100)
  IF v_total_jobs > 0 THEN
    v_completion_rate := v_completed_jobs::numeric / v_total_jobs;
    v_completion_score := LEAST(100, (v_completion_rate * 100)::int);
  END IF;
  
  -- Calculate reliability score (0-100)
  IF v_user_role = 'mechanic' THEN
    SELECT
      COUNT(*) FILTER (WHERE jp.customer_confirmed_arrival_at IS NOT NULL) as confirmed,
      COUNT(*) as total
    INTO v_on_time_rate, v_total_jobs
    FROM public.job_progress jp
    JOIN public.job_contracts jc ON jc.job_id = jp.job_id
    WHERE jc.mechanic_id = p_user_id;
    
    IF v_total_jobs > 0 THEN
      v_on_time_rate := v_on_time_rate::numeric / v_total_jobs;
      v_reliability_score := LEAST(100, (v_on_time_rate * 100)::int);
    END IF;
  ELSE
    v_reliability_score := 50;
  END IF;
  
  -- Calculate badge score (0-100)
  SELECT COALESCE(SUM(
    CASE b.tier
      WHEN 1 THEN 5
      WHEN 2 THEN 10
      WHEN 3 THEN 20
      ELSE 0
    END
  ), 0)::int
  INTO v_badge_score
  FROM public.user_badges ub
  JOIN public.badges b ON b.id = ub.badge_id
  WHERE ub.user_id = p_user_id
    AND ub.revoked_at IS NULL
    AND b.is_active = true;
  
  v_badge_score := LEAST(100, v_badge_score);
  
  -- Calculate tenure score (0-100)
  SELECT EXTRACT(DAY FROM now() - created_at)::int
  INTO v_account_age_days
  FROM public.profiles
  WHERE id = p_user_id;
  
  v_tenure_score := LEAST(100, (v_account_age_days / 365.0 * 100)::int);
  
  -- Calculate overall score (weighted average)
  v_overall_score := (
    v_rating_score * 0.35 +
    v_completion_score * 0.25 +
    v_reliability_score * 0.20 +
    v_badge_score * 0.10 +
    v_tenure_score * 0.10
  )::int;
  
  -- Upsert trust score
  INSERT INTO public.trust_scores (
    user_id,
    overall_score,
    rating_score,
    completion_score,
    reliability_score,
    badge_score,
    tenure_score,
    total_jobs,
    completed_jobs,
    cancelled_jobs,
    disputed_jobs,
    no_show_count,
    reviews_given,
    reviews_received,
    avg_rating_given,
    avg_rating_received,
    last_calculated_at,
    updated_at
  ) VALUES (
    p_user_id,
    v_overall_score,
    v_rating_score,
    v_completion_score,
    v_reliability_score,
    v_badge_score,
    v_tenure_score,
    v_total_jobs,
    v_completed_jobs,
    v_cancelled_jobs,
    v_disputed_jobs,
    v_no_show_count,
    v_reviews_given,
    v_reviews_received,
    v_avg_rating_given,
    v_avg_rating_received,
    now(),
    now()
  )
  ON CONFLICT (user_id) DO UPDATE SET
    overall_score = EXCLUDED.overall_score,
    rating_score = EXCLUDED.rating_score,
    completion_score = EXCLUDED.completion_score,
    reliability_score = EXCLUDED.reliability_score,
    badge_score = EXCLUDED.badge_score,
    tenure_score = EXCLUDED.tenure_score,
    total_jobs = EXCLUDED.total_jobs,
    completed_jobs = EXCLUDED.completed_jobs,
    cancelled_jobs = EXCLUDED.cancelled_jobs,
    disputed_jobs = EXCLUDED.disputed_jobs,
    no_show_count = EXCLUDED.no_show_count,
    reviews_given = EXCLUDED.reviews_given,
    reviews_received = EXCLUDED.reviews_received,
    avg_rating_given = EXCLUDED.avg_rating_given,
    avg_rating_received = EXCLUDED.avg_rating_received,
    last_calculated_at = now(),
    updated_at = now();
  
  -- Add to history
  INSERT INTO public.trust_score_history (
    user_id,
    overall_score,
    rating_score,
    completion_score,
    reliability_score,
    badge_score,
    tenure_score,
    snapshot_reason
  ) VALUES (
    p_user_id,
    v_overall_score,
    v_rating_score,
    v_completion_score,
    v_reliability_score,
    v_badge_score,
    v_tenure_score,
    'manual_calculation'
  );
  
  RETURN jsonb_build_object(
    'overall_score', v_overall_score,
    'rating_score', v_rating_score,
    'completion_score', v_completion_score,
    'reliability_score', v_reliability_score,
    'badge_score', v_badge_score,
    'tenure_score', v_tenure_score
  );
END;
$$;

-- =====================================================
-- FIX: evaluate_and_award_badges function
-- =====================================================
CREATE OR REPLACE FUNCTION public.evaluate_and_award_badges(
  p_user_id uuid,
  p_trigger_reason text DEFAULT 'manual',
  p_job_id uuid DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_badge_record RECORD;
  v_user_role text;
  v_meets_criteria boolean;
  v_current_value numeric;
  v_badges_awarded int := 0;
  v_badges_revoked int := 0;
  v_has_badge boolean;
  v_review_count int;
BEGIN
  -- Get user role
  SELECT role INTO v_user_role
  FROM public.profiles
  WHERE id = p_user_id;
  
  -- Loop through all active badges
  FOR v_badge_record IN
    SELECT * FROM public.badges
    WHERE is_active = true
    ORDER BY display_priority ASC
  LOOP
    v_meets_criteria := false;
    v_current_value := 0;
    
    -- Evaluate criteria based on type
    CASE v_badge_record.criteria_type
      
      -- Jobs completed milestone
      WHEN 'jobs_completed' THEN
        IF v_user_role = 'mechanic' THEN
          SELECT COUNT(*)
          INTO v_current_value
          FROM public.job_contracts
          WHERE mechanic_id = p_user_id
            AND status = 'completed';
          
          v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
        END IF;
      
      -- Average rating (using overall_rating column)
      WHEN 'avg_rating' THEN
        SELECT COUNT(*)
        INTO v_review_count
        FROM public.reviews
        WHERE reviewee_id = p_user_id
          AND visibility = 'visible';
        
        -- Require minimum 5 reviews for rating badges
        IF v_review_count >= 5 THEN
          SELECT AVG(overall_rating)
          INTO v_current_value
          FROM public.reviews
          WHERE reviewee_id = p_user_id
            AND visibility = 'visible';
          
          v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
        END IF;
      
      -- Recommend rate
      WHEN 'recommend_rate' THEN
        WITH recommend_stats AS (
          SELECT
            COUNT(*) FILTER (WHERE would_recommend = true) as recommend_count,
            COUNT(*) as total_count
          FROM public.reviews
          WHERE reviewee_id = p_user_id
            AND visibility = 'visible'
            AND would_recommend IS NOT NULL
        )
        SELECT
          CASE WHEN total_count > 0 
            THEN (recommend_count::numeric / total_count * 100)
            ELSE 0
          END
        INTO v_current_value
        FROM recommend_stats;
        
        v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
      
      -- On-time arrival rate
      WHEN 'on_time_rate' THEN
        IF v_user_role = 'mechanic' THEN
          WITH on_time_stats AS (
            SELECT
              COUNT(*) FILTER (WHERE jp.customer_confirmed_arrival_at IS NOT NULL) as on_time_count,
              COUNT(*) as total_count
            FROM public.job_progress jp
            JOIN public.job_contracts jc ON jc.job_id = jp.job_id
            WHERE jc.mechanic_id = p_user_id
              AND jc.status IN ('active', 'completed')
          )
          SELECT
            CASE WHEN total_count > 0
              THEN (on_time_count::numeric / total_count * 100)
              ELSE 0
            END
          INTO v_current_value
          FROM on_time_stats;

          v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
        END IF;

      -- Completion rate
      WHEN 'completion_rate' THEN
        IF v_user_role = 'mechanic' THEN
          WITH completion_stats AS (
            SELECT
              COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
              COUNT(*) FILTER (WHERE status IN ('active', 'completed', 'cancelled')) as total_count
            FROM public.job_contracts
            WHERE mechanic_id = p_user_id
          )
          SELECT
            CASE WHEN total_count > 0
              THEN (completed_count::numeric / total_count * 100)
              ELSE 0
            END
          INTO v_current_value
          FROM completion_stats;

          v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
        END IF;
      
      -- Response time (average minutes to quote)
      WHEN 'response_time' THEN
        IF v_user_role = 'mechanic' THEN
          SELECT AVG(EXTRACT(EPOCH FROM (q.created_at - j.created_at)) / 60)
          INTO v_current_value
          FROM public.quotes q
          JOIN public.jobs j ON j.id = q.job_id
          WHERE q.mechanic_id = p_user_id
            AND q.created_at >= now() - interval '30 days';
          
          v_meets_criteria := v_current_value <= v_badge_record.criteria_threshold;
        END IF;
      
      -- Skill jobs (verified jobs for a skill)
      WHEN 'skill_jobs' THEN
        IF v_user_role = 'mechanic' THEN
          SELECT MAX(verified_job_count)
          INTO v_current_value
          FROM public.mechanic_skills
          WHERE mechanic_id = p_user_id;
          
          v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
        END IF;
      
      -- Verified skills count
      WHEN 'verified_skills' THEN
        IF v_user_role = 'mechanic' THEN
          SELECT COUNT(*)
          INTO v_current_value
          FROM public.mechanic_skills
          WHERE mechanic_id = p_user_id
            AND is_verified = true;
          
          v_meets_criteria := v_current_value >= v_badge_record.criteria_threshold;
        END IF;
      
      -- Top percentile (requires additional context)
      WHEN 'top_percentile' THEN
        v_meets_criteria := false;
      
      -- Manual badges (admin-only)
      WHEN 'manual' THEN
        v_meets_criteria := false;
      
      ELSE
        v_meets_criteria := false;
    END CASE;
    
    -- Check if user already has this badge
    SELECT EXISTS(
      SELECT 1 FROM public.user_badges
      WHERE user_id = p_user_id
        AND badge_id = v_badge_record.id
        AND revoked_at IS NULL
    ) INTO v_has_badge;
    
    -- Award or revoke badge
    IF v_meets_criteria AND NOT v_has_badge THEN
      -- Award badge
      INSERT INTO public.user_badges (
        user_id,
        badge_id,
        awarded_at,
        awarded_reason,
        job_id
      ) VALUES (
        p_user_id,
        v_badge_record.id,
        now(),
        p_trigger_reason,
        p_job_id
      )
      ON CONFLICT (user_id, badge_id) 
      DO UPDATE SET
        revoked_at = NULL,
        revoked_reason = NULL,
        awarded_at = now(),
        awarded_reason = p_trigger_reason;
      
      -- Log to history
      INSERT INTO public.badge_history (
        user_id,
        badge_id,
        action,
        reason,
        job_id,
        metadata
      ) VALUES (
        p_user_id,
        v_badge_record.id,
        'awarded',
        p_trigger_reason,
        p_job_id,
        jsonb_build_object('current_value', v_current_value, 'threshold', v_badge_record.criteria_threshold)
      );
      
      v_badges_awarded := v_badges_awarded + 1;
      
    ELSIF NOT v_meets_criteria AND v_has_badge THEN
      -- Revoke badge
      UPDATE public.user_badges
      SET
        revoked_at = now(),
        revoked_reason = 'criteria_no_longer_met'
      WHERE user_id = p_user_id
        AND badge_id = v_badge_record.id
        AND revoked_at IS NULL;
      
      -- Log to history
      INSERT INTO public.badge_history (
        user_id,
        badge_id,
        action,
        reason,
        metadata
      ) VALUES (
        p_user_id,
        v_badge_record.id,
        'revoked',
        'criteria_no_longer_met',
        jsonb_build_object('current_value', v_current_value, 'threshold', v_badge_record.criteria_threshold)
      );
      
      v_badges_revoked := v_badges_revoked + 1;
    END IF;
  END LOOP;
  
  RETURN jsonb_build_object(
    'badges_awarded', v_badges_awarded,
    'badges_revoked', v_badges_revoked
  );
END;
$$;

-- =====================================================
-- FIX: recalculate_trust_score function
-- =====================================================
CREATE OR REPLACE FUNCTION public.recalculate_trust_score(p_user_id uuid)
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_role public.user_role;
  v_rating_score int := 50;
  v_completion_score int := 100;
  v_reliability_score int := 50;
  v_badge_score int := 0;
  v_tenure_score int := 0;
  v_overall_score int;
  
  v_total_jobs int := 0;
  v_completed_jobs int := 0;
  v_cancelled_jobs int := 0;
  v_disputed_jobs int := 0;
  v_reviews_received int := 0;
  v_avg_rating numeric;
  v_badge_count int := 0;
  v_account_age_days int;
BEGIN
  -- Get user role
  SELECT role INTO v_user_role FROM public.profiles WHERE id = p_user_id;

  -- Calculate job stats based on role
  IF v_user_role = 'mechanic' THEN
    SELECT 
      COUNT(*),
      COUNT(*) FILTER (WHERE status = 'completed'),
      COUNT(*) FILTER (WHERE status = 'cancelled'),
      COUNT(*) FILTER (WHERE status = 'disputed')
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs, v_disputed_jobs
    FROM public.jobs
    WHERE accepted_mechanic_id = p_user_id;
  ELSE
    SELECT 
      COUNT(*),
      COUNT(*) FILTER (WHERE status = 'completed'),
      COUNT(*) FILTER (WHERE status = 'cancelled'),
      COUNT(*) FILTER (WHERE status = 'disputed')
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs, v_disputed_jobs
    FROM public.jobs
    WHERE customer_id = p_user_id;
  END IF;

  -- Calculate rating score (0-100) using overall_rating column
  SELECT COUNT(*), AVG(overall_rating)
  INTO v_reviews_received, v_avg_rating
  FROM public.reviews
  WHERE reviewee_id = p_user_id
    AND visibility = 'visible'
    AND is_hidden = false;

  IF v_reviews_received > 0 AND v_avg_rating IS NOT NULL THEN
    -- Convert 1-5 rating to 0-100 score
    v_rating_score := LEAST(100, GREATEST(0, ((v_avg_rating - 1) / 4.0 * 100)::int));
  END IF;

  -- Calculate completion score
  IF v_total_jobs > 0 THEN
    v_completion_score := LEAST(100, GREATEST(0, (v_completed_jobs::numeric / v_total_jobs * 100)::int));
  END IF;

  -- Calculate reliability score (penalize cancellations and disputes)
  IF v_total_jobs > 0 THEN
    v_reliability_score := LEAST(100, GREATEST(0, 
      100 - (v_cancelled_jobs * 10) - (v_disputed_jobs * 20)
    ));
  END IF;

  -- Calculate badge score (up to 20 points)
  SELECT COUNT(*) INTO v_badge_count
  FROM public.user_badges
  WHERE user_id = p_user_id
    AND revoked_at IS NULL
    AND (expires_at IS NULL OR expires_at > now());
  
  v_badge_score := LEAST(20, v_badge_count * 4);

  -- Calculate tenure score (up to 10 points, 1 point per month, max 10 months)
  SELECT EXTRACT(DAY FROM (now() - created_at))::int
  INTO v_account_age_days
  FROM public.profiles
  WHERE id = p_user_id;

  v_tenure_score := LEAST(10, (v_account_age_days / 30));

  -- Calculate overall score (weighted average)
  v_overall_score := (
    (v_rating_score * 0.40) +
    (v_completion_score * 0.25) +
    (v_reliability_score * 0.20) +
    (v_badge_score * 0.50) +
    (v_tenure_score * 0.50)
  )::int;

  -- Ensure within bounds
  v_overall_score := LEAST(100, GREATEST(0, v_overall_score));

  -- Upsert trust score
  INSERT INTO public.trust_scores (
    user_id,
    overall_score,
    rating_score,
    completion_score,
    reliability_score,
    badge_score,
    tenure_score,
    total_jobs,
    completed_jobs,
    cancelled_jobs,
    disputed_jobs,
    reviews_received,
    avg_rating_received,
    last_calculated_at
  ) VALUES (
    p_user_id,
    v_overall_score,
    v_rating_score,
    v_completion_score,
    v_reliability_score,
    v_badge_score,
    v_tenure_score,
    v_total_jobs,
    v_completed_jobs,
    v_cancelled_jobs,
    v_disputed_jobs,
    v_reviews_received,
    v_avg_rating,
    now()
  )
  ON CONFLICT (user_id) DO UPDATE SET
    overall_score = EXCLUDED.overall_score,
    rating_score = EXCLUDED.rating_score,
    completion_score = EXCLUDED.completion_score,
    reliability_score = EXCLUDED.reliability_score,
    badge_score = EXCLUDED.badge_score,
    tenure_score = EXCLUDED.tenure_score,
    total_jobs = EXCLUDED.total_jobs,
    completed_jobs = EXCLUDED.completed_jobs,
    cancelled_jobs = EXCLUDED.cancelled_jobs,
    disputed_jobs = EXCLUDED.disputed_jobs,
    reviews_received = EXCLUDED.reviews_received,
    avg_rating_received = EXCLUDED.avg_rating_received,
    last_calculated_at = now(),
    updated_at = now();

  -- Add to history
  INSERT INTO public.trust_score_history (
    user_id,
    overall_score,
    rating_score,
    completion_score,
    reliability_score,
    badge_score,
    tenure_score,
    snapshot_reason
  ) VALUES (
    p_user_id,
    v_overall_score,
    v_rating_score,
    v_completion_score,
    v_reliability_score,
    v_badge_score,
    v_tenure_score,
    'recalculation'
  );

  RETURN v_overall_score;
END;
$$;

COMMIT;
\n-- ===================================================================
-- END: 0025_fix_rating_column_references.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0026_earnings_rpcs.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0026: EARNINGS & TAXES RPCs
-- =====================================================
-- Purpose: RPCs for mechanic earnings dashboard
-- Timezone: All boundaries use America/Chicago
-- =====================================================

BEGIN;

-- =====================================================
-- INDEXES for performance
-- =====================================================

CREATE INDEX IF NOT EXISTS idx_payouts_mechanic_processed 
  ON public.payouts (mechanic_id, processed_at);

CREATE INDEX IF NOT EXISTS idx_payouts_mechanic_status 
  ON public.payouts (mechanic_id, status);

CREATE INDEX IF NOT EXISTS idx_payouts_status_processed 
  ON public.payouts (status, processed_at);

-- =====================================================
-- RPC 1: get_mechanic_earnings_summary
-- =====================================================
-- Returns aggregated earnings for a date range

CREATE OR REPLACE FUNCTION public.get_mechanic_earnings_summary(
  p_mechanic_id uuid,
  p_start timestamptz,
  p_end timestamptz
)
RETURNS TABLE (
  net_completed_cents bigint,
  gross_completed_cents bigint,
  commission_completed_cents bigint,
  adjustments_completed_cents bigint,
  net_pending_cents bigint,
  count_completed bigint,
  avg_net_completed_cents bigint,
  take_rate_bps int
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_net_completed bigint;
  v_gross_completed bigint;
  v_commission_completed bigint;
  v_adjustments_completed bigint;
  v_net_pending bigint;
  v_count_completed bigint;
  v_avg_net bigint;
  v_take_rate int;
BEGIN
  -- Completed payouts in range
  SELECT 
    COALESCE(SUM(net_amount_cents), 0),
    COALESCE(SUM(gross_amount_cents), 0),
    COALESCE(SUM(commission_cents), 0),
    COALESCE(SUM(adjustments_cents), 0),
    COUNT(*)
  INTO 
    v_net_completed,
    v_gross_completed,
    v_commission_completed,
    v_adjustments_completed,
    v_count_completed
  FROM payouts
  WHERE mechanic_id = p_mechanic_id
    AND status = 'completed'
    AND processed_at >= p_start
    AND processed_at < p_end;

  -- Pending payouts (all time for this mechanic)
  SELECT COALESCE(SUM(net_amount_cents), 0)
  INTO v_net_pending
  FROM payouts
  WHERE mechanic_id = p_mechanic_id
    AND status IN ('pending', 'processing', 'held');

  -- Calculate averages and rates
  IF v_count_completed > 0 THEN
    v_avg_net := v_net_completed / v_count_completed;
  ELSE
    v_avg_net := 0;
  END IF;

  IF v_gross_completed > 0 THEN
    v_take_rate := ((v_net_completed::numeric / v_gross_completed::numeric) * 10000)::int;
  ELSE
    v_take_rate := 0;
  END IF;

  RETURN QUERY SELECT 
    v_net_completed,
    v_gross_completed,
    v_commission_completed,
    v_adjustments_completed,
    v_net_pending,
    v_count_completed,
    v_avg_net,
    v_take_rate;
END;
$$;

COMMENT ON FUNCTION public.get_mechanic_earnings_summary IS 'Get aggregated earnings summary for a mechanic within a date range';

-- =====================================================
-- RPC 2: get_mechanic_payouts
-- =====================================================
-- Returns paginated payout list with job/customer details

CREATE OR REPLACE FUNCTION public.get_mechanic_payouts(
  p_mechanic_id uuid,
  p_start timestamptz,
  p_end timestamptz,
  p_limit int DEFAULT 20,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  payout_id uuid,
  contract_id uuid,
  status text,
  gross_amount_cents int,
  commission_cents int,
  adjustments_cents int,
  net_amount_cents int,
  scheduled_for timestamptz,
  processed_at timestamptz,
  failed_at timestamptz,
  held_at timestamptz,
  failure_reason text,
  hold_reason text,
  job_id uuid,
  job_title text,
  customer_id uuid,
  customer_name text,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.id as payout_id,
    p.contract_id,
    p.status::text,
    p.gross_amount_cents,
    p.commission_cents,
    p.adjustments_cents,
    p.net_amount_cents,
    p.scheduled_for,
    p.processed_at,
    p.failed_at,
    p.held_at,
    p.failure_reason,
    p.hold_reason,
    j.id as job_id,
    j.title as job_title,
    j.customer_id,
    COALESCE(pr.display_name, pr.full_name, 'Customer') as customer_name,
    p.created_at
  FROM payouts p
  JOIN job_contracts jc ON jc.id = p.contract_id
  JOIN jobs j ON j.id = jc.job_id
  LEFT JOIN profiles pr ON pr.id = j.customer_id
  WHERE p.mechanic_id = p_mechanic_id
    AND (
      (p.status = 'completed' AND p.processed_at >= p_start AND p.processed_at < p_end)
      OR (p.status IN ('pending', 'processing', 'held', 'failed') AND p.created_at >= p_start AND p.created_at < p_end)
    )
  ORDER BY 
    CASE WHEN p.status IN ('pending', 'processing', 'held') THEN 0 ELSE 1 END,
    COALESCE(p.processed_at, p.created_at) DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

COMMENT ON FUNCTION public.get_mechanic_payouts IS 'Get paginated payout list with job and customer details';

-- =====================================================
-- RPC 3: get_mechanic_tax_year_summary
-- =====================================================
-- Returns yearly tax summary with monthly breakdown

CREATE OR REPLACE FUNCTION public.get_mechanic_tax_year_summary(
  p_mechanic_id uuid,
  p_tax_year int
)
RETURNS TABLE (
  year_net_payouts_cents bigint,
  year_commission_cents bigint,
  year_adjustments_cents bigint,
  year_taxable_estimate_cents bigint,
  monthly_breakdown jsonb
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_year_start timestamptz;
  v_year_end timestamptz;
  v_net bigint;
  v_commission bigint;
  v_adjustments bigint;
  v_monthly jsonb;
BEGIN
  -- Year boundaries in America/Chicago timezone
  v_year_start := (p_tax_year || '-01-01')::date AT TIME ZONE 'America/Chicago';
  v_year_end := ((p_tax_year + 1) || '-01-01')::date AT TIME ZONE 'America/Chicago';

  -- Yearly totals (cash basis - only completed payouts)
  SELECT 
    COALESCE(SUM(net_amount_cents), 0),
    COALESCE(SUM(commission_cents), 0),
    COALESCE(SUM(adjustments_cents), 0)
  INTO v_net, v_commission, v_adjustments
  FROM payouts
  WHERE mechanic_id = p_mechanic_id
    AND status = 'completed'
    AND processed_at >= v_year_start
    AND processed_at < v_year_end;

  -- Monthly breakdown
  SELECT jsonb_agg(
    jsonb_build_object(
      'month', m.month,
      'net_cents', COALESCE(d.net, 0),
      'commission_cents', COALESCE(d.commission, 0),
      'adjustments_cents', COALESCE(d.adjustments, 0)
    ) ORDER BY m.month
  )
  INTO v_monthly
  FROM generate_series(1, 12) AS m(month)
  LEFT JOIN (
    SELECT 
      EXTRACT(MONTH FROM processed_at AT TIME ZONE 'America/Chicago')::int as month,
      SUM(net_amount_cents) as net,
      SUM(commission_cents) as commission,
      SUM(adjustments_cents) as adjustments
    FROM payouts
    WHERE mechanic_id = p_mechanic_id
      AND status = 'completed'
      AND processed_at >= v_year_start
      AND processed_at < v_year_end
    GROUP BY EXTRACT(MONTH FROM processed_at AT TIME ZONE 'America/Chicago')
  ) d ON d.month = m.month;

  RETURN QUERY SELECT 
    v_net,
    v_commission,
    v_adjustments,
    v_net - v_commission - v_adjustments,
    v_monthly;
END;
$$;

COMMENT ON FUNCTION public.get_mechanic_tax_year_summary IS 'Get yearly tax summary with monthly breakdown for a mechanic';

-- =====================================================
-- RPC 4: get_mechanic_available_tax_years
-- =====================================================
-- Returns list of years that have payout data

CREATE OR REPLACE FUNCTION public.get_mechanic_available_tax_years(
  p_mechanic_id uuid
)
RETURNS TABLE (tax_year int)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT DISTINCT EXTRACT(YEAR FROM processed_at AT TIME ZONE 'America/Chicago')::int as tax_year
  FROM payouts
  WHERE mechanic_id = p_mechanic_id
    AND status = 'completed'
    AND processed_at IS NOT NULL
  ORDER BY tax_year DESC;
END;
$$;

COMMENT ON FUNCTION public.get_mechanic_available_tax_years IS 'Get list of tax years with payout data';

COMMIT;
\n-- ===================================================================
-- END: 0026_earnings_rpcs.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0027_invitation_promo_system.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0027: INVITATION PROMO SYSTEM
-- =====================================================
-- Purpose: Implement referral/invitation system with promo credits
-- Awards: Inviter earns credits when invited user completes first paid fee transaction
-- =====================================================

BEGIN;

-- =====================================================
-- ENUM: promo_credit_type
-- =====================================================
DO $$ BEGIN
  CREATE TYPE public.promo_credit_type AS ENUM ('FEELESS', 'FEELESS3');
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- =====================================================
-- TABLE: invite_codes
-- =====================================================
-- Shareable invite codes for users
CREATE TABLE IF NOT EXISTS public.invite_codes (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code text UNIQUE NOT NULL,
  inviter_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at timestamptz DEFAULT now() NOT NULL,
  expires_at timestamptz DEFAULT NULL,
  max_uses int DEFAULT NULL,
  current_uses int DEFAULT 0 NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_invite_codes_inviter ON public.invite_codes(inviter_id);
CREATE INDEX IF NOT EXISTS idx_invite_codes_code ON public.invite_codes(code);

COMMENT ON TABLE public.invite_codes IS 'Shareable invite codes for referral system';

-- =====================================================
-- TABLE: invitations
-- =====================================================
-- Tracks who invited whom (invited_id is unique - can only be invited once)
CREATE TABLE IF NOT EXISTS public.invitations (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  inviter_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  invited_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  inviter_role public.user_role NOT NULL,
  invited_role public.user_role NOT NULL,
  invite_code_id uuid REFERENCES public.invite_codes(id) ON DELETE SET NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  
  CONSTRAINT invitations_no_self_invite CHECK (inviter_id != invited_id),
  CONSTRAINT invitations_invited_unique UNIQUE (invited_id)
);

CREATE INDEX IF NOT EXISTS idx_invitations_inviter ON public.invitations(inviter_id);
CREATE INDEX IF NOT EXISTS idx_invitations_invited ON public.invitations(invited_id);

COMMENT ON TABLE public.invitations IS 'Tracks invitation relationships between users';

-- =====================================================
-- TABLE: promo_credits
-- =====================================================
-- Individual credit buckets for FIFO consumption
CREATE TABLE IF NOT EXISTS public.promo_credits (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  credit_type public.promo_credit_type NOT NULL,
  remaining_uses int NOT NULL CHECK (remaining_uses >= 0),
  source_invited_user_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
  source_invitation_id uuid REFERENCES public.invitations(id) ON DELETE SET NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_promo_credits_user_created ON public.promo_credits(user_id, created_at);
CREATE INDEX IF NOT EXISTS idx_promo_credits_user_remaining ON public.promo_credits(user_id, remaining_uses) WHERE remaining_uses > 0;

COMMENT ON TABLE public.promo_credits IS 'Promo credit buckets for fee discounts (FIFO consumption)';

-- =====================================================
-- TABLE: invitation_awards
-- =====================================================
-- Idempotency + audit for awards (unique on invited_id ensures one award per invited user)
CREATE TABLE IF NOT EXISTS public.invitation_awards (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  inviter_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  invited_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  invitation_id uuid NOT NULL REFERENCES public.invitations(id) ON DELETE CASCADE,
  award_type text NOT NULL CHECK (award_type IN ('FEELESS_1', 'FEELESS_3')),
  stripe_event_id text,
  awarded_at timestamptz DEFAULT now() NOT NULL,

  CONSTRAINT invitation_awards_invited_unique UNIQUE (invited_id)
);

CREATE UNIQUE INDEX IF NOT EXISTS invitation_awards_stripe_event_id_unique
ON public.invitation_awards (stripe_event_id)
WHERE stripe_event_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_invitation_awards_inviter ON public.invitation_awards(inviter_id);
CREATE INDEX IF NOT EXISTS idx_invitation_awards_invited ON public.invitation_awards(invited_id);

COMMENT ON TABLE public.invitation_awards IS 'Audit trail for invitation awards (one per invited user)';

-- =====================================================
-- TABLE: payment_promo_applications
-- =====================================================
-- Immutable record of promo redemption per payment (unique on payment_id)
CREATE TABLE IF NOT EXISTS public.payment_promo_applications (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  payment_id uuid NOT NULL UNIQUE REFERENCES public.payments(id) ON DELETE CASCADE,
  promo_credit_id uuid REFERENCES public.promo_credits(id) ON DELETE SET NULL,
  credit_type public.promo_credit_type NOT NULL,
  fee_before_cents int NOT NULL,
  discount_cents int NOT NULL,
  fee_after_cents int NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  
  CONSTRAINT valid_promo_amounts CHECK (
    fee_before_cents >= 0 AND
    discount_cents >= 0 AND
    fee_after_cents >= 0 AND
    fee_after_cents = fee_before_cents - discount_cents
  )
);

CREATE INDEX IF NOT EXISTS idx_payment_promo_applications_payment ON public.payment_promo_applications(payment_id);
CREATE INDEX IF NOT EXISTS idx_payment_promo_applications_credit ON public.payment_promo_applications(promo_credit_id);

COMMENT ON TABLE public.payment_promo_applications IS 'Immutable record of promo credit redemption per payment';

-- =====================================================
-- TABLE: promotions (for validate-promotion edge function)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.promotions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code text UNIQUE NOT NULL,
  type text NOT NULL CHECK (type IN ('percent_discount', 'fixed_discount', 'waive_platform_fee')),
  description text,
  percent_off numeric CHECK (percent_off IS NULL OR (percent_off > 0 AND percent_off <= 100)),
  amount_cents int CHECK (amount_cents IS NULL OR amount_cents > 0),
  minimum_amount_cents int DEFAULT 0,
  start_date timestamptz NOT NULL DEFAULT now(),
  end_date timestamptz,
  max_redemptions int,
  max_redemptions_per_user int DEFAULT 1,
  current_redemptions int DEFAULT 0,
  active boolean DEFAULT true NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_promotions_code ON public.promotions(code) WHERE active = true;

COMMENT ON TABLE public.promotions IS 'Manual promo codes for validate-promotion edge function';

-- =====================================================
-- TABLE: promotion_redemptions
-- =====================================================
CREATE TABLE IF NOT EXISTS public.promotion_redemptions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  promotion_id uuid NOT NULL REFERENCES public.promotions(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  payment_id uuid REFERENCES public.payments(id) ON DELETE SET NULL,
  created_at timestamptz DEFAULT now() NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_promotion_redemptions_promotion_user ON public.promotion_redemptions(promotion_id, user_id);
CREATE INDEX IF NOT EXISTS idx_promotion_redemptions_user ON public.promotion_redemptions(user_id);

COMMENT ON TABLE public.promotion_redemptions IS 'Tracks manual promo code redemptions';

-- =====================================================
-- RLS POLICIES
-- =====================================================

-- invite_codes
ALTER TABLE public.invite_codes ENABLE ROW LEVEL SECURITY;

CREATE POLICY invite_codes_select ON public.invite_codes
  FOR SELECT USING (inviter_id = auth.uid());

CREATE POLICY invite_codes_insert ON public.invite_codes
  FOR INSERT WITH CHECK (inviter_id = auth.uid());

CREATE POLICY invite_codes_update ON public.invite_codes
  FOR UPDATE USING (inviter_id = auth.uid());

-- invitations
ALTER TABLE public.invitations ENABLE ROW LEVEL SECURITY;

CREATE POLICY invitations_select ON public.invitations
  FOR SELECT USING (inviter_id = auth.uid() OR invited_id = auth.uid());

CREATE POLICY invitations_insert ON public.invitations
  FOR INSERT WITH CHECK (inviter_id = auth.uid());

-- promo_credits (read own, writes via RPC/service role)
ALTER TABLE public.promo_credits ENABLE ROW LEVEL SECURITY;

CREATE POLICY promo_credits_select ON public.promo_credits
  FOR SELECT USING (user_id = auth.uid());

-- invitation_awards (read own)
ALTER TABLE public.invitation_awards ENABLE ROW LEVEL SECURITY;

CREATE POLICY invitation_awards_select ON public.invitation_awards
  FOR SELECT USING (inviter_id = auth.uid() OR invited_id = auth.uid());

-- payment_promo_applications (read via payment ownership)
ALTER TABLE public.payment_promo_applications ENABLE ROW LEVEL SECURITY;

CREATE POLICY payment_promo_applications_select ON public.payment_promo_applications
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.payments p
      WHERE p.id = payment_promo_applications.payment_id
      AND (p.customer_id = auth.uid() OR p.mechanic_id = auth.uid())
    )
  );

-- promotions (public read for active)
ALTER TABLE public.promotions ENABLE ROW LEVEL SECURITY;

CREATE POLICY promotions_select ON public.promotions
  FOR SELECT USING (active = true);

-- promotion_redemptions (read own)
ALTER TABLE public.promotion_redemptions ENABLE ROW LEVEL SECURITY;

CREATE POLICY promotion_redemptions_select ON public.promotion_redemptions
  FOR SELECT USING (user_id = auth.uid());

-- =====================================================
-- FUNCTION: generate_invite_code
-- =====================================================
-- Generates a unique 8-character invite code for a user
CREATE OR REPLACE FUNCTION public.generate_invite_code(p_user_id uuid)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_code text;
  v_exists boolean;
BEGIN
  LOOP
    -- Generate 8-char alphanumeric code
    v_code := upper(substring(md5(random()::text || clock_timestamp()::text) from 1 for 8));
    
    -- Check if exists
    SELECT EXISTS(SELECT 1 FROM invite_codes WHERE code = v_code) INTO v_exists;
    
    EXIT WHEN NOT v_exists;
  END LOOP;
  
  INSERT INTO invite_codes (code, inviter_id)
  VALUES (v_code, p_user_id)
  ON CONFLICT (code) DO NOTHING;
  
  RETURN v_code;
END;
$$;

GRANT EXECUTE ON FUNCTION public.generate_invite_code(uuid) TO authenticated;

-- =====================================================
-- FUNCTION: get_or_create_invite_code
-- =====================================================
-- Gets existing invite code or creates new one for user
CREATE OR REPLACE FUNCTION public.get_or_create_invite_code()
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_code text;
BEGIN
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Try to get existing code
  SELECT code INTO v_code
  FROM invite_codes
  WHERE inviter_id = v_user_id
  ORDER BY created_at DESC
  LIMIT 1;
  
  IF v_code IS NULL THEN
    v_code := generate_invite_code(v_user_id);
  END IF;
  
  RETURN v_code;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_or_create_invite_code() TO authenticated;

-- =====================================================
-- FUNCTION: accept_invitation
-- =====================================================
-- Called when a new user signs up with an invite code
CREATE OR REPLACE FUNCTION public.accept_invitation(p_invite_code text)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_invited_id uuid;
  v_invited_role public.user_role;
  v_inviter_id uuid;
  v_inviter_role public.user_role;
  v_invite_code_id uuid;
  v_already_invited boolean;
BEGIN
  v_invited_id := auth.uid();
  
  IF v_invited_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  
  -- Check if already invited
  SELECT EXISTS(SELECT 1 FROM invitations WHERE invited_id = v_invited_id) INTO v_already_invited;
  IF v_already_invited THEN
    RETURN jsonb_build_object('success', false, 'error', 'Already invited by another user');
  END IF;
  
  -- Get invite code details
  SELECT ic.id, ic.inviter_id INTO v_invite_code_id, v_inviter_id
  FROM invite_codes ic
  WHERE ic.code = upper(p_invite_code)
    AND (ic.expires_at IS NULL OR ic.expires_at > now())
    AND (ic.max_uses IS NULL OR ic.current_uses < ic.max_uses);
  
  IF v_inviter_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid or expired invite code');
  END IF;
  
  -- No self-invites
  IF v_inviter_id = v_invited_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Cannot use your own invite code');
  END IF;
  
  -- Get roles
  SELECT role INTO v_inviter_role FROM profiles WHERE id = v_inviter_id;
  SELECT role INTO v_invited_role FROM profiles WHERE id = v_invited_id;
  
  IF v_inviter_role IS NULL OR v_invited_role IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User profiles not found');
  END IF;
  
  -- Create invitation
  INSERT INTO invitations (inviter_id, invited_id, inviter_role, invited_role, invite_code_id)
  VALUES (v_inviter_id, v_invited_id, v_inviter_role, v_invited_role, v_invite_code_id);
  
  -- Increment invite code usage
  UPDATE invite_codes SET current_uses = current_uses + 1 WHERE id = v_invite_code_id;
  
  RETURN jsonb_build_object('success', true, 'inviter_id', v_inviter_id);
END;
$$;

GRANT EXECUTE ON FUNCTION public.accept_invitation(text) TO authenticated;

-- =====================================================
-- FUNCTION: award_invitation_credits
-- =====================================================
-- Called by webhook when invited user completes first qualifying paid transaction
-- Idempotent: unique constraint on invitation_awards.invited_id prevents double awards
CREATE OR REPLACE FUNCTION public.award_invitation_credits(
  p_invited_id uuid,
  p_payment_id uuid,
  p_stripe_event_id text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_invitation record;
  v_award_type text;
  v_credit_type public.promo_credit_type := 'FEELESS';
  v_credit_uses int;
  v_credit_id uuid;
BEGIN
  -- Get invitation details
  SELECT * INTO v_invitation
  FROM invitations
  WHERE invited_id = p_invited_id;

  IF v_invitation IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'No invitation found for user');
  END IF;

  -- New rules:
  -- Invite CUSTOMER -> 1 FEELESS use
  -- Invite MECHANIC -> 3 FEELESS uses
  IF v_invitation.invited_role = 'customer' THEN
    v_award_type := 'FEELESS_1';
    v_credit_uses := 1;
  ELSIF v_invitation.invited_role = 'mechanic' THEN
    v_award_type := 'FEELESS_3';
    v_credit_uses := 3;
  ELSE
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Invalid invited_role on invitation',
      'invited_role', v_invitation.invited_role
    );
  END IF;

  -- Insert award (idempotent by UNIQUE(invited_id))
  BEGIN
    INSERT INTO invitation_awards (inviter_id, invited_id, award_type, payment_id, stripe_event_id)
    VALUES (v_invitation.inviter_id, p_invited_id, v_award_type, p_payment_id, p_stripe_event_id);
  EXCEPTION WHEN unique_violation THEN
    RETURN jsonb_build_object('success', false, 'error', 'Award already granted for this invited user');
  END;

  -- Create promo credit bucket for inviter
  INSERT INTO promo_credits (user_id, credit_type, remaining_uses, source_invited_user_id, source_invitation_id)
  VALUES (v_invitation.inviter_id, v_credit_type, v_credit_uses, p_invited_id, v_invitation.id)
  RETURNING id INTO v_credit_id;

  RETURN jsonb_build_object(
    'success', true,
    'inviter_id', v_invitation.inviter_id,
    'award_type', v_award_type,
    'credit_id', v_credit_id,
    'credit_uses', v_credit_uses
  );
END;
$$;

REVOKE EXECUTE ON FUNCTION public.award_invitation_credits(uuid, uuid, text) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION public.award_invitation_credits(uuid, uuid, text) FROM authenticated;


-- =====================================================
-- FUNCTION: get_user_promo_credits
-- =====================================================
-- Returns user's available promo credits summary
CREATE OR REPLACE FUNCTION public.get_user_promo_credits()
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_feeless_count int;
  v_feeless3_count int;
BEGIN
  v_user_id := auth.uid();

  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  SELECT COALESCE(SUM(remaining_uses), 0) INTO v_feeless_count
  FROM promo_credits
  WHERE user_id = v_user_id AND credit_type = 'FEELESS' AND remaining_uses > 0;

  SELECT COALESCE(SUM(remaining_uses), 0) INTO v_feeless3_count
  FROM promo_credits
  WHERE user_id = v_user_id AND credit_type = 'FEELESS3' AND remaining_uses > 0;

  RETURN jsonb_build_object(
    'success', true,
    'feeless_credits', v_feeless_count,
    'feeless3_credits', v_feeless3_count,
    'total_credits', v_feeless_count + v_feeless3_count
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_user_promo_credits() TO authenticated;

-- =====================================================
-- FUNCTION: preview_promo_discount
-- =====================================================
-- Preview what discount would apply (read-only, no consumption)
CREATE OR REPLACE FUNCTION public.preview_promo_discount(p_platform_fee_cents int)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_credit record;
  v_discount_cents int;
BEGIN
  v_user_id := auth.uid();

  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  IF p_platform_fee_cents <= 0 THEN
    RETURN jsonb_build_object(
      'success', true,
      'has_discount', false,
      'discount_cents', 0,
      'fee_after_cents', 0,
      'reason', 'No platform fee to discount'
    );
  END IF;

  -- Get oldest available credit, prioritizing FEELESS over FEELESS3
  SELECT * INTO v_credit
  FROM promo_credits
  WHERE user_id = v_user_id AND remaining_uses > 0
  ORDER BY
    CASE credit_type WHEN 'FEELESS' THEN 0 ELSE 1 END,
    created_at ASC
  LIMIT 1
  FOR UPDATE SKIP LOCKED;

  IF v_credit IS NULL THEN
    RETURN jsonb_build_object(
      'success', true,
      'has_discount', false,
      'discount_cents', 0,
      'fee_after_cents', p_platform_fee_cents,
      'reason', 'No promo credits available'
    );
  END IF;

  -- Calculate discount
  IF v_credit.credit_type = 'FEELESS' THEN
    v_discount_cents := p_platform_fee_cents;
  ELSE -- FEELESS3
    v_discount_cents := LEAST(500, p_platform_fee_cents);
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'has_discount', true,
    'credit_type', v_credit.credit_type,
    'discount_cents', v_discount_cents,
    'fee_after_cents', p_platform_fee_cents - v_discount_cents
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.preview_promo_discount(int) TO authenticated;

-- =====================================================
-- FUNCTION: apply_promo_to_payment
-- =====================================================
-- Atomically applies best available promo credit to a payment
-- Must be called within payment finalization flow
CREATE OR REPLACE FUNCTION public.apply_promo_to_payment(
  p_payment_id uuid,
  p_user_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_payment record;
  v_credit record;
  v_fee_before int;
  v_discount_cents int;
  v_fee_after int;
  v_application_id uuid;
BEGIN
  -- Lock payment row
  SELECT * INTO v_payment
  FROM payments
  WHERE id = p_payment_id
  FOR UPDATE;
  
  IF v_payment IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Payment not found');
  END IF;
  
  -- Check if promo already applied
  IF EXISTS(SELECT 1 FROM payment_promo_applications WHERE payment_id = p_payment_id) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Promo already applied to this payment');
  END IF;
  
  v_fee_before := COALESCE(v_payment.platform_fee_cents, 0);
  
  -- If no fee, nothing to discount
  IF v_fee_before <= 0 THEN
    RETURN jsonb_build_object(
      'success', true,
      'applied', false,
      'reason', 'No platform fee to discount'
    );
  END IF;
  
  -- Get oldest available credit for user, prioritizing FEELESS
  SELECT * INTO v_credit
  FROM promo_credits
  WHERE user_id = p_user_id AND remaining_uses > 0
  ORDER BY 
    CASE credit_type WHEN 'FEELESS' THEN 0 ELSE 1 END,
    created_at ASC
  LIMIT 1
  FOR UPDATE;
  
  IF v_credit IS NULL THEN
    RETURN jsonb_build_object(
      'success', true,
      'applied', false,
      'reason', 'No promo credits available'
    );
  END IF;
  
  -- Calculate discount
  IF v_credit.credit_type = 'FEELESS' THEN
    v_discount_cents := v_fee_before;
  ELSE -- FEELESS3
    v_discount_cents := LEAST(500, v_fee_before);
  END IF;
  
  v_fee_after := v_fee_before - v_discount_cents;
  
  -- Decrement credit
  UPDATE promo_credits
  SET remaining_uses = remaining_uses - 1, updated_at = now()
  WHERE id = v_credit.id;
  
  -- Record application (immutable)
  INSERT INTO payment_promo_applications (
    payment_id, promo_credit_id, credit_type, fee_before_cents, discount_cents, fee_after_cents
  )
  VALUES (
    p_payment_id, v_credit.id, v_credit.credit_type, v_fee_before, v_discount_cents, v_fee_after
  )
  RETURNING id INTO v_application_id;
  
  -- Update payment with discount (if payment has a discount column, otherwise store in metadata)
  -- Note: payments table may not have discount_cents column, so we update platform_fee_cents
  UPDATE payments
  SET platform_fee_cents = v_fee_after,
      updated_at = now()
  WHERE id = p_payment_id;
  
  RETURN jsonb_build_object(
    'success', true,
    'applied', true,
    'credit_type', v_credit.credit_type,
    'fee_before_cents', v_fee_before,
    'discount_cents', v_discount_cents,
    'fee_after_cents', v_fee_after,
    'application_id', v_application_id
  );
END;
$$;

-- Only service role should call this (from payment flow)
REVOKE EXECUTE ON FUNCTION public.apply_promo_to_payment(uuid, uuid) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION public.apply_promo_to_payment(uuid, uuid) FROM authenticated;

-- =====================================================
-- FUNCTION: check_first_qualifying_payment
-- =====================================================
-- Checks if a payment is the user's first qualifying paid fee transaction
CREATE OR REPLACE FUNCTION public.check_first_qualifying_payment(
  p_user_id uuid,
  p_payment_id uuid
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_has_prior_paid boolean;
BEGIN
  -- Check if user has any prior succeeded payments with platform_fee_cents > 0
  -- excluding the current payment
  SELECT EXISTS(
    SELECT 1 FROM payments
    WHERE customer_id = p_user_id
      AND status = 'succeeded'
      AND platform_fee_cents > 0
      AND id != p_payment_id
  ) INTO v_has_prior_paid;
  
  RETURN NOT v_has_prior_paid;
END;
$$;

-- Only service role should call this
REVOKE EXECUTE ON FUNCTION public.check_first_qualifying_payment(uuid, uuid) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION public.check_first_qualifying_payment(uuid, uuid) FROM authenticated;

-- =====================================================
-- FUNCTION: get_invitation_status
-- =====================================================
-- Returns user's invitation status (who invited them, if anyone)
CREATE OR REPLACE FUNCTION public.get_invitation_status()
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_invitation record;
  v_inviter_name text;
  v_award_granted boolean;
BEGIN
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  
  SELECT * INTO v_invitation
  FROM invitations
  WHERE invited_id = v_user_id;
  
  IF v_invitation IS NULL THEN
    RETURN jsonb_build_object(
      'success', true,
      'was_invited', false
    );
  END IF;
  
  SELECT COALESCE(display_name, full_name, 'A friend') INTO v_inviter_name
  FROM profiles
  WHERE id = v_invitation.inviter_id;
  
  SELECT EXISTS(SELECT 1 FROM invitation_awards WHERE invited_id = v_user_id) INTO v_award_granted;
  
  RETURN jsonb_build_object(
    'success', true,
    'was_invited', true,
    'inviter_name', v_inviter_name,
    'invited_at', v_invitation.created_at,
    'award_granted_to_inviter', v_award_granted
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_invitation_status() TO authenticated;

-- =====================================================
-- FUNCTION: get_my_invitations
-- =====================================================
-- Returns list of users the current user has invited
CREATE OR REPLACE FUNCTION public.get_my_invitations()
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_invitations jsonb;
BEGIN
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'invited_id', i.invited_id,
      'invited_name', COALESCE(p.display_name, p.full_name, 'User'),
      'invited_role', i.invited_role,
      'invited_at', i.created_at,
      'award_granted', EXISTS(SELECT 1 FROM invitation_awards ia WHERE ia.invited_id = i.invited_id)
    )
    ORDER BY i.created_at DESC
  ), '[]'::jsonb) INTO v_invitations
  FROM invitations i
  JOIN profiles p ON p.id = i.invited_id
  WHERE i.inviter_id = v_user_id;
  
  RETURN jsonb_build_object(
    'success', true,
    'invitations', v_invitations
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_my_invitations() TO authenticated;

-- =====================================================
-- GRANT SERVICE ROLE FULL ACCESS
-- =====================================================
-- Service role needs explicit grants to bypass RLS for these tables
GRANT ALL ON public.promo_credits TO service_role;
GRANT ALL ON public.invite_codes TO service_role;
GRANT ALL ON public.invitations TO service_role;
GRANT ALL ON public.invitation_awards TO service_role;
GRANT ALL ON public.payment_promo_applications TO service_role;
GRANT ALL ON public.promotions TO service_role;
GRANT ALL ON public.promotion_redemptions TO service_role;

COMMIT;\n-- ===================================================================
-- END: 0027_invitation_promo_system.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0028_grant_service_role_promo.sql
-- ===================================================================\n
-- Grant service_role full access to promo tables
GRANT ALL ON public.promo_credits TO service_role;
GRANT ALL ON public.invite_codes TO service_role;
GRANT ALL ON public.invitations TO service_role;
GRANT ALL ON public.invitation_awards TO service_role;
GRANT ALL ON public.payment_promo_applications TO service_role;
GRANT ALL ON public.promotions TO service_role;
GRANT ALL ON public.promotion_redemptions TO service_role;

-- Grant service_role execute on promo RPCs
GRANT EXECUTE ON FUNCTION public.apply_promo_to_payment(uuid, uuid) TO service_role;
GRANT EXECUTE ON FUNCTION public.award_invitation_credits(uuid, uuid, text) TO service_role;
GRANT EXECUTE ON FUNCTION public.check_first_qualifying_payment(uuid, uuid) TO service_role;\n-- ===================================================================
-- END: 0028_grant_service_role_promo.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0029_payment_method_enforcement.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0029: PAYMENT METHOD ENFORCEMENT
-- =====================================================
-- Adds payment_method_status to profiles and creates
-- server-side enforcement for restricted actions
-- =====================================================

BEGIN;

-- =====================================================
-- ENUM: payment_method_status
-- =====================================================
DO $$ BEGIN
  CREATE TYPE public.payment_method_status AS ENUM (
    'none',
    'pending',
    'active',
    'failed'
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- =====================================================
-- ADD payment_method_status TO profiles
-- =====================================================
ALTER TABLE public.profiles 
ADD COLUMN IF NOT EXISTS payment_method_status public.payment_method_status DEFAULT 'none' NOT NULL;

ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS stripe_customer_id text UNIQUE;

-- =====================================================
-- FUNCTION: assert_payment_ready
-- =====================================================
-- Server-side check that user has active payment method
-- Returns error if not ready, otherwise returns success
-- =====================================================
CREATE OR REPLACE FUNCTION public.assert_payment_ready(p_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_status payment_method_status;
BEGIN
  SELECT payment_method_status INTO v_status
  FROM profiles
  WHERE id = p_user_id;

  IF v_status IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'code', 'USER_NOT_FOUND',
      'message', 'User profile not found'
    );
  END IF;

  IF v_status != 'active' THEN
    RETURN jsonb_build_object(
      'success', false,
      'code', 'PAYMENT_METHOD_REQUIRED',
      'message', 'A valid payment method is required to perform this action',
      'current_status', v_status::text
    );
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'code', 'PAYMENT_READY',
    'message', 'Payment method is active'
  );
END;
$$;

-- =====================================================
-- FUNCTION: check_payment_ready (for RLS policies)
-- =====================================================
CREATE OR REPLACE FUNCTION public.check_payment_ready(p_user_id uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_status payment_method_status;
BEGIN
  SELECT payment_method_status INTO v_status
  FROM profiles
  WHERE id = p_user_id;

  RETURN v_status = 'active';
END;
$$;

-- =====================================================
-- FUNCTION: set_payment_method_status
-- =====================================================
-- Called by webhook to update payment status
-- =====================================================
CREATE OR REPLACE FUNCTION public.set_payment_method_status(
  p_user_id uuid,
  p_status text,
  p_stripe_customer_id text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE profiles
  SET 
    payment_method_status = p_status::payment_method_status,
    stripe_customer_id = COALESCE(p_stripe_customer_id, stripe_customer_id),
    updated_at = now()
  WHERE id = p_user_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;

  RETURN jsonb_build_object('success', true, 'status', p_status);
END;
$$;

-- =====================================================
-- GRANTS
-- =====================================================
GRANT EXECUTE ON FUNCTION public.assert_payment_ready(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.assert_payment_ready(uuid) TO service_role;
GRANT EXECUTE ON FUNCTION public.check_payment_ready(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_payment_ready(uuid) TO service_role;
GRANT EXECUTE ON FUNCTION public.set_payment_method_status(uuid, text, text) TO service_role;

COMMIT;\n-- ===================================================================
-- END: 0029_payment_method_enforcement.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0030_payment_rls_enforcement.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0030: PAYMENT METHOD RLS ENFORCEMENT
-- =====================================================
-- Adds RLS policies to enforce payment method requirement
-- for restricted actions (job creation, quote submission)
-- =====================================================

BEGIN;

-- =====================================================
-- RLS POLICY: Jobs - Customers need payment to create
-- =====================================================
DROP POLICY IF EXISTS "jobs_insert_customer_with_payment" ON public.jobs;
CREATE POLICY "jobs_insert_customer_with_payment" ON public.jobs
  FOR INSERT
  WITH CHECK (
    auth.uid() = customer_id
    AND EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid()
      AND payment_method_status = 'active'
    )
  );

-- Drop old insert policy if exists
DROP POLICY IF EXISTS "jobs_insert_customer" ON public.jobs;
DROP POLICY IF EXISTS "Customers can insert their own jobs" ON public.jobs;

-- =====================================================
-- RLS POLICY: Quotes - Mechanics need payment to submit
-- =====================================================
DROP POLICY IF EXISTS "quotes_insert_mechanic_with_payment" ON public.quotes;
CREATE POLICY "quotes_insert_mechanic_with_payment" ON public.quotes
  FOR INSERT
  WITH CHECK (
    auth.uid() = mechanic_id
    AND EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid()
      AND payment_method_status = 'active'
    )
  );

-- Drop old insert policy if exists
DROP POLICY IF EXISTS "quotes_insert_mechanic" ON public.quotes;
DROP POLICY IF EXISTS "Mechanics can insert quotes" ON public.quotes;

-- =====================================================
-- RPC: submit_quote_with_payment_check
-- =====================================================
-- Server-side quote submission with payment enforcement
-- =====================================================
CREATE OR REPLACE FUNCTION public.submit_quote_with_payment_check(
  p_job_id uuid,
  p_price_cents int,
  p_estimated_hours numeric DEFAULT NULL,
  p_notes text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic_id uuid;
  v_payment_status payment_method_status;
  v_quote_id uuid;
BEGIN
  v_mechanic_id := auth.uid();
  
  IF v_mechanic_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'code', 'NOT_AUTHENTICATED');
  END IF;

  SELECT payment_method_status INTO v_payment_status
  FROM profiles WHERE id = v_mechanic_id;

  IF v_payment_status IS NULL OR v_payment_status != 'active' THEN
    RETURN jsonb_build_object(
      'success', false,
      'code', 'PAYMENT_METHOD_REQUIRED',
      'message', 'A valid payment method is required to submit quotes'
    );
  END IF;

  INSERT INTO quotes (job_id, mechanic_id, price_cents, estimated_hours, notes, status)
  VALUES (p_job_id, v_mechanic_id, p_price_cents, p_estimated_hours, p_notes, 'pending')
  RETURNING id INTO v_quote_id;

  RETURN jsonb_build_object('success', true, 'quote_id', v_quote_id);
END;
$$;

-- =====================================================
-- RPC: create_job_with_payment_check
-- =====================================================
-- Server-side job creation with payment enforcement
-- =====================================================
CREATE OR REPLACE FUNCTION public.create_job_with_payment_check(
  p_title text,
  p_description text DEFAULT NULL,
  p_location_address text DEFAULT NULL,
  p_location_lat double precision DEFAULT NULL,
  p_location_lng double precision DEFAULT NULL,
  p_vehicle_id uuid DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_customer_id uuid;
  v_payment_status payment_method_status;
  v_job_id uuid;
BEGIN
  v_customer_id := auth.uid();
  
  IF v_customer_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'code', 'NOT_AUTHENTICATED');
  END IF;

  SELECT payment_method_status INTO v_payment_status
  FROM profiles WHERE id = v_customer_id;

  IF v_payment_status IS NULL OR v_payment_status != 'active' THEN
    RETURN jsonb_build_object(
      'success', false,
      'code', 'PAYMENT_METHOD_REQUIRED',
      'message', 'A valid payment method is required to request service'
    );
  END IF;

  INSERT INTO jobs (customer_id, title, description, location_address, location_lat, location_lng, vehicle_id, status)
  VALUES (v_customer_id, p_title, p_description, p_location_address, p_location_lat, p_location_lng, p_vehicle_id, 'searching')
  RETURNING id INTO v_job_id;

  RETURN jsonb_build_object('success', true, 'job_id', v_job_id);
END;
$$;

-- =====================================================
-- GRANTS
-- =====================================================
GRANT EXECUTE ON FUNCTION public.submit_quote_with_payment_check(uuid, int, numeric, text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.create_job_with_payment_check(text, text, text, double precision, double precision, uuid) TO authenticated;

COMMIT;\n-- ===================================================================
-- END: 0030_payment_rls_enforcement.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0031_service_area_enforcement.sql
-- ===================================================================\n
-- MIGRATION 0031: SERVICE AREA ENFORCEMENT
-- Launch Hub: 60453 (Oak Lawn, IL) - 100 mile radius
-- Ring-based expansion with liquidity controls

-- 1. Enable PostGIS and set search path
CREATE EXTENSION IF NOT EXISTS postgis WITH SCHEMA extensions;
SET search_path TO public, extensions;

-- 2. ZIP codes lookup table
CREATE TABLE IF NOT EXISTS zip_codes (
  zip VARCHAR(10) PRIMARY KEY,
  lat DECIMAL(9,6) NOT NULL,
  lng DECIMAL(9,6) NOT NULL,
  city VARCHAR(100),
  state VARCHAR(2),
  location GEOGRAPHY(POINT, 4326) GENERATED ALWAYS AS (
    ST_SetSRID(ST_MakePoint(lng, lat), 4326)::extensions.geography
  ) STORED
);

CREATE INDEX IF NOT EXISTS idx_zip_location ON zip_codes USING GIST(location);

-- 3. Service hubs with ring-based expansion
CREATE TABLE IF NOT EXISTS service_hubs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  slug VARCHAR(50) UNIQUE NOT NULL,
  zip VARCHAR(10) NOT NULL,
  lat DECIMAL(9,6) NOT NULL,
  lng DECIMAL(9,6) NOT NULL,
  max_radius_miles INTEGER DEFAULT 100 CHECK (max_radius_miles <= 250),
  active_radius_miles INTEGER DEFAULT 25, -- Start with Ring 0 only
  is_active BOOLEAN DEFAULT true,
  invite_only BOOLEAN DEFAULT true, -- Soft launch gate
  auto_expand_enabled BOOLEAN DEFAULT false,
  launch_date DATE,
  graduated_at TIMESTAMPTZ, -- When hub went from soft to open launch
  location GEOGRAPHY(POINT, 4326) GENERATED ALWAYS AS (
    ST_SetSRID(ST_MakePoint(lng, lat), 4326)::extensions.geography
  ) STORED,
  settings JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS service_hubs_location_gix ON service_hubs USING GIST(location);

-- 4. Waitlist with ring segmentation
CREATE TABLE IF NOT EXISTS waitlist (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) NOT NULL,
  phone VARCHAR(20),
  zip VARCHAR(10) NOT NULL,
  lat DECIMAL(9,6),
  lng DECIMAL(9,6),
  location GEOGRAPHY(POINT, 4326) GENERATED ALWAYS AS (
    CASE WHEN lat IS NOT NULL AND lng IS NOT NULL
    THEN ST_SetSRID(ST_MakePoint(lng, lat), 4326)::extensions.geography
    END
  ) STORED,
  nearest_hub_id UUID REFERENCES service_hubs(id),
  distance_miles DECIMAL(6,1),
  ring INTEGER GENERATED ALWAYS AS (
    CASE
      WHEN distance_miles IS NULL THEN NULL
      WHEN distance_miles <= 25 THEN 0
      WHEN distance_miles <= 50 THEN 1
      WHEN distance_miles <= 75 THEN 2
      WHEN distance_miles <= 100 THEN 3
      ELSE 99  -- Future expansion
    END
  ) STORED,
  user_type VARCHAR(20) CHECK (user_type IN ('customer', 'mechanic')),
  -- Customer fields
  service_needed TEXT,
  -- Mechanic fields
  services_offered TEXT[],
  years_experience INTEGER,
  willing_travel_miles INTEGER,
  -- Status
  invited_at TIMESTAMPTZ,
  converted_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(email, zip)
);

CREATE INDEX IF NOT EXISTS idx_waitlist_location ON waitlist USING GIST(location);
CREATE INDEX IF NOT EXISTS idx_waitlist_zip ON waitlist(zip);
CREATE INDEX IF NOT EXISTS idx_waitlist_ring ON waitlist(ring);
CREATE INDEX IF NOT EXISTS idx_waitlist_hub_ring ON waitlist(nearest_hub_id, ring);

-- 5. Add location columns to profiles
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS service_lat DECIMAL(9,6);
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS service_lng DECIMAL(9,6);
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS service_zip VARCHAR(10);
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS hub_id UUID REFERENCES service_hubs(id);
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS location_hash VARCHAR(64); -- For fraud detection

-- Add generated geography column if not exists
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'profiles' AND column_name = 'service_location'
  ) THEN
    ALTER TABLE profiles ADD COLUMN service_location GEOGRAPHY(POINT, 4326) 
      GENERATED ALWAYS AS (
        CASE WHEN service_lat IS NOT NULL AND service_lng IS NOT NULL 
        THEN ST_SetSRID(ST_MakePoint(service_lng, service_lat), 4326)::extensions.geography 
        END
      ) STORED;
  END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_profiles_service_location ON profiles USING GIST(service_location);
CREATE INDEX IF NOT EXISTS idx_profiles_hub ON profiles(hub_id);

-- 6. Add location columns to jobs
ALTER TABLE jobs ADD COLUMN IF NOT EXISTS job_lat DECIMAL(9,6);
ALTER TABLE jobs ADD COLUMN IF NOT EXISTS job_lng DECIMAL(9,6);
ALTER TABLE jobs ADD COLUMN IF NOT EXISTS hub_id UUID REFERENCES service_hubs(id);

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'jobs' AND column_name = 'job_location'
  ) THEN
    ALTER TABLE jobs ADD COLUMN job_location GEOGRAPHY(POINT, 4326)
      GENERATED ALWAYS AS (
        CASE WHEN job_lat IS NOT NULL AND job_lng IS NOT NULL 
        THEN ST_SetSRID(ST_MakePoint(job_lng, job_lat), 4326)::extensions.geography 
        END
      ) STORED;
  END IF;
END $$;

CREATE INDEX IF NOT EXISTS jobs_location_gix ON jobs USING GIST(job_location);
CREATE INDEX IF NOT EXISTS idx_jobs_hub ON jobs(hub_id);

-- 7. Core function: Check if point is within any active service area
CREATE OR REPLACE FUNCTION is_within_service_area(
  check_lat DECIMAL,
  check_lng DECIMAL
) RETURNS BOOLEAN AS $$
BEGIN
  IF check_lat IS NULL OR check_lng IS NULL THEN
    RETURN false;
  END IF;
  
  RETURN EXISTS (
    SELECT 1 FROM service_hubs
    WHERE is_active = true
    AND ST_DWithin(
      location,
      ST_SetSRID(ST_MakePoint(check_lng, check_lat), 4326)::extensions.geography,
      radius_miles * 1609.34
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

-- 8. Get nearest hub with distance
-- COMMENTED OUT: This function is now defined in migration 0086 with double precision parameters
-- to avoid function overload conflicts. The version in 0086 uses Haversine formula instead of PostGIS.
/*
DROP FUNCTION IF EXISTS get_nearest_hub(DECIMAL, DECIMAL);

CREATE OR REPLACE FUNCTION get_nearest_hub(
  check_lat DECIMAL,
  check_lng DECIMAL
) RETURNS TABLE(
  hub_id UUID,
  hub_name VARCHAR,
  hub_slug VARCHAR,
  distance_miles DECIMAL,
  radius_miles INTEGER,
  is_within_area BOOLEAN
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    h.id,
    h.name,
    h.slug,
    ROUND((ST_Distance(
      h.location,
      ST_SetSRID(ST_MakePoint(check_lng, check_lat), 4326)::extensions.geography
    ) / 1609.34)::DECIMAL, 1),
    h.radius_miles,
    ST_DWithin(
      h.location,
      ST_SetSRID(ST_MakePoint(check_lng, check_lat), 4326)::extensions.geography,
      h.radius_miles * 1609.34
    )
  FROM service_hubs h
  WHERE h.is_active = true
  ORDER BY ST_Distance(
    h.location,
    ST_SetSRID(ST_MakePoint(check_lng, check_lat), 4326)::extensions.geography
  )
  LIMIT 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;
*/

-- 9. Get nearby jobs for mechanics (with safety limit)
CREATE OR REPLACE FUNCTION get_nearby_jobs(
  mechanic_lat DECIMAL,
  mechanic_lng DECIMAL,
  max_miles INTEGER DEFAULT 50,
  result_limit INTEGER DEFAULT 100
) RETURNS TABLE(
  job_id UUID,
  title VARCHAR,
  description TEXT,
  lat DECIMAL,
  lng DECIMAL,
  distance_miles DECIMAL,
  created_at TIMESTAMPTZ,
  status VARCHAR
) AS $$
BEGIN
  -- Cap results to prevent abuse
  IF result_limit > 100 THEN
    result_limit := 100;
  END IF;
  
  RETURN QUERY
  SELECT 
    j.id,
    j.title,
    j.description,
    j.job_lat,
    j.job_lng,
    ROUND((ST_Distance(
      j.job_location,
      ST_SetSRID(ST_MakePoint(mechanic_lng, mechanic_lat), 4326)::extensions.geography
    ) / 1609.34)::DECIMAL, 1),
    j.created_at,
    j.status
  FROM jobs j
  WHERE j.status = 'open'
  AND j.job_location IS NOT NULL
  AND ST_DWithin(
    j.job_location,
    ST_SetSRID(ST_MakePoint(mechanic_lng, mechanic_lat), 4326)::extensions.geography,
    max_miles * 1609.34
  )
  ORDER BY ST_Distance(
    j.job_location,
    ST_SetSRID(ST_MakePoint(mechanic_lng, mechanic_lat), 4326)::extensions.geography
  )
  LIMIT result_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

-- 10. Assign job to nearest hub
CREATE OR REPLACE FUNCTION assign_job_to_hub()
RETURNS TRIGGER AS $$
DECLARE
  nearest UUID;
BEGIN
  IF NEW.job_lat IS NOT NULL AND NEW.job_lng IS NOT NULL THEN
    SELECT h.id INTO nearest
    FROM service_hubs h
    WHERE h.is_active = true
    ORDER BY ST_Distance(
      h.location,
      ST_SetSRID(ST_MakePoint(NEW.job_lng, NEW.job_lat), 4326)::extensions.geography
    )
    LIMIT 1;
    
    NEW.hub_id := nearest;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_assign_job_hub ON jobs;
CREATE TRIGGER trg_assign_job_hub
  BEFORE INSERT OR UPDATE OF job_lat, job_lng ON jobs
  FOR EACH ROW
  EXECUTE FUNCTION assign_job_to_hub();

-- 11. RLS Policies for service area enforcement

-- Jobs must be within ACTIVE radius (not max radius)
DROP POLICY IF EXISTS "Jobs must be in service area" ON jobs;
CREATE POLICY "Jobs must be in service area" ON jobs
  FOR INSERT WITH CHECK (
    job_lat IS NULL OR job_lng IS NULL OR
    EXISTS (
      SELECT 1 FROM service_hubs h
      WHERE h.is_active = true
      AND ST_DWithin(
        ST_SetSRID(ST_MakePoint(job_lng, job_lat), 4326)::extensions.geography,
        h.location,
        h.active_radius_miles * 1609.34  -- Use active, not max
      )
    )
  );

-- 12. Ring-based expansion metrics
CREATE OR REPLACE VIEW waitlist_by_ring AS
SELECT
  w.nearest_hub_id,
  h.name as hub_name,
  w.ring,
  w.user_type,
  COUNT(*) as count,
  COUNT(CASE WHEN w.invited_at IS NOT NULL THEN 1 END) as invited,
  COUNT(CASE WHEN w.converted_at IS NOT NULL THEN 1 END) as converted
FROM waitlist w
LEFT JOIN service_hubs h ON w.nearest_hub_id = h.id
WHERE w.ring IS NOT NULL
GROUP BY w.nearest_hub_id, h.name, w.ring, w.user_type
ORDER BY w.nearest_hub_id, w.ring, w.user_type;

-- Launch readiness check per ring
CREATE OR REPLACE VIEW ring_launch_readiness AS
SELECT
  h.id as hub_id,
  h.name as hub_name,
  h.active_radius_miles,
  r.ring,
  COALESCE(SUM(CASE WHEN w.user_type = 'customer' THEN 1 ELSE 0 END), 0) as customers,
  COALESCE(SUM(CASE WHEN w.user_type = 'mechanic' THEN 1 ELSE 0 END), 0) as mechanics,
  CASE
    WHEN r.ring = 0 THEN 20  -- Ring 0 needs 20 customers
    WHEN r.ring = 1 THEN 15
    WHEN r.ring = 2 THEN 10
    ELSE 10
  END as customer_threshold,
  CASE
    WHEN r.ring = 0 THEN 5   -- Ring 0 needs 5 mechanics
    ELSE 3
  END as mechanic_threshold
FROM service_hubs h
CROSS JOIN (SELECT generate_series(0, 3) as ring) r
LEFT JOIN waitlist w ON w.nearest_hub_id = h.id AND w.ring = r.ring
GROUP BY h.id, h.name, h.active_radius_miles, r.ring;

-- 13. Hub health metrics (for expansion decisions)
CREATE TABLE IF NOT EXISTS hub_daily_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  hub_id UUID REFERENCES service_hubs(id) NOT NULL,
  date DATE NOT NULL,
  jobs_created INTEGER DEFAULT 0,
  jobs_completed INTEGER DEFAULT 0,
  median_response_minutes INTEGER,
  avg_completion_rate DECIMAL(5,2),
  supply_shortage_reports INTEGER DEFAULT 0,
  active_mechanics INTEGER DEFAULT 0,
  UNIQUE(hub_id, date)
);

CREATE INDEX IF NOT EXISTS idx_hub_metrics_date ON hub_daily_metrics(hub_id, date DESC);

-- 14. Security audit table
CREATE TABLE IF NOT EXISTS location_audit (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  action VARCHAR(50) NOT NULL,
  claimed_lat DECIMAL(9,6),
  claimed_lng DECIMAL(9,6),
  claimed_zip VARCHAR(10),
  ip_address INET,
  ip_lat DECIMAL(9,6),
  ip_lng DECIMAL(9,6),
  distance_delta_miles DECIMAL(8,1),
  flagged BOOLEAN DEFAULT false,
  details JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_location_audit_user ON location_audit(user_id);
CREATE INDEX IF NOT EXISTS idx_location_audit_flagged ON location_audit(flagged) WHERE flagged = true;

-- 15. Insert Oak Lawn hub (60453)
INSERT INTO service_hubs (name, slug, zip, lat, lng, max_radius_miles, active_radius_miles, is_active, invite_only, launch_date)
VALUES ('Chicago', 'chicago', '60453', 41.7200, -87.7500, 100, 100, true, true, CURRENT_DATE)
ON CONFLICT (slug) DO UPDATE SET
  zip = EXCLUDED.zip,
  lat = EXCLUDED.lat,
  lng = EXCLUDED.lng,
  active_radius_miles = EXCLUDED.active_radius_miles;

-- 16. Function to check expansion readiness
CREATE OR REPLACE FUNCTION check_ring_expansion_ready(
  p_hub_id UUID,
  p_ring INTEGER
) RETURNS TABLE(
  ready BOOLEAN,
  customers INTEGER,
  mechanics INTEGER,
  customer_threshold INTEGER,
  mechanic_threshold INTEGER,
  last_7d_response_median INTEGER,
  last_7d_completion_rate DECIMAL
) AS $$
DECLARE
  cust_count INTEGER;
  mech_count INTEGER;
  cust_thresh INTEGER;
  mech_thresh INTEGER;
  resp_median INTEGER;
  comp_rate DECIMAL;
BEGIN
  -- Get waitlist counts for this ring
  SELECT
    COUNT(CASE WHEN user_type = 'customer' THEN 1 END),
    COUNT(CASE WHEN user_type = 'mechanic' THEN 1 END)
  INTO cust_count, mech_count
  FROM waitlist
  WHERE nearest_hub_id = p_hub_id AND ring = p_ring;

  -- Thresholds
  cust_thresh := CASE WHEN p_ring = 0 THEN 20 WHEN p_ring = 1 THEN 15 ELSE 10 END;
  mech_thresh := CASE WHEN p_ring = 0 THEN 5 ELSE 3 END;

  -- Last 7 days metrics
  SELECT
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY median_response_minutes),
    AVG(avg_completion_rate)
  INTO resp_median, comp_rate
  FROM hub_daily_metrics
  WHERE hub_id = p_hub_id AND date >= CURRENT_DATE - 7;

  RETURN QUERY SELECT
    (cust_count >= cust_thresh AND mech_count >= mech_thresh AND
     (resp_median IS NULL OR resp_median <= 20) AND
     (comp_rate IS NULL OR comp_rate >= 75)),
    cust_count,
    mech_count,
    cust_thresh,
    mech_thresh,
    resp_median,
    comp_rate;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

-- 17. Grant permissions
GRANT SELECT ON zip_codes TO authenticated;
GRANT SELECT ON service_hubs TO authenticated;
GRANT SELECT, INSERT, UPDATE ON waitlist TO authenticated, anon;
GRANT SELECT ON waitlist_by_ring TO authenticated;
GRANT SELECT ON ring_launch_readiness TO authenticated;
GRANT SELECT ON hub_daily_metrics TO authenticated;
GRANT EXECUTE ON FUNCTION is_within_service_area TO authenticated, anon;
-- GRANT EXECUTE ON FUNCTION get_nearest_hub TO authenticated, anon; -- Commented out - function now in 0086
GRANT EXECUTE ON FUNCTION get_nearby_jobs TO authenticated;
GRANT EXECUTE ON FUNCTION check_ring_expansion_ready TO authenticated;

COMMENT ON TABLE service_hubs IS 'Geographic service areas with ring-based expansion';
COMMENT ON TABLE waitlist IS 'Users segmented by ring for controlled launch';
COMMENT ON TABLE hub_daily_metrics IS 'Daily health metrics for expansion decisions';
COMMENT ON FUNCTION check_ring_expansion_ready IS 'Check if a ring meets launch thresholds';
\n-- ===================================================================
-- END: 0031_service_area_enforcement.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0032_invite_system.sql
-- ===================================================================\n
-- MIGRATION 0032: INVITE SYSTEM & LAUNCH DASHBOARD
-- Ring-based invite logic with kill switch

-- 1. Update waitlist with invite tracking
ALTER TABLE waitlist ADD COLUMN IF NOT EXISTS status VARCHAR(20) 
  DEFAULT 'waiting' CHECK (status IN ('waiting', 'invited', 'active', 'expired'));
ALTER TABLE waitlist ADD COLUMN IF NOT EXISTS invite_expires_at TIMESTAMPTZ;
ALTER TABLE waitlist ADD COLUMN IF NOT EXISTS invite_code VARCHAR(32);
ALTER TABLE waitlist ADD COLUMN IF NOT EXISTS accepted_at TIMESTAMPTZ;

CREATE INDEX IF NOT EXISTS idx_waitlist_status ON waitlist(status);
CREATE INDEX IF NOT EXISTS idx_waitlist_invite_expires ON waitlist(invite_expires_at) WHERE status = 'invited';

-- 2. Invite batches table (audit trail)
CREATE TABLE IF NOT EXISTS invite_batches (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  hub_id UUID REFERENCES service_hubs(id) NOT NULL,
  ring INTEGER NOT NULL,
  user_type VARCHAR(20) NOT NULL CHECK (user_type IN ('customer', 'mechanic')),
  batch_size INTEGER NOT NULL,
  invited_count INTEGER DEFAULT 0,
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  notes TEXT
);

-- 3. Launch dashboard metrics (daily snapshot)
CREATE TABLE IF NOT EXISTS launch_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  hub_id UUID REFERENCES service_hubs(id) NOT NULL,
  date DATE NOT NULL,
  -- Supply metrics
  active_mechanics INTEGER DEFAULT 0,
  new_mechanics INTEGER DEFAULT 0,
  -- Demand metrics
  jobs_requested INTEGER DEFAULT 0,
  jobs_completed INTEGER DEFAULT 0,
  -- Response metrics
  median_response_minutes INTEGER,
  p90_response_minutes INTEGER,
  -- Fulfillment
  completion_rate DECIMAL(5,2),
  -- Utilization
  jobs_per_mechanic DECIMAL(5,2),
  -- Ring distribution
  ring_0_jobs INTEGER DEFAULT 0,
  ring_1_jobs INTEGER DEFAULT 0,
  ring_2_jobs INTEGER DEFAULT 0,
  ring_3_jobs INTEGER DEFAULT 0,
  -- Support signals
  no_shows INTEGER DEFAULT 0,
  late_arrivals INTEGER DEFAULT 0,
  cancellations INTEGER DEFAULT 0,
  complaints INTEGER DEFAULT 0,
  -- Computed health
  health_score INTEGER, -- 0-100
  can_expand BOOLEAN DEFAULT false,
  UNIQUE(hub_id, date)
);

CREATE INDEX IF NOT EXISTS idx_launch_metrics_hub_date ON launch_metrics(hub_id, date DESC);

-- 4. Function: Check if hub can expand to next ring
CREATE OR REPLACE FUNCTION can_expand_ring(p_hub_id UUID)
RETURNS TABLE(
  can_expand BOOLEAN,
  current_ring INTEGER,
  next_ring INTEGER,
  blockers TEXT[],
  metrics JSONB
) AS $$
DECLARE
  hub RECORD;
  last_7d RECORD;
  current_r INTEGER;
  next_r INTEGER;
  blocks TEXT[] := '{}';
BEGIN
  -- Get hub info
  SELECT * INTO hub FROM service_hubs WHERE id = p_hub_id;
  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 0, 0, ARRAY['Hub not found']::TEXT[], '{}'::JSONB;
    RETURN;
  END IF;
  
  -- Calculate current ring from active radius
  current_r := CASE 
    WHEN hub.active_radius_miles <= 25 THEN 0
    WHEN hub.active_radius_miles <= 50 THEN 1
    WHEN hub.active_radius_miles <= 75 THEN 2
    ELSE 3
  END;
  next_r := LEAST(current_r + 1, 3);
  
  -- Get last 7 days metrics
  SELECT 
    AVG(median_response_minutes) as avg_response,
    AVG(completion_rate) as avg_completion,
    SUM(active_mechanics) / NULLIF(COUNT(*), 0) as avg_mechanics,
    SUM(complaints) as total_complaints,
    SUM(no_shows) as total_no_shows
  INTO last_7d
  FROM launch_metrics
  WHERE hub_id = p_hub_id AND date >= CURRENT_DATE - 7;
  
  -- Check blockers
  IF last_7d.avg_response IS NULL THEN
    blocks := array_append(blocks, 'No metrics data yet');
  ELSIF last_7d.avg_response > 20 THEN
    blocks := array_append(blocks, 'Response time > 20 min (' || ROUND(last_7d.avg_response) || ' min)');
  END IF;
  
  IF last_7d.avg_completion IS NOT NULL AND last_7d.avg_completion < 75 THEN
    blocks := array_append(blocks, 'Completion rate < 75% (' || ROUND(last_7d.avg_completion) || '%)');
  END IF;
  
  IF last_7d.total_complaints > 5 THEN
    blocks := array_append(blocks, 'Too many complaints (' || last_7d.total_complaints || ')');
  END IF;
  
  IF last_7d.total_no_shows > 3 THEN
    blocks := array_append(blocks, 'Too many no-shows (' || last_7d.total_no_shows || ')');
  END IF;
  
  IF current_r >= 3 THEN
    blocks := array_append(blocks, 'Already at max ring');
  END IF;
  
  RETURN QUERY SELECT
    array_length(blocks, 1) IS NULL OR array_length(blocks, 1) = 0,
    current_r,
    next_r,
    blocks,
    jsonb_build_object(
      'avg_response_minutes', ROUND(last_7d.avg_response),
      'avg_completion_rate', ROUND(last_7d.avg_completion),
      'avg_active_mechanics', ROUND(last_7d.avg_mechanics),
      'total_complaints', last_7d.total_complaints,
      'total_no_shows', last_7d.total_no_shows
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

-- 5. Function: Send invites for a ring (mechanics first)
CREATE OR REPLACE FUNCTION send_ring_invites(
  p_hub_id UUID,
  p_ring INTEGER,
  p_user_type VARCHAR(20),
  p_batch_size INTEGER DEFAULT 10,
  p_created_by UUID DEFAULT NULL
) RETURNS TABLE(
  invited_count INTEGER,
  invite_batch_id UUID
) AS $$
DECLARE
  batch_id UUID;
  count INTEGER := 0;
  invite_code VARCHAR(32);
  w RECORD;
BEGIN
  -- Validate batch size
  IF p_batch_size > 25 THEN
    p_batch_size := 25;
  END IF;
  
  -- Create batch record
  INSERT INTO invite_batches (hub_id, ring, user_type, batch_size, created_by)
  VALUES (p_hub_id, p_ring, p_user_type, p_batch_size, p_created_by)
  RETURNING id INTO batch_id;
  
  -- Send invites
  FOR w IN 
    SELECT id FROM waitlist
    WHERE nearest_hub_id = p_hub_id
    AND ring = p_ring
    AND user_type = p_user_type
    AND status = 'waiting'
    ORDER BY created_at ASC
    LIMIT p_batch_size
  LOOP
    invite_code := encode(gen_random_bytes(16), 'hex');
    
    UPDATE waitlist SET
      status = 'invited',
      invited_at = NOW(),
      invite_expires_at = NOW() + INTERVAL '72 hours',
      invite_code = invite_code
    WHERE id = w.id;
    
    count := count + 1;
  END LOOP;
  
  -- Update batch with actual count
  UPDATE invite_batches SET invited_count = count WHERE id = batch_id;
  
  RETURN QUERY SELECT count, batch_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6. Function: Expire old invites
CREATE OR REPLACE FUNCTION expire_old_invites()
RETURNS INTEGER AS $$
DECLARE
  expired_count INTEGER;
BEGIN
  UPDATE waitlist
  SET status = 'expired'
  WHERE status = 'invited'
  AND invite_expires_at < NOW();
  
  GET DIAGNOSTICS expired_count = ROW_COUNT;
  RETURN expired_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 7. Function: Accept invite
CREATE OR REPLACE FUNCTION accept_invite(p_invite_code VARCHAR(32))
RETURNS TABLE(
  success BOOLEAN,
  message TEXT,
  user_type VARCHAR,
  hub_name VARCHAR
) AS $$
DECLARE
  w RECORD;
  h RECORD;
BEGIN
  SELECT * INTO w FROM waitlist WHERE invite_code = p_invite_code;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 'Invalid invite code'::TEXT, NULL::VARCHAR, NULL::VARCHAR;
    RETURN;
  END IF;
  
  IF w.status = 'expired' THEN
    RETURN QUERY SELECT false, 'This invite has expired'::TEXT, NULL::VARCHAR, NULL::VARCHAR;
    RETURN;
  END IF;
  
  IF w.status = 'active' THEN
    RETURN QUERY SELECT false, 'This invite has already been used'::TEXT, NULL::VARCHAR, NULL::VARCHAR;
    RETURN;
  END IF;
  
  IF w.invite_expires_at < NOW() THEN
    UPDATE waitlist SET status = 'expired' WHERE id = w.id;
    RETURN QUERY SELECT false, 'This invite has expired'::TEXT, NULL::VARCHAR, NULL::VARCHAR;
    RETURN;
  END IF;
  
  -- Accept the invite
  UPDATE waitlist SET
    status = 'active',
    accepted_at = NOW()
  WHERE id = w.id;
  
  SELECT name INTO h FROM service_hubs WHERE id = w.nearest_hub_id;
  
  RETURN QUERY SELECT true, 'Welcome! Your account is now active.'::TEXT, w.user_type, h.name;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 8. Dashboard view: Current hub health
DROP VIEW IF EXISTS hub_health_dashboard;
CREATE VIEW hub_health_dashboard AS
SELECT 
  h.id as hub_id,
  h.name as hub_name,
  h.active_radius_miles,
  h.max_radius_miles,
  h.invite_only,
  CASE 
    WHEN h.active_radius_miles <= 25 THEN 0
    WHEN h.active_radius_miles <= 50 THEN 1
    WHEN h.active_radius_miles <= 75 THEN 2
    ELSE 3
  END as current_ring,
  -- Last 7 days
  ROUND(AVG(m.median_response_minutes)) as avg_response_7d,
  ROUND(AVG(m.completion_rate)) as avg_completion_7d,
  SUM(m.jobs_requested) as jobs_7d,
  SUM(m.jobs_completed) as completed_7d,
  ROUND(AVG(m.active_mechanics)) as avg_mechanics_7d,
  ROUND(AVG(m.jobs_per_mechanic), 1) as utilization_7d,
  SUM(m.complaints) as complaints_7d,
  SUM(m.no_shows) as no_shows_7d,
  -- Waitlist by ring
  (SELECT COUNT(*) FROM waitlist w WHERE w.nearest_hub_id = h.id AND w.ring = 0 AND w.status = 'waiting') as ring_0_waiting,
  (SELECT COUNT(*) FROM waitlist w WHERE w.nearest_hub_id = h.id AND w.ring = 1 AND w.status = 'waiting') as ring_1_waiting,
  (SELECT COUNT(*) FROM waitlist w WHERE w.nearest_hub_id = h.id AND w.ring = 2 AND w.status = 'waiting') as ring_2_waiting,
  (SELECT COUNT(*) FROM waitlist w WHERE w.nearest_hub_id = h.id AND w.ring = 3 AND w.status = 'waiting') as ring_3_waiting,
  -- Health assessment
  CASE
    WHEN AVG(m.median_response_minutes) > 25 THEN 'RED'
    WHEN AVG(m.median_response_minutes) > 15 THEN 'YELLOW'
    ELSE 'GREEN'
  END as response_health,
  CASE
    WHEN AVG(m.completion_rate) < 70 THEN 'RED'
    WHEN AVG(m.completion_rate) < 75 THEN 'YELLOW'
    ELSE 'GREEN'
  END as completion_health
FROM service_hubs h
LEFT JOIN launch_metrics m ON m.hub_id = h.id AND m.date >= CURRENT_DATE - 7
WHERE h.is_active = true
GROUP BY h.id, h.name, h.active_radius_miles, h.max_radius_miles, h.invite_only;

-- 9. Grant permissions
GRANT SELECT ON invite_batches TO authenticated;
GRANT SELECT ON launch_metrics TO authenticated;
GRANT SELECT ON hub_health_dashboard TO authenticated;
GRANT EXECUTE ON FUNCTION can_expand_ring TO authenticated;
GRANT EXECUTE ON FUNCTION send_ring_invites TO authenticated;
GRANT EXECUTE ON FUNCTION expire_old_invites TO authenticated;
GRANT EXECUTE ON FUNCTION accept_invite TO anon, authenticated;

COMMENT ON FUNCTION can_expand_ring IS 'Check if hub metrics allow expanding to next ring';
COMMENT ON FUNCTION send_ring_invites IS 'Send batch invites for a specific ring (mechanics first!)';
COMMENT ON FUNCTION accept_invite IS 'Accept an invite code and activate user';
COMMENT ON VIEW hub_health_dashboard IS 'Real-time hub health for launch decisions';
\n-- ===================================================================
-- END: 0032_invite_system.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0033_add_deleted_reason.sql
-- ===================================================================\n
-- Add columns required for account deletion
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS deleted_at timestamptz;
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS deleted_reason text;
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS deletion_requested_by uuid;
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS can_reapply boolean DEFAULT true;
\n-- ===================================================================
-- END: 0033_add_deleted_reason.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0034_add_deletion_columns.sql
-- ===================================================================\n
-- Add missing columns for account deletion
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS deleted_at timestamptz;
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS deletion_requested_by uuid;
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS can_reapply boolean DEFAULT true;
\n-- ===================================================================
-- END: 0034_add_deletion_columns.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0035_add_preferred_time_to_job_rpc.sql
-- ===================================================================\n
-- Add preferred_time parameter to create_job_with_payment_check
CREATE OR REPLACE FUNCTION public.create_job_with_payment_check(
  p_title text,
  p_description text DEFAULT NULL,
  p_location_address text DEFAULT NULL,
  p_location_lat double precision DEFAULT NULL,
  p_location_lng double precision DEFAULT NULL,
  p_vehicle_id uuid DEFAULT NULL,
  p_preferred_time text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_customer_id uuid;
  v_payment_status payment_method_status;
  v_job_id uuid;
BEGIN
  v_customer_id := auth.uid();
  
  IF v_customer_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'code', 'NOT_AUTHENTICATED');
  END IF;

  SELECT payment_method_status INTO v_payment_status
  FROM profiles WHERE id = v_customer_id;

  IF v_payment_status IS NULL OR v_payment_status != 'active' THEN
    RETURN jsonb_build_object(
      'success', false,
      'code', 'PAYMENT_METHOD_REQUIRED',
      'message', 'A valid payment method is required to request service'
    );
  END IF;

  INSERT INTO jobs (customer_id, title, description, location_address, location_lat, location_lng, vehicle_id, preferred_time, status)
  VALUES (v_customer_id, p_title, p_description, p_location_address, p_location_lat, p_location_lng, p_vehicle_id, p_preferred_time, 'searching')
  RETURNING id INTO v_job_id;

  RETURN jsonb_build_object('success', true, 'job_id', v_job_id);
END;
$$;

GRANT EXECUTE ON FUNCTION public.create_job_with_payment_check(text, text, text, double precision, double precision, uuid, text) TO authenticated;
\n-- ===================================================================
-- END: 0035_add_preferred_time_to_job_rpc.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0036_promo_system_enhancements.sql
-- ===================================================================\n
-- PROMO SYSTEM ENHANCEMENTS - SCHEMA

CREATE TABLE IF NOT EXISTS public.platform_pricing (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  key text UNIQUE NOT NULL,
  value_cents int,
  value_percent numeric,
  description text,
  effective_from timestamptz DEFAULT now() NOT NULL,
  effective_until timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

INSERT INTO public.platform_pricing (key, value_percent, value_cents, description) VALUES
  ('platform_fee_percent', 10.00, NULL, 'Platform fee as percentage of quote')
ON CONFLICT (key) DO NOTHING;

INSERT INTO public.platform_pricing (key, value_percent, value_cents, description) VALUES
  ('min_platform_fee_cents', NULL, 500, 'Minimum platform fee in cents')
ON CONFLICT (key) DO NOTHING;

INSERT INTO public.platform_pricing (key, value_percent, value_cents, description) VALUES
  ('max_platform_fee_cents', NULL, 10000, 'Maximum platform fee in cents')
ON CONFLICT (key) DO NOTHING;

CREATE INDEX IF NOT EXISTS idx_platform_pricing_key_effective 
  ON public.platform_pricing(key, effective_from) 
  WHERE effective_until IS NULL;

ALTER TABLE public.promotions 
  ADD COLUMN IF NOT EXISTS redemption_paused boolean DEFAULT false,
  ADD COLUMN IF NOT EXISTS pause_reason text,
  ADD COLUMN IF NOT EXISTS terms_text text,
  ADD COLUMN IF NOT EXISTS terms_updated_at timestamptz,
  ADD COLUMN IF NOT EXISTS max_total_discount_cents int,
  ADD COLUMN IF NOT EXISTS current_total_discount_cents int DEFAULT 0,
  ADD COLUMN IF NOT EXISTS applies_to text DEFAULT 'platform_fee',
  ADD COLUMN IF NOT EXISTS max_discount_cents int,
  ADD COLUMN IF NOT EXISTS sunset_at timestamptz,
  ADD COLUMN IF NOT EXISTS sunset_reason text,
  ADD COLUMN IF NOT EXISTS grant_paused boolean DEFAULT false,
  ADD COLUMN IF NOT EXISTS grant_pause_reason text,
  ADD COLUMN IF NOT EXISTS user_segment text DEFAULT 'all',
  ADD COLUMN IF NOT EXISTS priority int DEFAULT 0;

CREATE INDEX IF NOT EXISTS idx_promotions_financial_exposure 
  ON public.promotions(max_total_discount_cents, current_total_discount_cents) 
  WHERE active = true;

CREATE INDEX IF NOT EXISTS idx_promotions_sunset 
  ON public.promotions(sunset_at) 
  WHERE sunset_at IS NOT NULL AND active = true;

ALTER TABLE public.promo_credits
  ADD COLUMN IF NOT EXISTS expires_at timestamptz,
  ADD COLUMN IF NOT EXISTS paused boolean DEFAULT false,
  ADD COLUMN IF NOT EXISTS pause_reason text,
  ADD COLUMN IF NOT EXISTS max_discount_cents int,
  ADD COLUMN IF NOT EXISTS promotion_id uuid REFERENCES public.promotions(id);

CREATE INDEX IF NOT EXISTS idx_promo_credits_expires 
  ON public.promo_credits(expires_at) 
  WHERE expires_at IS NOT NULL AND remaining_uses > 0;

ALTER TABLE public.promotion_redemptions
  ADD COLUMN IF NOT EXISTS discount_cents int,
  ADD COLUMN IF NOT EXISTS quote_amount_cents int,
  ADD COLUMN IF NOT EXISTS platform_fee_cents int,
  ADD COLUMN IF NOT EXISTS discount_type text,
  ADD COLUMN IF NOT EXISTS idempotency_key text UNIQUE;

CREATE INDEX IF NOT EXISTS idx_promotion_redemptions_idempotency 
  ON public.promotion_redemptions(idempotency_key) 
  WHERE idempotency_key IS NOT NULL;

ALTER TABLE public.platform_pricing ENABLE ROW LEVEL SECURITY;

CREATE POLICY platform_pricing_select ON public.platform_pricing
  FOR SELECT USING (true);

GRANT SELECT ON public.platform_pricing TO authenticated;
\n-- ===================================================================
-- END: 0036_promo_system_enhancements.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0037_promo_validate_function.sql
-- ===================================================================\n
-- Promo validation function (read-only)
CREATE OR REPLACE FUNCTION public.validate_promo_eligibility(
  p_user_id uuid,
  p_promo_code text,
  p_quote_amount_cents int,
  p_platform_fee_cents int DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $func$
DECLARE
  v_promo record;
  v_user_redemptions int;
  v_user_role text;
  v_user_created_at timestamptz;
  v_platform_fee int;
  v_discount_cents int;
  v_eligible_amount int;
BEGIN
  IF p_platform_fee_cents IS NULL THEN
    v_platform_fee := GREATEST(
      COALESCE((SELECT value_cents FROM platform_pricing WHERE key = 'min_platform_fee_cents' AND effective_until IS NULL), 500),
      LEAST(
        (p_quote_amount_cents * COALESCE((SELECT value_percent FROM platform_pricing WHERE key = 'platform_fee_percent' AND effective_until IS NULL), 10) / 100)::int,
        COALESCE((SELECT value_cents FROM platform_pricing WHERE key = 'max_platform_fee_cents' AND effective_until IS NULL), 10000)
      )
    );
  ELSE
    v_platform_fee := p_platform_fee_cents;
  END IF;

  SELECT * INTO v_promo FROM promotions WHERE UPPER(code) = UPPER(p_promo_code);

  IF NOT FOUND THEN
    RETURN jsonb_build_object('valid', false, 'error_code', 'INVALID_CODE', 'user_message', 'This promo code is not valid.');
  END IF;

  IF NOT v_promo.active THEN
    RETURN jsonb_build_object('valid', false, 'error_code', 'PROMO_INACTIVE', 'user_message', 'This promotion is no longer active.');
  END IF;

  IF v_promo.redemption_paused THEN
    RETURN jsonb_build_object('valid', false, 'error_code', 'PROMO_PAUSED', 'user_message', COALESCE(v_promo.pause_reason, 'This promotion is temporarily unavailable.'));
  END IF;

  IF v_promo.start_date > now() THEN
    RETURN jsonb_build_object('valid', false, 'error_code', 'NOT_STARTED', 'user_message', 'This promotion has not started yet.');
  END IF;

  IF v_promo.end_date IS NOT NULL AND v_promo.end_date < now() THEN
    RETURN jsonb_build_object('valid', false, 'error_code', 'EXPIRED', 'user_message', 'This promotion has expired.');
  END IF;

  IF v_promo.max_redemptions IS NOT NULL AND v_promo.current_redemptions >= v_promo.max_redemptions THEN
    RETURN jsonb_build_object('valid', false, 'error_code', 'MAX_REDEMPTIONS', 'user_message', 'This promotion has reached its maximum redemptions.');
  END IF;

  SELECT COUNT(*) INTO v_user_redemptions FROM promotion_redemptions WHERE promotion_id = v_promo.id AND user_id = p_user_id;

  IF v_promo.max_redemptions_per_user IS NOT NULL AND v_user_redemptions >= v_promo.max_redemptions_per_user THEN
    RETURN jsonb_build_object('valid', false, 'error_code', 'USER_LIMIT', 'user_message', 'You have already used this promotion the maximum number of times.');
  END IF;

  IF v_promo.max_total_discount_cents IS NOT NULL AND v_promo.current_total_discount_cents >= v_promo.max_total_discount_cents THEN
    RETURN jsonb_build_object('valid', false, 'error_code', 'BUDGET_EXHAUSTED', 'user_message', 'This promotion has reached its budget limit.');
  END IF;

  IF v_promo.minimum_amount_cents IS NOT NULL AND p_quote_amount_cents < v_promo.minimum_amount_cents THEN
    RETURN jsonb_build_object('valid', false, 'error_code', 'MINIMUM_NOT_MET', 'user_message', format('Minimum order of $%s required.', (v_promo.minimum_amount_cents / 100.0)::text));
  END IF;

  CASE COALESCE(v_promo.applies_to, 'platform_fee')
    WHEN 'platform_fee' THEN v_eligible_amount := v_platform_fee;
    WHEN 'quote_amount' THEN v_eligible_amount := p_quote_amount_cents;
    WHEN 'both' THEN v_eligible_amount := p_quote_amount_cents + v_platform_fee;
    ELSE v_eligible_amount := v_platform_fee;
  END CASE;

  CASE v_promo.type
    WHEN 'percent_discount' THEN v_discount_cents := FLOOR(v_eligible_amount * v_promo.percent_off / 100)::int;
    WHEN 'fixed_discount' THEN v_discount_cents := LEAST(v_promo.amount_cents, v_eligible_amount);
    WHEN 'waive_platform_fee' THEN v_discount_cents := v_platform_fee;
    ELSE v_discount_cents := 0;
  END CASE;

  IF v_promo.max_discount_cents IS NOT NULL THEN
    v_discount_cents := LEAST(v_discount_cents, v_promo.max_discount_cents);
  END IF;

  IF v_promo.max_total_discount_cents IS NOT NULL THEN
    v_discount_cents := LEAST(v_discount_cents, v_promo.max_total_discount_cents - COALESCE(v_promo.current_total_discount_cents, 0));
  END IF;

  v_discount_cents := GREATEST(v_discount_cents, 0);

  RETURN jsonb_build_object(
    'valid', true,
    'promo_id', v_promo.id,
    'promo_code', v_promo.code,
    'promo_type', v_promo.type,
    'applies_to', COALESCE(v_promo.applies_to, 'platform_fee'),
    'discount_cents', v_discount_cents,
    'quote_amount_cents', p_quote_amount_cents,
    'platform_fee_cents', v_platform_fee,
    'terms_text', v_promo.terms_text,
    'user_message', format('You save $%s!', (v_discount_cents / 100.0)::text)
  );
END;
$func$;
\n-- ===================================================================
-- END: 0037_promo_validate_function.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0038_promo_apply_function.sql
-- ===================================================================\n
-- Atomic promo application function
CREATE OR REPLACE FUNCTION public.apply_promo_atomic(
  p_user_id uuid,
  p_promo_id uuid,
  p_payment_id uuid,
  p_discount_cents int,
  p_quote_amount_cents int,
  p_platform_fee_cents int,
  p_idempotency_key text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $func$
DECLARE
  v_promo record;
  v_existing_redemption uuid;
  v_redemption_id uuid;
BEGIN
  SELECT id INTO v_existing_redemption FROM promotion_redemptions WHERE idempotency_key = p_idempotency_key;

  IF FOUND THEN
    RETURN jsonb_build_object('success', true, 'redemption_id', v_existing_redemption, 'idempotent', true);
  END IF;

  SELECT * INTO v_promo FROM promotions WHERE id = p_promo_id FOR UPDATE;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'PROMO_NOT_FOUND');
  END IF;

  IF NOT v_promo.active THEN
    RETURN jsonb_build_object('success', false, 'error', 'PROMO_INACTIVE');
  END IF;

  IF v_promo.redemption_paused THEN
    RETURN jsonb_build_object('success', false, 'error', 'PROMO_PAUSED');
  END IF;

  IF v_promo.max_redemptions IS NOT NULL AND v_promo.current_redemptions >= v_promo.max_redemptions THEN
    RETURN jsonb_build_object('success', false, 'error', 'MAX_REDEMPTIONS');
  END IF;

  IF v_promo.max_total_discount_cents IS NOT NULL AND (COALESCE(v_promo.current_total_discount_cents, 0) + p_discount_cents) > v_promo.max_total_discount_cents THEN
    RETURN jsonb_build_object('success', false, 'error', 'BUDGET_EXCEEDED');
  END IF;

  INSERT INTO promotion_redemptions (promotion_id, user_id, payment_id, discount_cents, quote_amount_cents, platform_fee_cents, discount_type, idempotency_key)
  VALUES (p_promo_id, p_user_id, p_payment_id, p_discount_cents, p_quote_amount_cents, p_platform_fee_cents, v_promo.type, p_idempotency_key)
  RETURNING id INTO v_redemption_id;

  UPDATE promotions SET current_redemptions = current_redemptions + 1, current_total_discount_cents = COALESCE(current_total_discount_cents, 0) + p_discount_cents, updated_at = now() WHERE id = p_promo_id;

  RETURN jsonb_build_object('success', true, 'redemption_id', v_redemption_id, 'discount_applied_cents', p_discount_cents);
END;
$func$;
\n-- ===================================================================
-- END: 0038_promo_apply_function.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0039_promo_helper_function.sql
-- ===================================================================\n
-- Helper function to get platform fee
CREATE OR REPLACE FUNCTION public.get_platform_fee(p_quote_amount_cents int)
RETURNS int
LANGUAGE plpgsql
STABLE
AS $func$
DECLARE
  v_percent numeric;
  v_min int;
  v_max int;
  v_fee int;
BEGIN
  SELECT value_percent INTO v_percent FROM platform_pricing WHERE key = 'platform_fee_percent' AND effective_until IS NULL;
  SELECT value_cents INTO v_min FROM platform_pricing WHERE key = 'min_platform_fee_cents' AND effective_until IS NULL;
  SELECT value_cents INTO v_max FROM platform_pricing WHERE key = 'max_platform_fee_cents' AND effective_until IS NULL;

  v_fee := FLOOR(p_quote_amount_cents * COALESCE(v_percent, 10) / 100)::int;
  v_fee := GREATEST(v_fee, COALESCE(v_min, 500));
  v_fee := LEAST(v_fee, COALESCE(v_max, 10000));

  RETURN v_fee;
END;
$func$;
\n-- ===================================================================
-- END: 0039_promo_helper_function.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0040_promo_grants.sql
-- ===================================================================\n
GRANT EXECUTE ON FUNCTION public.apply_promo_atomic TO authenticated;
\n-- ===================================================================
-- END: 0040_promo_grants.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0041_promo_grants2.sql
-- ===================================================================\n
GRANT EXECUTE ON FUNCTION public.get_platform_fee TO authenticated;
\n-- ===================================================================
-- END: 0041_promo_grants2.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0042_promo_grants3.sql
-- ===================================================================\n
GRANT EXECUTE ON FUNCTION public.validate_promo_eligibility TO authenticated;
\n-- ===================================================================
-- END: 0042_promo_grants3.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0043_fix_avatar_storage_policy.sql
-- ===================================================================\n
-- Fix avatars storage bucket RLS policies
-- The path is avatars/{userId}.{ext} so foldername is 'avatars'

-- Ensure bucket exists and is public
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true)
ON CONFLICT (id) DO UPDATE SET public = true;

-- Drop existing policies
DROP POLICY IF EXISTS "Avatar upload" ON storage.objects;
DROP POLICY IF EXISTS "Avatar update" ON storage.objects;
DROP POLICY IF EXISTS "Avatar delete" ON storage.objects;
DROP POLICY IF EXISTS "Avatar public read" ON storage.objects;

-- Policy: Authenticated users can upload their own avatar
CREATE POLICY "Avatar upload" ON storage.objects
  FOR INSERT TO authenticated
  WITH CHECK (
    bucket_id = 'avatars' 
    AND (storage.filename(name) LIKE auth.uid()::text || '.%')
  );

-- Policy: Users can update their own avatar
CREATE POLICY "Avatar update" ON storage.objects
  FOR UPDATE TO authenticated
  USING (
    bucket_id = 'avatars'
    AND (storage.filename(name) LIKE auth.uid()::text || '.%')
  );

-- Policy: Users can delete their own avatar
CREATE POLICY "Avatar delete" ON storage.objects
  FOR DELETE TO authenticated
  USING (
    bucket_id = 'avatars'
    AND (storage.filename(name) LIKE auth.uid()::text || '.%')
  );

-- Policy: Anyone can read avatars (public bucket)
CREATE POLICY "Avatar public read" ON storage.objects
  FOR SELECT
  USING (bucket_id = 'avatars');
\n-- ===================================================================
-- END: 0043_fix_avatar_storage_policy.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0044_fix_mechanic_quote_check.sql
-- ===================================================================\n
-- Fix submit_quote_with_payment_check to check mechanic payout setup instead of payment method

CREATE OR REPLACE FUNCTION public.submit_quote_with_payment_check(
  p_job_id uuid,
  p_price_cents int,
  p_estimated_hours numeric DEFAULT NULL,
  p_notes text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic_id uuid;
  v_has_payout boolean;
  v_quote_id uuid;
BEGIN
  v_mechanic_id := auth.uid();
  
  IF v_mechanic_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'code', 'NOT_AUTHENTICATED');
  END IF;

  -- Check if mechanic has payout setup (check both tables)
  SELECT EXISTS (
    SELECT 1 FROM mechanic_stripe_accounts 
    WHERE mechanic_id = v_mechanic_id AND stripe_account_id IS NOT NULL
  ) OR EXISTS (
    SELECT 1 FROM mechanic_profiles 
    WHERE id = v_mechanic_id AND stripe_account_id IS NOT NULL
  ) INTO v_has_payout;

  IF NOT v_has_payout THEN
    RETURN jsonb_build_object(
      'success', false,
      'code', 'PAYOUT_NOT_SETUP',
      'message', 'Please set up your payout account before submitting quotes'
    );
  END IF;

  INSERT INTO quotes (job_id, mechanic_id, price_cents, estimated_hours, notes, status)
  VALUES (p_job_id, v_mechanic_id, p_price_cents, p_estimated_hours, p_notes, 'pending')
  RETURNING id INTO v_quote_id;

  RETURN jsonb_build_object('success', true, 'quote_id', v_quote_id);
END;
$$;
\n-- ===================================================================
-- END: 0044_fix_mechanic_quote_check.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0045_fix_quote_upsert.sql
-- ===================================================================\n
-- Fix submit_quote_with_payment_check to upsert instead of insert

CREATE OR REPLACE FUNCTION public.submit_quote_with_payment_check(
  p_job_id uuid,
  p_price_cents int,
  p_estimated_hours numeric DEFAULT NULL,
  p_notes text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic_id uuid;
  v_has_payout boolean;
  v_quote_id uuid;
BEGIN
  v_mechanic_id := auth.uid();
  
  IF v_mechanic_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'code', 'NOT_AUTHENTICATED');
  END IF;

  -- Check if mechanic has payout setup (check both tables)
  SELECT EXISTS (
    SELECT 1 FROM mechanic_stripe_accounts 
    WHERE mechanic_id = v_mechanic_id AND stripe_account_id IS NOT NULL
  ) OR EXISTS (
    SELECT 1 FROM mechanic_profiles 
    WHERE id = v_mechanic_id AND stripe_account_id IS NOT NULL
  ) INTO v_has_payout;

  IF NOT v_has_payout THEN
    RETURN jsonb_build_object(
      'success', false,
      'code', 'PAYOUT_NOT_SETUP',
      'message', 'Please set up your payout account before submitting quotes'
    );
  END IF;

  INSERT INTO quotes (job_id, mechanic_id, price_cents, estimated_hours, notes, status)
  VALUES (p_job_id, v_mechanic_id, p_price_cents, p_estimated_hours, p_notes, 'pending')
  ON CONFLICT (job_id, mechanic_id) DO UPDATE SET
    price_cents = EXCLUDED.price_cents,
    estimated_hours = EXCLUDED.estimated_hours,
    notes = EXCLUDED.notes,
    status = 'pending',
    updated_at = now()
  RETURNING id INTO v_quote_id;

  RETURN jsonb_build_object('success', true, 'quote_id', v_quote_id);
END;
$$;
\n-- ===================================================================
-- END: 0045_fix_quote_upsert.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0046_fix_profile_card_reviews.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0046: FIX PROFILE CARD REVIEWS DISPLAY
-- =====================================================
-- Purpose: Fix get_public_profile_card to handle review columns properly
-- Issue: Function references columns that may not exist in all environments
-- =====================================================

BEGIN;

-- =====================================================
-- ENSURE ENUM TYPES EXIST
-- =====================================================
DO $$ BEGIN
  CREATE TYPE public.review_visibility AS ENUM (
    'hidden',           -- Not yet visible (blind period)
    'visible',          -- Visible to all
    'moderated'         -- Hidden by moderation
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- =====================================================
-- ENSURE REVIEW COLUMNS EXIST
-- =====================================================
-- Add missing columns if they don't exist (idempotent)
ALTER TABLE public.reviews
  ADD COLUMN IF NOT EXISTS professionalism_rating int,
  ADD COLUMN IF NOT EXISTS communication_rating int,
  ADD COLUMN IF NOT EXISTS would_recommend boolean,
  ADD COLUMN IF NOT EXISTS visibility public.review_visibility DEFAULT 'hidden',
  ADD COLUMN IF NOT EXISTS made_visible_at timestamptz,
  ADD COLUMN IF NOT EXISTS visibility_reason text,
  ADD COLUMN IF NOT EXISTS blind_deadline timestamptz;

-- Add constraints if they don't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'reviews_professionalism_rating_range'
  ) THEN
    ALTER TABLE public.reviews ADD CONSTRAINT reviews_professionalism_rating_range 
      CHECK (professionalism_rating IS NULL OR (professionalism_rating >= 1 AND professionalism_rating <= 5));
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'reviews_communication_rating_range'
  ) THEN
    ALTER TABLE public.reviews ADD CONSTRAINT reviews_communication_rating_range 
      CHECK (communication_rating IS NULL OR (communication_rating >= 1 AND communication_rating <= 5));
  END IF;
END $$;

-- =====================================================
-- UPDATE FUNCTION: get_public_profile_card
-- =====================================================
-- Now properly handles all review columns including new ratings
CREATE OR REPLACE FUNCTION public.get_public_profile_card(user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  result jsonb;
  profile_record record;
  profile_ratings jsonb;
  profile_badges jsonb;
  profile_skills jsonb;
  profile_trust_score jsonb;
BEGIN
  -- Get the profile record
  SELECT p.id, p.role, p.full_name, p.avatar_url, p.created_at
  INTO profile_record
  FROM profiles p
  WHERE p.id = user_id
    AND p.deleted_at IS NULL;

  IF NOT FOUND THEN
    RETURN NULL;
  END IF;

  -- Get ratings from visible reviews only
  -- Uses visibility column if it exists, falls back to is_hidden
  SELECT jsonb_build_object(
    'overall_avg', COALESCE(AVG(r.overall_rating), 0),
    'performance_avg', COALESCE(AVG(r.performance_rating), 0),
    'timing_avg', COALESCE(AVG(r.timing_rating), 0),
    'cost_avg', COALESCE(AVG(r.cost_rating), 0),
    'professionalism_avg', COALESCE(AVG(r.professionalism_rating), 0),
    'communication_avg', COALESCE(AVG(r.communication_rating), 0),
    'review_count', COUNT(r.id)::integer,
    'would_recommend_count', COUNT(r.id) FILTER (WHERE r.would_recommend = true)::integer,
    'would_recommend_total', COUNT(r.id) FILTER (WHERE r.would_recommend IS NOT NULL)::integer
  )
  INTO profile_ratings
  FROM reviews r
  WHERE r.reviewee_id = profile_record.id
    AND (r.visibility = 'visible' OR (r.visibility IS NULL AND r.is_hidden = false))
    AND r.deleted_at IS NULL;

  -- Get badges with tier info
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ub.id,
      'badge_id', ub.badge_id,
      'awarded_at', ub.awarded_at,
      'badge', jsonb_build_object(
        'code', b.code,
        'title', b.title,
        'description', b.description,
        'icon', b.icon,
        'category', COALESCE(b.category, b.badge_type),
        'tier', b.tier
      )
    ) ORDER BY COALESCE(b.display_priority, 999) ASC
  ), '[]'::jsonb)
  INTO profile_badges
  FROM user_badges ub
  INNER JOIN badges b ON b.id = ub.badge_id
  WHERE ub.user_id = profile_record.id
    AND ub.revoked_at IS NULL
    AND (ub.expires_at IS NULL OR ub.expires_at > NOW());

  -- Get skills with verification status (for mechanics only)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ms.id,
      'skill', jsonb_build_object(
        'key', s.key,
        'label', s.label,
        'category', s.category
      ),
      'is_verified', COALESCE(ms.is_verified, false),
      'verified_job_count', COALESCE(ms.verified_job_count, 0),
      'avg_job_rating', ms.avg_job_rating
    ) ORDER BY COALESCE(ms.is_verified, false) DESC, COALESCE(ms.verified_job_count, 0) DESC
  ), '[]'::jsonb)
  INTO profile_skills
  FROM mechanic_skills ms
  INNER JOIN skills s ON s.key = ms.skill_key
  WHERE ms.mechanic_id = profile_record.id;

  -- Get trust score if available
  SELECT jsonb_build_object(
    'overall_score', ts.overall_score,
    'rating_score', ts.rating_score,
    'completion_score', ts.completion_score,
    'reliability_score', ts.reliability_score,
    'badge_score', ts.badge_score,
    'tenure_score', ts.tenure_score,
    'completed_jobs', ts.completed_jobs,
    'total_jobs', ts.total_jobs
  )
  INTO profile_trust_score
  FROM trust_scores ts
  WHERE ts.user_id = profile_record.id;

  -- Build result (NO email, NO phone - privacy protected)
  result := jsonb_build_object(
    'id', profile_record.id,
    'role', profile_record.role,
    'display_name', COALESCE(profile_record.full_name, 'User'),
    'avatar_url', profile_record.avatar_url,
    'created_at', profile_record.created_at,
    'ratings', profile_ratings,
    'badges', profile_badges,
    'skills', profile_skills,
    'trust_score', COALESCE(profile_trust_score, jsonb_build_object(
      'overall_score', 50,
      'rating_score', 50,
      'completion_score', 100,
      'reliability_score', 50,
      'badge_score', 0,
      'tenure_score', 0,
      'completed_jobs', 0,
      'total_jobs', 0
    ))
  );

  RETURN result;
END;
$$;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO anon;

COMMIT;
\n-- ===================================================================
-- END: 0046_fix_profile_card_reviews.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0047_chat_moderation_system.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0047: CHAT MODERATION & PLATFORM PROTECTION
-- =====================================================
-- Purpose: Implement anti-circumvention controls, chat lifecycle management,
--          and preferred mechanic system to prevent platform bypass
-- =====================================================

BEGIN;

-- =====================================================
-- ENUM TYPES
-- =====================================================

DO $$ BEGIN
  CREATE TYPE public.message_action AS ENUM (
    'allowed',
    'blocked',
    'masked',
    'warned'
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  CREATE TYPE public.violation_tier AS ENUM (
    'education',
    'warning',
    'restriction',
    'review'
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  CREATE TYPE public.chat_restriction_type AS ENUM (
    'none',
    'soft_warning',
    'contact_info_blocked',
    'templated_only',
    'read_only',
    'suspended'
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- =====================================================
-- TABLE: message_audit_logs
-- =====================================================
CREATE TABLE IF NOT EXISTS public.message_audit_logs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  message_id uuid NOT NULL,
  conversation_id uuid NOT NULL,
  sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  recipient_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Message content
  original_content text NOT NULL,
  displayed_content text,
  
  -- Detection details
  patterns_detected text[],
  risk_score numeric(5,2),
  action_taken public.message_action NOT NULL,
  
  -- Context
  job_id uuid REFERENCES public.jobs(id) ON DELETE SET NULL,
  job_stage text,
  sender_account_age_days int,
  sender_completed_jobs int,
  sender_previous_violations int,
  
  -- Review
  flagged_for_review boolean DEFAULT false,
  reviewed_by uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
  reviewed_at timestamptz,
  review_decision text,
  review_notes text,
  
  created_at timestamptz DEFAULT now() NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_message_audit_sender ON public.message_audit_logs(sender_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_message_audit_conversation ON public.message_audit_logs(conversation_id);
CREATE INDEX IF NOT EXISTS idx_message_audit_flagged ON public.message_audit_logs(flagged_for_review) WHERE flagged_for_review = true;
CREATE INDEX IF NOT EXISTS idx_message_audit_job ON public.message_audit_logs(job_id) WHERE job_id IS NOT NULL;

COMMENT ON TABLE public.message_audit_logs IS 'Audit trail for message moderation and contact info detection';

-- =====================================================
-- TABLE: user_violations
-- =====================================================
CREATE TABLE IF NOT EXISTS public.user_violations (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Violation details
  violation_type text NOT NULL,
  tier public.violation_tier NOT NULL,
  description text,
  
  -- Context
  message_audit_log_id uuid REFERENCES public.message_audit_logs(id) ON DELETE SET NULL,
  job_id uuid REFERENCES public.jobs(id) ON DELETE SET NULL,
  
  -- Resolution
  acknowledged boolean DEFAULT false,
  acknowledged_at timestamptz,
  expires_at timestamptz,
  
  created_at timestamptz DEFAULT now() NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_user_violations_user ON public.user_violations(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_user_violations_active ON public.user_violations(user_id, expires_at);

COMMENT ON TABLE public.user_violations IS 'Track user violations for progressive enforcement';

-- =====================================================
-- TABLE: chat_restrictions
-- =====================================================
CREATE TABLE IF NOT EXISTS public.chat_restrictions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Restriction details
  restriction_type public.chat_restriction_type NOT NULL,
  reason text,
  
  -- Scope
  applies_to_all_chats boolean DEFAULT true,
  specific_conversation_id uuid,
  
  -- Duration
  starts_at timestamptz DEFAULT now() NOT NULL,
  expires_at timestamptz,
  
  -- Review
  requires_human_review boolean DEFAULT false,
  reviewed_by uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
  reviewed_at timestamptz,
  review_notes text,
  
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_chat_restrictions_user ON public.chat_restrictions(user_id);
CREATE INDEX IF NOT EXISTS idx_chat_restrictions_active ON public.chat_restrictions(user_id, expires_at);

COMMENT ON TABLE public.chat_restrictions IS 'Active chat restrictions for users';

-- =====================================================
-- TABLE: preferred_mechanics
-- =====================================================
CREATE TABLE IF NOT EXISTS public.preferred_mechanics (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Relationship metrics
  jobs_completed int DEFAULT 0 NOT NULL,
  total_spent_cents bigint DEFAULT 0 NOT NULL,
  avg_rating numeric(3,2),
  last_job_at timestamptz,
  
  -- Benefits
  commission_tier int DEFAULT 1 NOT NULL,
  priority_scheduling boolean DEFAULT false,
  
  -- Status
  is_active boolean DEFAULT true,
  
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  
  CONSTRAINT preferred_mechanics_unique UNIQUE(customer_id, mechanic_id),
  CONSTRAINT preferred_mechanics_commission_tier_range CHECK (commission_tier >= 1 AND commission_tier <= 5)
);

CREATE INDEX IF NOT EXISTS idx_preferred_mechanics_customer ON public.preferred_mechanics(customer_id, is_active);
CREATE INDEX IF NOT EXISTS idx_preferred_mechanics_mechanic ON public.preferred_mechanics(mechanic_id, is_active);
CREATE INDEX IF NOT EXISTS idx_preferred_mechanics_tier ON public.preferred_mechanics(commission_tier);

COMMENT ON TABLE public.preferred_mechanics IS 'Track preferred mechanic relationships for reduced commissions';

-- =====================================================
-- TABLE: chat_lifecycle_config
-- =====================================================
CREATE TABLE IF NOT EXISTS public.chat_lifecycle_config (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id uuid NOT NULL UNIQUE,
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  
  -- Lifecycle timestamps
  chat_opened_at timestamptz DEFAULT now() NOT NULL,
  job_completed_at timestamptz,
  chat_readonly_at timestamptz,
  chat_archived_at timestamptz,
  
  -- Configuration
  post_completion_window_hours int DEFAULT 48,
  readonly_period_days int DEFAULT 30,
  
  -- Flags
  has_safety_issue boolean DEFAULT false,
  has_dispute boolean DEFAULT false,
  
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_chat_lifecycle_conversation ON public.chat_lifecycle_config(conversation_id);
CREATE INDEX IF NOT EXISTS idx_chat_lifecycle_job ON public.chat_lifecycle_config(job_id);

COMMENT ON TABLE public.chat_lifecycle_config IS 'Manage chat lifecycle based on job stage';

-- =====================================================
-- FUNCTION: detect_contact_info
-- =====================================================
CREATE OR REPLACE FUNCTION public.detect_contact_info(message_text text)
RETURNS jsonb
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  patterns_found text[] := '{}';
  risk_score numeric := 0;
BEGIN
  -- Phone number patterns
  IF message_text ~* '(\+?1[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}' THEN
    patterns_found := array_append(patterns_found, 'phone');
    risk_score := risk_score + 30;
  END IF;
  
  -- Email patterns
  IF message_text ~* '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}' THEN
    patterns_found := array_append(patterns_found, 'email');
    risk_score := risk_score + 30;
  END IF;
  
  -- Social media patterns
  IF message_text ~* '(instagram|facebook|whatsapp|telegram|snapchat|twitter|tiktok)[\s:@]?[\w.]+' THEN
    patterns_found := array_append(patterns_found, 'social');
    risk_score := risk_score + 25;
  END IF;
  
  -- URL patterns
  IF message_text ~* '(https?://|www\.)[^\s]+' THEN
    patterns_found := array_append(patterns_found, 'url');
    risk_score := risk_score + 20;
  END IF;
  
  -- Obfuscation patterns - spaced digits
  IF message_text ~* '\d[\s.]{1,3}\d[\s.]{1,3}\d[\s.]{1,3}\d[\s.]{1,3}\d' THEN
    patterns_found := array_append(patterns_found, 'obfuscated_phone');
    risk_score := risk_score + 40;
  END IF;
  
  -- Obfuscation patterns - word numbers
  IF message_text ~* '(zero|one|two|three|four|five|six|seven|eight|nine)[\s-]+(zero|one|two|three|four|five|six|seven|eight|nine)' THEN
    patterns_found := array_append(patterns_found, 'obfuscated_numbers');
    risk_score := risk_score + 35;
  END IF;
  
  -- Obfuscation patterns - at/dot
  IF message_text ~* '(\bat\b|\[at\]|\(at\)).*(\bdot\b|\[dot\]|\(dot\))' THEN
    patterns_found := array_append(patterns_found, 'obfuscated_email');
    risk_score := risk_score + 35;
  END IF;
  
  RETURN jsonb_build_object(
    'patterns_detected', patterns_found,
    'risk_score', LEAST(risk_score, 100),
    'has_contact_info', array_length(patterns_found, 1) > 0
  );
END;
$$;

COMMENT ON FUNCTION public.detect_contact_info IS 'Detect contact information and obfuscation patterns in messages';

-- =====================================================
-- FUNCTION: check_legitimate_patterns
-- =====================================================
CREATE OR REPLACE FUNCTION public.check_legitimate_patterns(message_text text)
RETURNS boolean
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
  -- Part numbers (often look like phone numbers)
  IF message_text ~* 'part\s*#?\s*\d{3}[-.\s]?\d{3}[-.\s]?\d{4}' THEN
    RETURN true;
  END IF;
  
  -- VIN numbers
  IF message_text ~* '\b[A-HJ-NPR-Z0-9]{17}\b' THEN
    RETURN true;
  END IF;
  
  -- License plates
  IF message_text ~* 'plate\s*#?\s*[A-Z0-9]{2,8}' THEN
    RETURN true;
  END IF;
  
  -- Addresses (legitimate for mobile mechanics)
  IF message_text ~* '\d+\s+[A-Za-z\s]+(?:street|st|avenue|ave|road|rd|drive|dr|lane|ln|way|court|ct|circle|blvd|boulevard)' THEN
    RETURN true;
  END IF;
  
  -- Time references
  IF message_text ~* '\d{1,2}:\d{2}\s*(?:am|pm)?' THEN
    RETURN true;
  END IF;
  
  RETURN false;
END;
$$;

COMMENT ON FUNCTION public.check_legitimate_patterns IS 'Check if message contains legitimate patterns that look like contact info';

-- =====================================================
-- FUNCTION: calculate_message_risk
-- =====================================================
CREATE OR REPLACE FUNCTION public.calculate_message_risk(
  p_message_text text,
  p_sender_id uuid,
  p_job_id uuid,
  p_job_stage text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_detection_result jsonb;
  v_is_legitimate boolean;
  v_sender_age_days int;
  v_completed_jobs int;
  v_recent_violations int;
  v_final_risk_score numeric;
  v_action public.message_action;
  v_restriction_level text;
BEGIN
  -- Detect contact info patterns
  v_detection_result := detect_contact_info(p_message_text);
  
  -- Check for legitimate patterns
  v_is_legitimate := check_legitimate_patterns(p_message_text);
  
  -- If legitimate pattern detected, allow with low risk
  IF v_is_legitimate THEN
    RETURN jsonb_build_object(
      'risk_level', 'low',
      'risk_score', 0,
      'action', 'allowed',
      'patterns_detected', '{}',
      'reason', 'legitimate_pattern'
    );
  END IF;
  
  -- If no contact info detected, allow
  IF NOT (v_detection_result->>'has_contact_info')::boolean THEN
    RETURN jsonb_build_object(
      'risk_level', 'low',
      'risk_score', 0,
      'action', 'allowed',
      'patterns_detected', '{}',
      'reason', 'no_contact_info'
    );
  END IF;
  
  -- Get sender context
  SELECT
    EXTRACT(DAY FROM (now() - p.created_at))::int,
    COALESCE(COUNT(DISTINCT j.id), 0)
  INTO v_sender_age_days, v_completed_jobs
  FROM profiles p
  LEFT JOIN jobs j ON (j.customer_id = p.id OR j.accepted_mechanic_id = p.id)
    AND j.status = 'completed'
  WHERE p.id = p_sender_id
  GROUP BY p.created_at;
  
  -- Get recent violations (last 30 days)
  SELECT COUNT(*)::int
  INTO v_recent_violations
  FROM user_violations
  WHERE user_id = p_sender_id
    AND created_at > now() - interval '30 days';
  
  -- Calculate final risk score
  v_final_risk_score := (v_detection_result->>'risk_score')::numeric;
  
  -- Adjust based on user context
  IF v_sender_age_days < 7 THEN
    v_final_risk_score := v_final_risk_score + 15;
  END IF;
  
  IF v_completed_jobs = 0 THEN
    v_final_risk_score := v_final_risk_score + 10;
  ELSIF v_completed_jobs >= 10 THEN
    v_final_risk_score := v_final_risk_score - 15;
  END IF;
  
  IF v_recent_violations > 0 THEN
    v_final_risk_score := v_final_risk_score + (v_recent_violations * 10);
  END IF;
  
  -- Adjust based on job stage
  IF p_job_stage IN ('searching', 'quoted') THEN
    -- Pre-booking: highest risk
    v_final_risk_score := v_final_risk_score + 20;
  ELSIF p_job_stage IN ('accepted', 'work_in_progress') THEN
    -- Active job: lower risk
    v_final_risk_score := v_final_risk_score - 20;
  ELSIF p_job_stage = 'completed' THEN
    -- Post-completion: medium risk
    v_final_risk_score := v_final_risk_score + 10;
  END IF;

  -- Cap at 100
  v_final_risk_score := LEAST(v_final_risk_score, 100);

  -- Determine action based on risk score and job stage
  IF v_final_risk_score >= 70 THEN
    -- High risk
    IF p_job_stage IN ('searching', 'quoted') THEN
      v_action := 'blocked';
      v_restriction_level := 'high';
    ELSE
      v_action := 'warned';
      v_restriction_level := 'medium';
    END IF;
  ELSIF v_final_risk_score >= 40 THEN
    -- Medium risk
    IF p_job_stage IN ('searching', 'quoted') THEN
      v_action := 'blocked';
      v_restriction_level := 'medium';
    ELSIF p_job_stage = 'completed' THEN
      v_action := 'masked';
      v_restriction_level := 'medium';
    ELSE
      v_action := 'warned';
      v_restriction_level := 'low';
    END IF;
  ELSE
    -- Low risk
    v_action := 'allowed';
    v_restriction_level := 'low';
  END IF;
  
  RETURN jsonb_build_object(
    'risk_level', v_restriction_level,
    'risk_score', v_final_risk_score,
    'action', v_action,
    'patterns_detected', v_detection_result->'patterns_detected',
    'sender_age_days', v_sender_age_days,
    'completed_jobs', v_completed_jobs,
    'recent_violations', v_recent_violations,
    'job_stage', p_job_stage
  );
END;
$$;

COMMENT ON FUNCTION public.calculate_message_risk IS 'Calculate risk score and determine action for message moderation';

-- =====================================================
-- FUNCTION: get_user_violation_count
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_user_violation_count(p_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_total int;
  v_last_30_days int;
  v_last_7_days int;
  v_current_tier public.violation_tier;
BEGIN
  SELECT 
    COUNT(*)::int,
    COUNT(*) FILTER (WHERE created_at > now() - interval '30 days')::int,
    COUNT(*) FILTER (WHERE created_at > now() - interval '7 days')::int
  INTO v_total, v_last_30_days, v_last_7_days
  FROM user_violations
  WHERE user_id = p_user_id;
  
  -- Determine current tier based on recent violations
  IF v_last_7_days >= 6 THEN
    v_current_tier := 'review';
  ELSIF v_last_7_days >= 4 THEN
    v_current_tier := 'restriction';
  ELSIF v_last_7_days >= 2 THEN
    v_current_tier := 'warning';
  ELSE
    v_current_tier := 'education';
  END IF;
  
  RETURN jsonb_build_object(
    'total', v_total,
    'last_30_days', v_last_30_days,
    'last_7_days', v_last_7_days,
    'current_tier', v_current_tier
  );
END;
$$;

COMMENT ON FUNCTION public.get_user_violation_count IS 'Get violation counts and current enforcement tier for user';

COMMIT;
\n-- ===================================================================
-- END: 0047_chat_moderation_system.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0048_chat_moderation_rpcs.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0048: CHAT MODERATION RPC FUNCTIONS
-- =====================================================
-- Purpose: RPC functions for message scanning, enforcement, and preferred mechanics
-- =====================================================

BEGIN;

-- =====================================================
-- FUNCTION: scan_message_before_send
-- =====================================================
CREATE OR REPLACE FUNCTION public.scan_message_before_send(
  p_message_text text,
  p_recipient_id uuid,
  p_job_id uuid DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_sender_id uuid;
  v_job_stage text;
  v_risk_result jsonb;
  v_active_restriction record;
  v_masked_content text;
BEGIN
  -- Get authenticated user
  v_sender_id := auth.uid();
  
  IF v_sender_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Check for active chat restrictions
  SELECT * INTO v_active_restriction
  FROM chat_restrictions
  WHERE user_id = v_sender_id
    AND (expires_at IS NULL OR expires_at > now())
  ORDER BY created_at DESC
  LIMIT 1;
  
  IF v_active_restriction.restriction_type = 'suspended' THEN
    RETURN jsonb_build_object(
      'allowed', false,
      'action', 'blocked',
      'reason', 'account_suspended',
      'message', 'Your account is under review. Please contact support.',
      'requires_human_review', true
    );
  END IF;
  
  IF v_active_restriction.restriction_type = 'templated_only' THEN
    RETURN jsonb_build_object(
      'allowed', false,
      'action', 'blocked',
      'reason', 'templated_only',
      'message', 'Your chat access is temporarily limited. Please use quick action buttons.',
      'restriction_expires_at', v_active_restriction.expires_at
    );
  END IF;
  
  -- Get job stage if job_id provided
  IF p_job_id IS NOT NULL THEN
    SELECT status INTO v_job_stage
    FROM jobs
    WHERE id = p_job_id;
  END IF;
  
  -- Calculate risk
  v_risk_result := calculate_message_risk(
    p_message_text,
    v_sender_id,
    p_job_id,
    COALESCE(v_job_stage, 'unknown')
  );
  
  -- Determine response based on action
  CASE (v_risk_result->>'action')::message_action
    WHEN 'blocked' THEN
      RETURN jsonb_build_object(
        'allowed', false,
        'action', 'blocked',
        'reason', 'contact_info_detected',
        'risk_score', v_risk_result->'risk_score',
        'patterns_detected', v_risk_result->'patterns_detected',
        'message', CASE
          WHEN v_job_stage IN ('searching', 'quoted') THEN
            'For your protection, please keep all communication in WrenchGo until the job is booked. This ensures payment protection, job history, and support if anything goes wrong.'
          ELSE
            'We detected contact information in your message. For warranty coverage and payment protection, keep future bookings through WrenchGo.'
        END,
        'show_rebook_button', v_job_stage = 'completed'
      );
      
    WHEN 'masked' THEN
      -- Mask contact info in message
      v_masked_content := p_message_text;
      v_masked_content := regexp_replace(v_masked_content, '(\+?1[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}', '[Contact Hidden]', 'g');
      v_masked_content := regexp_replace(v_masked_content, '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}', '[Email Hidden]', 'g');
      
      RETURN jsonb_build_object(
        'allowed', true,
        'action', 'masked',
        'original_content', p_message_text,
        'masked_content', v_masked_content,
        'risk_score', v_risk_result->'risk_score',
        'patterns_detected', v_risk_result->'patterns_detected',
        'message', 'Contact info has been hidden. Use the Rebook button to work with this person again!',
        'show_rebook_button', true
      );
      
    WHEN 'warned' THEN
      RETURN jsonb_build_object(
        'allowed', true,
        'action', 'warned',
        'risk_score', v_risk_result->'risk_score',
        'patterns_detected', v_risk_result->'patterns_detected',
        'warning_message', 'Sharing contact info? For warranty coverage and payment protection, keep future bookings through WrenchGo.',
        'show_soft_warning', true
      );
      
    ELSE -- 'allowed'
      RETURN jsonb_build_object(
        'allowed', true,
        'action', 'allowed',
        'risk_score', v_risk_result->'risk_score'
      );
  END CASE;
END;
$$;

GRANT EXECUTE ON FUNCTION public.scan_message_before_send TO authenticated;

COMMENT ON FUNCTION public.scan_message_before_send IS 'Scan message for contact info before sending, return action to take';

-- =====================================================
-- FUNCTION: log_message_audit
-- =====================================================
CREATE OR REPLACE FUNCTION public.log_message_audit(
  p_message_id uuid,
  p_conversation_id uuid,
  p_recipient_id uuid,
  p_original_content text,
  p_displayed_content text,
  p_action text,
  p_risk_result jsonb,
  p_job_id uuid DEFAULT NULL
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_sender_id uuid;
  v_audit_id uuid;
  v_sender_age_days int;
  v_completed_jobs int;
  v_recent_violations int;
  v_job_stage text;
  v_patterns text[];
BEGIN
  v_sender_id := auth.uid();
  
  IF v_sender_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Get sender context
  SELECT
    EXTRACT(DAY FROM (now() - p.created_at))::int,
    COALESCE(COUNT(DISTINCT j.id), 0)
  INTO v_sender_age_days, v_completed_jobs
  FROM profiles p
  LEFT JOIN jobs j ON (j.customer_id = p.id OR j.accepted_mechanic_id = p.id)
    AND j.status = 'completed'
  WHERE p.id = v_sender_id
  GROUP BY p.created_at;
  
  -- Get recent violations
  SELECT COUNT(*)::int INTO v_recent_violations
  FROM user_violations
  WHERE user_id = v_sender_id
    AND created_at > now() - interval '30 days';
  
  -- Get job stage
  IF p_job_id IS NOT NULL THEN
    SELECT status INTO v_job_stage FROM jobs WHERE id = p_job_id;
  END IF;

  -- Parse patterns from JSONB array to text[]
  SELECT COALESCE(array_agg(elem::text), '{}')
  INTO v_patterns
  FROM jsonb_array_elements_text(COALESCE(p_risk_result->'patterns_detected', '[]'::jsonb)) AS elem;

  -- Insert audit log
  INSERT INTO message_audit_logs (
    message_id,
    conversation_id,
    sender_id,
    recipient_id,
    original_content,
    displayed_content,
    patterns_detected,
    risk_score,
    action_taken,
    job_id,
    job_stage,
    sender_account_age_days,
    sender_completed_jobs,
    sender_previous_violations,
    flagged_for_review
  ) VALUES (
    p_message_id,
    p_conversation_id,
    v_sender_id,
    p_recipient_id,
    p_original_content,
    p_displayed_content,
    v_patterns,
    COALESCE((p_risk_result->>'risk_score')::numeric, 0),
    p_action::message_action,
    p_job_id,
    v_job_stage,
    COALESCE(v_sender_age_days, 0),
    COALESCE(v_completed_jobs, 0),
    COALESCE(v_recent_violations, 0),
    COALESCE((p_risk_result->>'risk_score')::numeric, 0) >= 70
  )
  RETURNING id INTO v_audit_id;

  RETURN v_audit_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.log_message_audit TO authenticated;

COMMENT ON FUNCTION public.log_message_audit IS 'Log message audit trail for moderation';

-- =====================================================
-- FUNCTION: record_violation
-- =====================================================
CREATE OR REPLACE FUNCTION public.record_violation(
  p_user_id uuid,
  p_violation_type text,
  p_description text DEFAULT NULL,
  p_message_audit_log_id uuid DEFAULT NULL,
  p_job_id uuid DEFAULT NULL
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_violation_id uuid;
  v_violation_counts jsonb;
  v_tier public.violation_tier;
  v_expires_at timestamptz;
BEGIN
  -- Get current violation counts
  v_violation_counts := get_user_violation_count(p_user_id);
  
  -- Determine tier and expiration
  CASE (v_violation_counts->>'current_tier')::violation_tier
    WHEN 'education' THEN
      v_tier := 'education';
      v_expires_at := NULL; -- No expiration for education
    WHEN 'warning' THEN
      v_tier := 'warning';
      v_expires_at := now() + interval '7 days';
    WHEN 'restriction' THEN
      v_tier := 'restriction';
      v_expires_at := now() + interval '24 hours';
    WHEN 'review' THEN
      v_tier := 'review';
      v_expires_at := NULL; -- Requires human review
  END CASE;
  
  -- Insert violation
  INSERT INTO user_violations (
    user_id,
    violation_type,
    tier,
    description,
    message_audit_log_id,
    job_id,
    expires_at
  ) VALUES (
    p_user_id,
    p_violation_type,
    v_tier,
    p_description,
    p_message_audit_log_id,
    p_job_id,
    v_expires_at
  )
  RETURNING id INTO v_violation_id;
  
  -- Apply chat restriction if needed
  IF v_tier = 'restriction' THEN
    INSERT INTO chat_restrictions (
      user_id,
      restriction_type,
      reason,
      expires_at
    ) VALUES (
      p_user_id,
      'templated_only',
      'Repeated policy violations',
      now() + interval '24 hours'
    );
  ELSIF v_tier = 'review' THEN
    INSERT INTO chat_restrictions (
      user_id,
      restriction_type,
      reason,
      requires_human_review
    ) VALUES (
      p_user_id,
      'suspended',
      'Multiple violations - account under review',
      true
    );
  END IF;
  
  RETURN v_violation_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.record_violation TO authenticated;

COMMENT ON FUNCTION public.record_violation IS 'Record user violation and apply progressive enforcement';

-- =====================================================
-- FUNCTION: update_preferred_mechanic
-- =====================================================
CREATE OR REPLACE FUNCTION public.update_preferred_mechanic(
  p_customer_id uuid,
  p_mechanic_id uuid,
  p_job_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_job_total_cents bigint;
  v_job_rating numeric;
  v_new_jobs_completed int;
  v_new_total_spent bigint;
  v_new_commission_tier int;
  v_old_commission_tier int;
BEGIN
  -- Get job details
  SELECT 
    total_cost_cents,
    (SELECT overall_rating FROM reviews WHERE job_id = p_job_id AND reviewee_id = p_mechanic_id LIMIT 1)
  INTO v_job_total_cents, v_job_rating
  FROM jobs
  WHERE id = p_job_id;
  
  -- Insert or update preferred mechanic relationship
  INSERT INTO preferred_mechanics (
    customer_id,
    mechanic_id,
    jobs_completed,
    total_spent_cents,
    avg_rating,
    last_job_at,
    commission_tier
  ) VALUES (
    p_customer_id,
    p_mechanic_id,
    1,
    v_job_total_cents,
    v_job_rating,
    now(),
    1
  )
  ON CONFLICT (customer_id, mechanic_id)
  DO UPDATE SET
    jobs_completed = preferred_mechanics.jobs_completed + 1,
    total_spent_cents = preferred_mechanics.total_spent_cents + v_job_total_cents,
    avg_rating = CASE 
      WHEN v_job_rating IS NOT NULL THEN
        (COALESCE(preferred_mechanics.avg_rating, 0) * preferred_mechanics.jobs_completed + v_job_rating) / (preferred_mechanics.jobs_completed + 1)
      ELSE
        preferred_mechanics.avg_rating
    END,
    last_job_at = now(),
    updated_at = now()
  RETURNING jobs_completed, total_spent_cents, commission_tier INTO v_new_jobs_completed, v_new_total_spent, v_old_commission_tier;
  
  -- Calculate new commission tier based on jobs completed
  v_new_commission_tier := CASE
    WHEN v_new_jobs_completed >= 10 THEN 5  -- 8% commission
    WHEN v_new_jobs_completed >= 4 THEN 4   -- 10% commission
    WHEN v_new_jobs_completed >= 2 THEN 3   -- 15% commission
    ELSE 1                                   -- 20% commission
  END;
  
  -- Update commission tier if changed
  IF v_new_commission_tier != v_old_commission_tier THEN
    UPDATE preferred_mechanics
    SET 
      commission_tier = v_new_commission_tier,
      priority_scheduling = v_new_jobs_completed >= 3
    WHERE customer_id = p_customer_id
      AND mechanic_id = p_mechanic_id;
  END IF;
  
  RETURN jsonb_build_object(
    'jobs_completed', v_new_jobs_completed,
    'total_spent_cents', v_new_total_spent,
    'commission_tier', v_new_commission_tier,
    'commission_rate', CASE v_new_commission_tier
      WHEN 5 THEN 0.08
      WHEN 4 THEN 0.10
      WHEN 3 THEN 0.15
      ELSE 0.20
    END,
    'tier_upgraded', v_new_commission_tier > v_old_commission_tier,
    'has_priority_scheduling', v_new_jobs_completed >= 3
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.update_preferred_mechanic TO authenticated;

COMMENT ON FUNCTION public.update_preferred_mechanic IS 'Update preferred mechanic relationship and commission tier after job completion';

-- =====================================================
-- FUNCTION: get_preferred_mechanics
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_preferred_mechanics(p_customer_id uuid DEFAULT NULL)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_customer_id uuid;
  v_result jsonb;
BEGIN
  v_customer_id := COALESCE(p_customer_id, auth.uid());
  
  IF v_customer_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'mechanic_id', pm.mechanic_id,
      'mechanic', jsonb_build_object(
        'id', p.id,
        'full_name', p.full_name,
        'avatar_url', p.avatar_url
      ),
      'jobs_completed', pm.jobs_completed,
      'total_spent_cents', pm.total_spent_cents,
      'avg_rating', pm.avg_rating,
      'last_job_at', pm.last_job_at,
      'commission_tier', pm.commission_tier,
      'commission_rate', CASE pm.commission_tier
        WHEN 5 THEN 0.08
        WHEN 4 THEN 0.10
        WHEN 3 THEN 0.15
        ELSE 0.20
      END,
      'has_priority_scheduling', pm.priority_scheduling
    ) ORDER BY pm.jobs_completed DESC, pm.last_job_at DESC
  ), '[]'::jsonb)
  INTO v_result
  FROM preferred_mechanics pm
  INNER JOIN profiles p ON p.id = pm.mechanic_id
  WHERE pm.customer_id = v_customer_id
    AND pm.is_active = true;
  
  RETURN v_result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_preferred_mechanics TO authenticated;

COMMENT ON FUNCTION public.get_preferred_mechanics IS 'Get list of preferred mechanics for customer with commission tiers';

-- =====================================================
-- FUNCTION: get_chat_status
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_chat_status(
  p_conversation_id uuid,
  p_job_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_job_status text;
  v_job_completed_at timestamptz;
  v_lifecycle record;
  v_restriction record;
  v_chat_state text;
  v_can_send boolean;
  v_restriction_message text;
BEGIN
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Get job status
  SELECT status, completed_at
  INTO v_job_status, v_job_completed_at
  FROM jobs
  WHERE id = p_job_id;
  
  -- Get lifecycle config
  SELECT * INTO v_lifecycle
  FROM chat_lifecycle_config
  WHERE conversation_id = p_conversation_id;
  
  -- Get active restriction
  SELECT * INTO v_restriction
  FROM chat_restrictions
  WHERE user_id = v_user_id
    AND (expires_at IS NULL OR expires_at > now())
  ORDER BY created_at DESC
  LIMIT 1;
  
  -- Determine chat state
  IF v_restriction.restriction_type = 'suspended' THEN
    v_chat_state := 'suspended';
    v_can_send := false;
    v_restriction_message := 'Your account is under review. Please contact support.';
  ELSIF v_restriction.restriction_type = 'templated_only' THEN
    v_chat_state := 'templated_only';
    v_can_send := false;
    v_restriction_message := 'Your chat access is temporarily limited. Please use quick action buttons.';
  ELSIF v_lifecycle.has_safety_issue OR v_lifecycle.has_dispute THEN
    v_chat_state := 'support_only';
    v_can_send := false;
    v_restriction_message := 'This conversation is being handled by support.';
  ELSIF v_job_status = 'completed' THEN
    IF v_job_completed_at + interval '48 hours' > now() THEN
      v_chat_state := 'post_completion_active';
      v_can_send := true;
      v_restriction_message := NULL;
    ELSIF v_job_completed_at + interval '30 days' > now() THEN
      v_chat_state := 'read_only';
      v_can_send := false;
      v_restriction_message := 'This conversation is now read-only. Use the Rebook button to work together again!';
    ELSE
      v_chat_state := 'archived';
      v_can_send := false;
      v_restriction_message := 'This conversation is archived. You can still view messages and file warranty claims.';
    END IF;
  ELSIF v_job_status IN ('booked', 'in_progress') THEN
    v_chat_state := 'active';
    v_can_send := true;
    v_restriction_message := NULL;
  ELSIF v_job_status IN ('lead', 'quote_submitted') THEN
    v_chat_state := 'pre_booking';
    v_can_send := true;
    v_restriction_message := NULL;
  ELSE
    v_chat_state := 'unknown';
    v_can_send := false;
    v_restriction_message := 'Unable to determine chat status.';
  END IF;
  
  RETURN jsonb_build_object(
    'chat_state', v_chat_state,
    'can_send_messages', v_can_send,
    'restriction_message', v_restriction_message,
    'job_status', v_job_status,
    'has_active_restriction', v_restriction.id IS NOT NULL,
    'restriction_expires_at', v_restriction.expires_at,
    'show_rebook_button', v_chat_state IN ('read_only', 'archived', 'post_completion_active'),
    'show_support_button', v_chat_state IN ('read_only', 'archived'),
    'show_warranty_button', v_chat_state IN ('read_only', 'archived')
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_chat_status TO authenticated;

COMMENT ON FUNCTION public.get_chat_status IS 'Get current chat status and restrictions for conversation';

COMMIT;
\n-- ===================================================================
-- END: 0048_chat_moderation_rpcs.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0049_support_phase1.sql
-- ===================================================================\n
-- =====================================================
-- PHASE 1: CUSTOMER SUPPORT SYSTEM
-- =====================================================

-- Create support_requests table
CREATE TABLE IF NOT EXISTS public.support_requests (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
  category text NOT NULL CHECK (category IN (
    'payments_refunds',
    'job_issue',
    'account_login',
    'bug_app_problem',
    'other'
  )),
  message text NOT NULL,
  job_id uuid NULL,
  screenshot_url text NULL,
  metadata jsonb NOT NULL DEFAULT '{}'::jsonb,
  status text NOT NULL DEFAULT 'open' CHECK (status IN ('open', 'resolved')),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_support_requests_user_id ON public.support_requests(user_id);
CREATE INDEX IF NOT EXISTS idx_support_requests_status ON public.support_requests(status);
CREATE INDEX IF NOT EXISTS idx_support_requests_created_at ON public.support_requests(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_support_requests_category ON public.support_requests(category);

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION public.update_support_requests_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_support_requests_updated_at ON public.support_requests;
CREATE TRIGGER trigger_support_requests_updated_at
  BEFORE UPDATE ON public.support_requests
  FOR EACH ROW
  EXECUTE FUNCTION public.update_support_requests_updated_at();

-- =====================================================
-- RLS POLICIES
-- =====================================================

ALTER TABLE public.support_requests ENABLE ROW LEVEL SECURITY;

-- Users can insert their own support requests
DROP POLICY IF EXISTS "Users can insert own support requests" ON public.support_requests;
CREATE POLICY "Users can insert own support requests"
  ON public.support_requests
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

-- Users can view their own support requests
DROP POLICY IF EXISTS "Users can view own support requests" ON public.support_requests;
CREATE POLICY "Users can view own support requests"
  ON public.support_requests
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

-- Only service role can update/delete (deny normal users)
DROP POLICY IF EXISTS "Service role can update support requests" ON public.support_requests;
CREATE POLICY "Service role can update support requests"
  ON public.support_requests
  FOR UPDATE
  TO service_role
  USING (true);

DROP POLICY IF EXISTS "Service role can delete support requests" ON public.support_requests;
CREATE POLICY "Service role can delete support requests"
  ON public.support_requests
  FOR DELETE
  TO service_role
  USING (true);

-- =====================================================
-- STORAGE BUCKET FOR SCREENSHOTS
-- =====================================================

-- Create support-screenshots bucket if it doesn't exist
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'support-screenshots',
  'support-screenshots',
  false,
  5242880, -- 5MB limit
  ARRAY['image/jpeg', 'image/jpg', 'image/png', 'image/webp']
)
ON CONFLICT (id) DO NOTHING;

-- Storage policies for support-screenshots bucket

-- Authenticated users can upload to their own folder
DROP POLICY IF EXISTS "Users can upload own screenshots" ON storage.objects;
CREATE POLICY "Users can upload own screenshots"
  ON storage.objects
  FOR INSERT
  TO authenticated
  WITH CHECK (
    bucket_id = 'support-screenshots' 
    AND (storage.foldername(name))[1] = auth.uid()::text
  );

-- Users can read their own screenshots
DROP POLICY IF EXISTS "Users can read own screenshots" ON storage.objects;
CREATE POLICY "Users can read own screenshots"
  ON storage.objects
  FOR SELECT
  TO authenticated
  USING (
    bucket_id = 'support-screenshots'
    AND (storage.foldername(name))[1] = auth.uid()::text
  );

-- Service role can read all screenshots
DROP POLICY IF EXISTS "Service role can read all screenshots" ON storage.objects;
CREATE POLICY "Service role can read all screenshots"
  ON storage.objects
  FOR SELECT
  TO service_role
  USING (bucket_id = 'support-screenshots');

-- =====================================================
-- HELPER FUNCTION: Get user's recent support requests
-- =====================================================

CREATE OR REPLACE FUNCTION public.get_user_support_requests(
  p_user_id uuid DEFAULT NULL,
  p_limit int DEFAULT 10
)
RETURNS TABLE (
  id uuid,
  category text,
  message text,
  job_id uuid,
  screenshot_url text,
  status text,
  created_at timestamptz
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    sr.id,
    sr.category,
    sr.message,
    sr.job_id,
    sr.screenshot_url,
    sr.status,
    sr.created_at
  FROM public.support_requests sr
  WHERE sr.user_id = COALESCE(p_user_id, auth.uid())
  ORDER BY sr.created_at DESC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION public.get_user_support_requests TO authenticated;

-- =====================================================
-- COMMENTS
-- =====================================================

COMMENT ON TABLE public.support_requests IS 'Phase 1 customer support requests';
COMMENT ON COLUMN public.support_requests.category IS 'Support request category: payments_refunds, job_issue, account_login, bug_app_problem, other';
COMMENT ON COLUMN public.support_requests.metadata IS 'JSON metadata: platform, app_version, device_model, role, etc.';
COMMENT ON COLUMN public.support_requests.status IS 'Request status: open or resolved';
\n-- ===================================================================
-- END: 0049_support_phase1.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0050_fix_quote_rejected_status.sql
-- ===================================================================\n
-- Fix: Change 'rejected' to 'declined' in accept_quote_and_create_contract
-- The quotes table CHECK constraint only allows: pending, accepted, declined, expired, withdrawn

BEGIN;

CREATE OR REPLACE FUNCTION accept_quote_and_create_contract(
  p_quote_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_quote RECORD;
  v_job RECORD;
  v_contract_id uuid;
  v_progress_id uuid;
  v_platform_fee_cents int := 1500;
  v_commission_cents int;
  v_total_customer_cents int;
  v_mechanic_payout_cents int;
  v_line_item_id uuid;
BEGIN
  SELECT q.*, j.customer_id as job_customer_id, j.status as job_status
  INTO v_quote
  FROM public.quotes q
  JOIN public.jobs j ON j.id = q.job_id
  WHERE q.id = p_quote_id
  FOR UPDATE OF q, j;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote not found');
  END IF;
  
  IF v_quote.job_customer_id != p_customer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  IF v_quote.status != 'pending' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote is no longer available');
  END IF;
  
  IF v_quote.job_status NOT IN ('searching', 'quoted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job is no longer accepting quotes');
  END IF;
  
  v_commission_cents := calculate_mechanic_commission(v_quote.price_cents);
  v_total_customer_cents := v_quote.price_cents + v_platform_fee_cents;
  v_mechanic_payout_cents := v_quote.price_cents - v_commission_cents;
  
  INSERT INTO public.job_contracts (
    job_id, quote_id, customer_id, mechanic_id,
    status, quoted_price_cents, platform_fee_cents, estimated_hours,
    subtotal_cents, total_customer_cents, mechanic_commission_cents, mechanic_payout_cents
  ) VALUES (
    v_quote.job_id, p_quote_id, p_customer_id, v_quote.mechanic_id,
    'active', v_quote.price_cents, v_platform_fee_cents, v_quote.estimated_hours,
    v_quote.price_cents, v_total_customer_cents, v_commission_cents, v_mechanic_payout_cents
  )
  RETURNING id INTO v_contract_id;
  
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'base_labor', 'Service as quoted', 1, v_quote.price_cents, v_quote.price_cents,
    'approved', false, v_quote.mechanic_id, 'mechanic', 0
  )
  RETURNING id INTO v_line_item_id;
  
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'platform_fee', 'WrenchGo platform fee', 1, v_platform_fee_cents, v_platform_fee_cents,
    'approved', false, p_customer_id, 'customer', 100
  );
  
  INSERT INTO public.job_progress (job_id, contract_id)
  VALUES (v_quote.job_id, v_contract_id)
  RETURNING id INTO v_progress_id;
  
  UPDATE public.quotes
  SET status = 'accepted', updated_at = now()
  WHERE id = p_quote_id;
  
  -- Use 'declined' instead of 'rejected' to match CHECK constraint
  UPDATE public.quotes
  SET status = 'declined', updated_at = now()
  WHERE job_id = v_quote.job_id AND id != p_quote_id AND status = 'pending';
  
  UPDATE public.jobs
  SET 
    status = 'accepted',
    accepted_mechanic_id = v_quote.mechanic_id,
    updated_at = now()
  WHERE id = v_quote.job_id;
  
  PERFORM log_job_event(
    v_quote.job_id, v_contract_id, 'contract_created',
    p_customer_id, 'customer',
    'Contract created',
    'Quote accepted and contract created',
    jsonb_build_object(
      'quoted_price_cents', v_quote.price_cents,
      'platform_fee_cents', v_platform_fee_cents,
      'total_cents', v_total_customer_cents
    ),
    v_total_customer_cents
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'contract_id', v_contract_id,
    'total_cents', v_total_customer_cents,
    'mechanic_id', v_quote.mechanic_id
  );
END;
$$;

COMMIT;\n-- ===================================================================
-- END: 0050_fix_quote_rejected_status.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0051_add_payout_method_status.sql
-- ===================================================================\n
-- Migration: Add payout_method_status to profiles for mechanics
-- Similar to payment_method_status for customers

-- ENUM: payout_method_status (reuse payment_method_status enum values)
DO $$ BEGIN
  CREATE TYPE public.payout_method_status AS ENUM (
    'none',
    'pending',
    'active',
    'failed'
  );
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

-- ADD payout_method_status TO profiles
ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS payout_method_status public.payout_method_status DEFAULT 'none' NOT NULL;

-- FUNCTION: Update payout_method_status when mechanic_stripe_accounts changes
CREATE OR REPLACE FUNCTION public.sync_payout_method_status()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
    IF NEW.onboarding_complete = true AND NEW.payouts_enabled = true AND NEW.deleted_at IS NULL THEN
      UPDATE public.profiles
      SET payout_method_status = 'active'
      WHERE id = NEW.mechanic_id;
    ELSIF NEW.onboarding_complete = true AND NEW.payouts_enabled = false THEN
      UPDATE public.profiles
      SET payout_method_status = 'pending'
      WHERE id = NEW.mechanic_id;
    ELSIF NEW.deleted_at IS NOT NULL THEN
      UPDATE public.profiles
      SET payout_method_status = 'none'
      WHERE id = NEW.mechanic_id;
    END IF;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.profiles
    SET payout_method_status = 'none'
    WHERE id = OLD.mechanic_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- TRIGGER: sync payout status on mechanic_stripe_accounts changes
DROP TRIGGER IF EXISTS sync_payout_method_status_trigger ON public.mechanic_stripe_accounts;
CREATE TRIGGER sync_payout_method_status_trigger
  AFTER INSERT OR UPDATE OR DELETE ON public.mechanic_stripe_accounts
  FOR EACH ROW EXECUTE FUNCTION public.sync_payout_method_status();

-- Backfill existing mechanic_stripe_accounts
UPDATE public.profiles p
SET payout_method_status = 'active'
FROM public.mechanic_stripe_accounts msa
WHERE msa.mechanic_id = p.id
  AND msa.onboarding_complete = true
  AND msa.payouts_enabled = true
  AND msa.deleted_at IS NULL;

UPDATE public.profiles p
SET payout_method_status = 'pending'
FROM public.mechanic_stripe_accounts msa
WHERE msa.mechanic_id = p.id
  AND msa.onboarding_complete = true
  AND msa.payouts_enabled = false
  AND msa.deleted_at IS NULL
  AND p.payout_method_status = 'none';
\n-- ===================================================================
-- END: 0051_add_payout_method_status.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0052_fix_log_message_audit_mechanic_id.sql
-- ===================================================================\n
-- Fix log_message_audit function: j.mechanic_id -> j.accepted_mechanic_id

CREATE OR REPLACE FUNCTION public.log_message_audit(
  p_message_id uuid,
  p_conversation_id uuid,
  p_recipient_id uuid,
  p_original_content text,
  p_displayed_content text,
  p_action text,
  p_risk_result jsonb,
  p_job_id uuid DEFAULT NULL
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_sender_id uuid;
  v_audit_id uuid;
  v_sender_age_days int;
  v_completed_jobs int;
  v_recent_violations int;
  v_job_stage text;
  v_patterns text[];
BEGIN
  v_sender_id := auth.uid();

  IF v_sender_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Parse patterns from JSONB array to text[]
  SELECT COALESCE(array_agg(elem::text), '{}')
  INTO v_patterns
  FROM jsonb_array_elements_text(COALESCE(p_risk_result->'patterns_detected', '[]'::jsonb)) AS elem;

  -- Get sender context
  SELECT
    EXTRACT(DAY FROM (now() - p.created_at))::int,
    COALESCE(COUNT(DISTINCT j.id), 0)
  INTO v_sender_age_days, v_completed_jobs
  FROM profiles p
  LEFT JOIN jobs j ON (j.customer_id = p.id OR j.accepted_mechanic_id = p.id)
    AND j.status = 'completed'
  WHERE p.id = v_sender_id
  GROUP BY p.created_at;

  -- Get recent violations
  SELECT COUNT(*)::int INTO v_recent_violations
  FROM user_violations
  WHERE user_id = v_sender_id
    AND created_at > now() - interval '30 days';

  -- Get job stage
  IF p_job_id IS NOT NULL THEN
    SELECT status INTO v_job_stage FROM jobs WHERE id = p_job_id;
  END IF;

  -- Insert audit log
  INSERT INTO message_audit_logs (
    message_id,
    conversation_id,
    sender_id,
    recipient_id,
    original_content,
    displayed_content,
    patterns_detected,
    risk_score,
    action_taken,
    job_id,
    job_stage,
    sender_account_age_days,
    sender_completed_jobs,
    sender_previous_violations,
    flagged_for_review
  ) VALUES (
    p_message_id,
    p_conversation_id,
    v_sender_id,
    p_recipient_id,
    p_original_content,
    p_displayed_content,
    v_patterns,
    COALESCE((p_risk_result->>'risk_score')::numeric, 0),
    p_action::message_action,
    p_job_id,
    v_job_stage,
    COALESCE(v_sender_age_days, 0),
    COALESCE(v_completed_jobs, 0),
    COALESCE(v_recent_violations, 0),
    COALESCE((p_risk_result->>'risk_score')::numeric, 0) >= 70
  )
  RETURNING id INTO v_audit_id;

  RETURN v_audit_id;
END;
$$;\n-- ===================================================================
-- END: 0052_fix_log_message_audit_mechanic_id.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0053_fix_log_message_audit_patterns.sql
-- ===================================================================\n
-- Fix log_message_audit function: j.mechanic_id -> j.accepted_mechanic_id

CREATE OR REPLACE FUNCTION public.log_message_audit(
  p_message_id uuid,
  p_conversation_id uuid,
  p_recipient_id uuid,
  p_original_content text,
  p_displayed_content text,
  p_action text,
  p_risk_result jsonb,
  p_job_id uuid DEFAULT NULL
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_sender_id uuid;
  v_audit_id uuid;
  v_sender_age_days int;
  v_completed_jobs int;
  v_recent_violations int;
  v_job_stage text;
  v_patterns text[];
BEGIN
  v_sender_id := auth.uid();

  IF v_sender_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Parse patterns from JSONB array to text[]
  SELECT COALESCE(array_agg(elem::text), '{}')
  INTO v_patterns
  FROM jsonb_array_elements_text(COALESCE(p_risk_result->'patterns_detected', '[]'::jsonb)) AS elem;

  -- Get sender context
  SELECT
    EXTRACT(DAY FROM (now() - p.created_at))::int,
    COALESCE(COUNT(DISTINCT j.id), 0)
  INTO v_sender_age_days, v_completed_jobs
  FROM profiles p
  LEFT JOIN jobs j ON (j.customer_id = p.id OR j.accepted_mechanic_id = p.id)
    AND j.status = 'completed'
  WHERE p.id = v_sender_id
  GROUP BY p.created_at;

  -- Get recent violations
  SELECT COUNT(*)::int INTO v_recent_violations
  FROM user_violations
  WHERE user_id = v_sender_id
    AND created_at > now() - interval '30 days';

  -- Get job stage
  IF p_job_id IS NOT NULL THEN
    SELECT status INTO v_job_stage FROM jobs WHERE id = p_job_id;
  END IF;

  -- Insert audit log
  INSERT INTO message_audit_logs (
    message_id,
    conversation_id,
    sender_id,
    recipient_id,
    original_content,
    displayed_content,
    patterns_detected,
    risk_score,
    action_taken,
    job_id,
    job_stage,
    sender_account_age_days,
    sender_completed_jobs,
    sender_previous_violations,
    flagged_for_review
  ) VALUES (
    p_message_id,
    p_conversation_id,
    v_sender_id,
    p_recipient_id,
    p_original_content,
    p_displayed_content,
    v_patterns,
    COALESCE((p_risk_result->>'risk_score')::numeric, 0),
    p_action::message_action,
    p_job_id,
    v_job_stage,
    COALESCE(v_sender_age_days, 0),
    COALESCE(v_completed_jobs, 0),
    COALESCE(v_recent_violations, 0),
    COALESCE((p_risk_result->>'risk_score')::numeric, 0) >= 70
  )
  RETURNING id INTO v_audit_id;

  RETURN v_audit_id;
END;
$$;\n-- ===================================================================
-- END: 0053_fix_log_message_audit_patterns.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0054_fix_job_stage_values.sql
-- ===================================================================\n
-- Fix job stage values in moderation functions to match actual job statuses

-- Fix calculate_message_risk
CREATE OR REPLACE FUNCTION public.calculate_message_risk(
  p_message_text text,
  p_sender_id uuid,
  p_job_id uuid,
  p_job_stage text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_detection_result jsonb;
  v_is_legitimate boolean;
  v_sender_age_days int;
  v_completed_jobs int;
  v_recent_violations int;
  v_final_risk_score numeric;
  v_action public.message_action;
  v_restriction_level text;
BEGIN
  v_detection_result := detect_contact_info(p_message_text);
  v_is_legitimate := check_legitimate_patterns(p_message_text);
  
  IF v_is_legitimate THEN
    RETURN jsonb_build_object(
      'risk_level', 'low',
      'risk_score', 0,
      'action', 'allowed',
      'patterns_detected', '{}',
      'reason', 'legitimate_pattern'
    );
  END IF;
  
  IF NOT (v_detection_result->>'has_contact_info')::boolean THEN
    RETURN jsonb_build_object(
      'risk_level', 'low',
      'risk_score', 0,
      'action', 'allowed',
      'patterns_detected', '{}',
      'reason', 'no_contact_info'
    );
  END IF;
  
  SELECT
    EXTRACT(DAY FROM (now() - p.created_at))::int,
    COALESCE(COUNT(DISTINCT j.id), 0)
  INTO v_sender_age_days, v_completed_jobs
  FROM profiles p
  LEFT JOIN jobs j ON (j.customer_id = p.id OR j.accepted_mechanic_id = p.id)
    AND j.status = 'completed'
  WHERE p.id = p_sender_id
  GROUP BY p.created_at;
  
  SELECT COUNT(*)::int
  INTO v_recent_violations
  FROM user_violations
  WHERE user_id = p_sender_id
    AND created_at > now() - interval '30 days';
  
  v_final_risk_score := (v_detection_result->>'risk_score')::numeric;
  
  IF v_sender_age_days < 7 THEN
    v_final_risk_score := v_final_risk_score + 15;
  END IF;
  
  IF v_completed_jobs = 0 THEN
    v_final_risk_score := v_final_risk_score + 10;
  ELSIF v_completed_jobs >= 10 THEN
    v_final_risk_score := v_final_risk_score - 15;
  END IF;
  
  IF v_recent_violations > 0 THEN
    v_final_risk_score := v_final_risk_score + (v_recent_violations * 10);
  END IF;
  
  -- Use actual job statuses: searching, quoted, accepted, work_in_progress, completed, canceled
  IF p_job_stage IN ('searching', 'quoted') THEN
    v_final_risk_score := v_final_risk_score + 20;
  ELSIF p_job_stage IN ('accepted', 'work_in_progress') THEN
    v_final_risk_score := v_final_risk_score - 20;
  ELSIF p_job_stage = 'completed' THEN
    v_final_risk_score := v_final_risk_score + 10;
  END IF;
  
  v_final_risk_score := LEAST(v_final_risk_score, 100);
  
  IF v_final_risk_score >= 70 THEN
    IF p_job_stage IN ('searching', 'quoted') THEN
      v_action := 'blocked';
      v_restriction_level := 'high';
    ELSE
      v_action := 'warned';
      v_restriction_level := 'medium';
    END IF;
  ELSIF v_final_risk_score >= 40 THEN
    IF p_job_stage IN ('searching', 'quoted') THEN
      v_action := 'blocked';
      v_restriction_level := 'medium';
    ELSIF p_job_stage = 'completed' THEN
      v_action := 'masked';
      v_restriction_level := 'medium';
    ELSE
      v_action := 'warned';
      v_restriction_level := 'low';
    END IF;
  ELSE
    v_action := 'allowed';
    v_restriction_level := 'low';
  END IF;
  
  RETURN jsonb_build_object(
    'risk_level', v_restriction_level,
    'risk_score', v_final_risk_score,
    'action', v_action,
    'patterns_detected', v_detection_result->'patterns_detected',
    'sender_context', jsonb_build_object(
      'account_age_days', v_sender_age_days,
      'completed_jobs', v_completed_jobs,
      'recent_violations', v_recent_violations
    ),
    'job_stage', p_job_stage
  );
END;
$$;

-- Fix scan_message_before_send
CREATE OR REPLACE FUNCTION public.scan_message_before_send(
  p_message_text text,
  p_recipient_id uuid,
  p_job_id uuid DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_sender_id uuid;
  v_job_stage text;
  v_risk_result jsonb;
  v_active_restriction record;
  v_masked_content text;
BEGIN
  v_sender_id := auth.uid();
  
  IF v_sender_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  SELECT * INTO v_active_restriction
  FROM chat_restrictions
  WHERE user_id = v_sender_id
    AND (expires_at IS NULL OR expires_at > now())
  ORDER BY created_at DESC
  LIMIT 1;
  
  IF v_active_restriction.restriction_type = 'suspended' THEN
    RETURN jsonb_build_object(
      'allowed', false,
      'action', 'blocked',
      'reason', 'account_suspended',
      'message', 'Your account is under review. Please contact support.',
      'requires_human_review', true
    );
  END IF;
  
  IF v_active_restriction.restriction_type = 'templated_only' THEN
    RETURN jsonb_build_object(
      'allowed', false,
      'action', 'blocked',
      'reason', 'templated_only',
      'message', 'Your chat access is temporarily limited. Please use quick action buttons.',
      'restriction_expires_at', v_active_restriction.expires_at
    );
  END IF;
  
  IF p_job_id IS NOT NULL THEN
    SELECT status INTO v_job_stage
    FROM jobs
    WHERE id = p_job_id;
  END IF;
  
  v_risk_result := calculate_message_risk(
    p_message_text,
    v_sender_id,
    p_job_id,
    COALESCE(v_job_stage, 'unknown')
  );
  
  CASE (v_risk_result->>'action')::message_action
    WHEN 'blocked' THEN
      RETURN jsonb_build_object(
        'allowed', false,
        'action', 'blocked',
        'reason', 'contact_info_detected',
        'risk_score', v_risk_result->'risk_score',
        'patterns_detected', v_risk_result->'patterns_detected',
        'message', CASE 
          WHEN v_job_stage IN ('searching', 'quoted') THEN
            'For your protection, please keep all communication in WrenchGo until the job is booked. This ensures payment protection, job history, and support if anything goes wrong.'
          ELSE
            'We detected contact information in your message. For warranty coverage and payment protection, keep future bookings through WrenchGo.'
        END,
        'show_rebook_button', v_job_stage = 'completed'
      );
      
    WHEN 'masked' THEN
      v_masked_content := p_message_text;
      v_masked_content := regexp_replace(v_masked_content, '(\+?1[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}', '[Contact Hidden]', 'g');
      v_masked_content := regexp_replace(v_masked_content, '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}', '[Email Hidden]', 'g');
      
      RETURN jsonb_build_object(
        'allowed', true,
        'action', 'masked',
        'original_content', p_message_text,
        'masked_content', v_masked_content,
        'risk_score', v_risk_result->'risk_score',
        'patterns_detected', v_risk_result->'patterns_detected',
        'message', 'Contact info has been hidden. Use the Rebook button to work with this person again!',
        'show_rebook_button', true
      );
      
    WHEN 'warned' THEN
      RETURN jsonb_build_object(
        'allowed', true,
        'action', 'warned',
        'risk_score', v_risk_result->'risk_score',
        'patterns_detected', v_risk_result->'patterns_detected',
        'warning_message', 'Sharing contact info? For warranty coverage and payment protection, keep future bookings through WrenchGo.',
        'show_soft_warning', true
      );
      
    ELSE
      RETURN jsonb_build_object(
        'allowed', true,
        'action', 'allowed',
        'risk_score', v_risk_result->'risk_score'
      );
  END CASE;
END;
$$;\n-- ===================================================================
-- END: 0054_fix_job_stage_values.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0055_fix_phone_detection.sql
-- ===================================================================\n
-- Fix phone number detection to catch plain 10-digit numbers

CREATE OR REPLACE FUNCTION public.detect_contact_info(message_text text)
RETURNS jsonb
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  patterns_found text[] := '{}';
  risk_score numeric := 0;
BEGIN
  -- Phone number patterns - including plain 10-digit numbers
  IF message_text ~* '(\+?1[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}' 
     OR message_text ~* '\b\d{10}\b' THEN
    patterns_found := array_append(patterns_found, 'phone');
    risk_score := risk_score + 30;
  END IF;
  
  -- Email patterns
  IF message_text ~* '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}' THEN
    patterns_found := array_append(patterns_found, 'email');
    risk_score := risk_score + 30;
  END IF;
  
  -- Social media patterns
  IF message_text ~* '(instagram|facebook|whatsapp|telegram|snapchat|twitter|tiktok)[\s:@]?[\w.]+' THEN
    patterns_found := array_append(patterns_found, 'social');
    risk_score := risk_score + 25;
  END IF;
  
  -- URL patterns
  IF message_text ~* '(https?://|www\.)[^\s]+' THEN
    patterns_found := array_append(patterns_found, 'url');
    risk_score := risk_score + 20;
  END IF;
  
  -- Obfuscation patterns - spaced digits
  IF message_text ~* '\d[\s.]{1,3}\d[\s.]{1,3}\d[\s.]{1,3}\d[\s.]{1,3}\d' THEN
    patterns_found := array_append(patterns_found, 'obfuscated_phone');
    risk_score := risk_score + 40;
  END IF;
  
  -- Obfuscation patterns - word numbers
  IF message_text ~* '(zero|one|two|three|four|five|six|seven|eight|nine)[\s-]+(zero|one|two|three|four|five|six|seven|eight|nine)' THEN
    patterns_found := array_append(patterns_found, 'obfuscated_numbers');
    risk_score := risk_score + 35;
  END IF;
  
  -- Obfuscation patterns - at/dot
  IF message_text ~* '(\bat\b|\[at\]|\(at\)).*(\bdot\b|\[dot\]|\(dot\))' THEN
    patterns_found := array_append(patterns_found, 'obfuscated_email');
    risk_score := risk_score + 35;
  END IF;
  
  RETURN jsonb_build_object(
    'patterns_detected', patterns_found,
    'risk_score', LEAST(risk_score, 100),
    'has_contact_info', array_length(patterns_found, 1) > 0
  );
END;
$$;\n-- ===================================================================
-- END: 0055_fix_phone_detection.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0056_fix_phone_detection_v2.sql
-- ===================================================================\n
-- Fix phone number detection - add 7+ digit detection

CREATE OR REPLACE FUNCTION public.detect_contact_info(message_text text)
RETURNS jsonb
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  patterns_found text[] := '{}';
  risk_score numeric := 0;
BEGIN
  -- Phone number patterns - 7+ consecutive digits or formatted numbers
  IF message_text ~* '\d{7,}' 
     OR message_text ~* '(\+?1[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}' THEN
    patterns_found := array_append(patterns_found, 'phone');
    risk_score := risk_score + 40;
  END IF;
  
  -- Email patterns
  IF message_text ~* '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}' THEN
    patterns_found := array_append(patterns_found, 'email');
    risk_score := risk_score + 40;
  END IF;
  
  -- Social media patterns
  IF message_text ~* '(instagram|facebook|whatsapp|telegram|snapchat|twitter|tiktok)[\s:@]?[\w.]+' THEN
    patterns_found := array_append(patterns_found, 'social');
    risk_score := risk_score + 35;
  END IF;
  
  -- URL patterns
  IF message_text ~* '(https?://|www\.)[^\s]+' THEN
    patterns_found := array_append(patterns_found, 'url');
    risk_score := risk_score + 30;
  END IF;
  
  -- Obfuscation patterns - spaced digits
  IF message_text ~* '\d[\s.]{1,3}\d[\s.]{1,3}\d[\s.]{1,3}\d[\s.]{1,3}\d' THEN
    patterns_found := array_append(patterns_found, 'obfuscated_phone');
    risk_score := risk_score + 50;
  END IF;
  
  -- Obfuscation patterns - word numbers
  IF message_text ~* '(zero|one|two|three|four|five|six|seven|eight|nine)[\s-]+(zero|one|two|three|four|five|six|seven|eight|nine)' THEN
    patterns_found := array_append(patterns_found, 'obfuscated_numbers');
    risk_score := risk_score + 45;
  END IF;
  
  -- Obfuscation patterns - at/dot
  IF message_text ~* '(\bat\b|\[at\]|\(at\)).*(\bdot\b|\[dot\]|\(dot\))' THEN
    patterns_found := array_append(patterns_found, 'obfuscated_email');
    risk_score := risk_score + 45;
  END IF;
  
  RETURN jsonb_build_object(
    'patterns_detected', patterns_found,
    'risk_score', LEAST(risk_score, 100),
    'has_contact_info', array_length(patterns_found, 1) > 0
  );
END;
$$;\n-- ===================================================================
-- END: 0056_fix_phone_detection_v2.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0057_always_block_contact_info.sql
-- ===================================================================\n
-- Block contact info at all job stages

CREATE OR REPLACE FUNCTION public.calculate_message_risk(
  p_message_text text,
  p_sender_id uuid,
  p_job_id uuid,
  p_job_stage text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_detection_result jsonb;
  v_is_legitimate boolean;
  v_sender_age_days int;
  v_completed_jobs int;
  v_recent_violations int;
  v_final_risk_score numeric;
  v_action public.message_action;
  v_restriction_level text;
BEGIN
  v_detection_result := detect_contact_info(p_message_text);
  v_is_legitimate := check_legitimate_patterns(p_message_text);
  
  IF v_is_legitimate THEN
    RETURN jsonb_build_object(
      'risk_level', 'low',
      'risk_score', 0,
      'action', 'allowed',
      'patterns_detected', '{}',
      'reason', 'legitimate_pattern'
    );
  END IF;
  
  IF NOT (v_detection_result->>'has_contact_info')::boolean THEN
    RETURN jsonb_build_object(
      'risk_level', 'low',
      'risk_score', 0,
      'action', 'allowed',
      'patterns_detected', '{}',
      'reason', 'no_contact_info'
    );
  END IF;
  
  v_final_risk_score := (v_detection_result->>'risk_score')::numeric;
  
  -- Contact info detected = always block
  IF v_final_risk_score >= 30 THEN
    v_action := 'blocked';
    v_restriction_level := 'high';
  ELSE
    v_action := 'allowed';
    v_restriction_level := 'low';
  END IF;
  
  RETURN jsonb_build_object(
    'risk_level', v_restriction_level,
    'risk_score', v_final_risk_score,
    'action', v_action,
    'patterns_detected', v_detection_result->'patterns_detected',
    'job_stage', p_job_stage
  );
END;
$$;\n-- ===================================================================
-- END: 0057_always_block_contact_info.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0060_postgis_service_areas.sql
-- ===================================================================\n
-- Migration: Add PostGIS geography columns for spatial queries
-- Purpose: Secure location enforcement, performant distance queries

-- 1. Enable PostGIS in extensions schema (Supabase requirement)
CREATE EXTENSION IF NOT EXISTS postgis WITH SCHEMA extensions;

-- Set search path to include extensions for PostGIS types
SET search_path TO public, extensions;

-- 2. Add geography columns to jobs table
ALTER TABLE public.jobs 
ADD COLUMN IF NOT EXISTS location_geo geography(Point, 4326);

-- 3. Backfill geography column from existing lat/lng on jobs
UPDATE public.jobs
SET location_geo = ST_SetSRID(ST_MakePoint(location_lng, location_lat), 4326)::extensions.geography
WHERE location_lat IS NOT NULL 
  AND location_lng IS NOT NULL 
  AND location_geo IS NULL;

-- 4. Create trigger to auto-populate geography on insert/update for jobs
CREATE OR REPLACE FUNCTION sync_job_location_geo()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.location_lat IS NOT NULL AND NEW.location_lng IS NOT NULL THEN
    NEW.location_geo := ST_SetSRID(ST_MakePoint(NEW.location_lng, NEW.location_lat), 4326)::extensions.geography;
  ELSE
    NEW.location_geo := NULL;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_job_location_geo ON public.jobs;
CREATE TRIGGER trg_sync_job_location_geo
  BEFORE INSERT OR UPDATE OF location_lat, location_lng ON public.jobs
  FOR EACH ROW EXECUTE FUNCTION sync_job_location_geo();

-- 5. Create GIST index for fast spatial queries on jobs
CREATE INDEX IF NOT EXISTS idx_jobs_location_geo ON public.jobs USING GIST (location_geo);

-- 6. Composite index for jobs filtering
CREATE INDEX IF NOT EXISTS idx_jobs_status_deleted ON public.jobs (status, deleted_at) 
WHERE deleted_at IS NULL;

COMMENT ON COLUMN public.jobs.location_geo IS 'PostGIS geography point for spatial queries';
\n-- ===================================================================
-- END: 0060_postgis_service_areas.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0061_hardened_get_mechanic_leads.sql
-- ===================================================================\n
-- Migration: Hardened get_mechanic_leads with PostGIS and service area enforcement
-- Replaces client-trusted location with DB-enforced mechanic location

SET search_path TO public, extensions;

-- Drop and recreate the function with security hardening
DROP FUNCTION IF EXISTS public.get_mechanic_leads(uuid, text, numeric, numeric, numeric, integer, integer, text);

CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text DEFAULT 'all',
  p_mechanic_lat numeric DEFAULT NULL,
  p_mechanic_lng numeric DEFAULT NULL,
  p_radius_miles numeric DEFAULT 25,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  created_at timestamptz,
  preferred_time text,
  location_address text,
  latitude numeric,
  longitude numeric,
  distance_miles numeric,
  customer_id uuid,
  customer_name text,
  customer_photo_url text,
  customer_rating numeric,
  customer_review_count bigint,
  vehicle_id uuid,
  vehicle_year integer,
  vehicle_make text,
  vehicle_model text,
  has_quoted boolean,
  quote_id uuid,
  quote_amount integer,
  quote_status text,
  quote_created_at timestamptz,
  is_new boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, extensions
AS $$
DECLARE
  v_mechanic_geo geography;
  v_effective_radius_meters numeric;
  v_has_active_hub boolean;
BEGIN
  -- ===========================================
  -- Build mechanic geography from provided lat/lng
  -- (In future: fetch from mechanic_profiles.location_geo)
  -- ===========================================
  IF p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL THEN
    v_mechanic_geo := ST_SetSRID(ST_MakePoint(p_mechanic_lng, p_mechanic_lat), 4326)::extensions.geography;
  ELSE
    RETURN;
  END IF;

  -- ===========================================
  -- SERVICE AREA CHECK: Mechanic must be in an active hub
  -- Uses service_hubs.location (geography) and active_radius_miles
  -- ===========================================
  SELECT EXISTS(
    SELECT 1 FROM service_hubs sh
    WHERE sh.is_active = true
      AND ST_DWithin(v_mechanic_geo, sh.location, sh.active_radius_miles * 1609.34)
  ) INTO v_has_active_hub;

  IF NOT v_has_active_hub THEN
    RETURN;
  END IF;

  -- ===========================================
  -- RADIUS CALCULATION
  -- ===========================================
  IF p_filter = 'nearby' THEN
    v_effective_radius_meters := 5 * 1609.34;
  ELSE
    v_effective_radius_meters := LEAST(p_radius_miles, 50) * 1609.34;
  END IF;

  -- ===========================================
  -- MAIN QUERY with PostGIS spatial filtering
  -- ===========================================
  RETURN QUERY
  WITH mechanic_quote AS (
    SELECT 
      q.job_id,
      q.id AS quote_id,
      q.price_cents,
      q.status::text AS quote_status,
      q.created_at AS quote_created_at
    FROM quotes q
    WHERE q.mechanic_id = p_mechanic_id
  )
  SELECT
    j.id AS job_id,
    j.title,
    j.description,
    j.status::text,
    j.created_at,
    j.preferred_time,
    j.location_address,
    j.location_lat::numeric AS latitude,
    j.location_lng::numeric AS longitude,
    (ST_Distance(v_mechanic_geo, j.location_geo) / 1609.34)::numeric AS distance_miles,
    p.id AS customer_id,
    p.full_name AS customer_name,
    p.avatar_url AS customer_photo_url,
    COALESCE(cr.avg_rating, 0)::numeric AS customer_rating,
    COALESCE(cr.review_count, 0)::bigint AS customer_review_count,
    j.vehicle_id,
    v.year AS vehicle_year,
    v.make AS vehicle_make,
    v.model AS vehicle_model,
    (mq.quote_id IS NOT NULL) AS has_quoted,
    mq.quote_id,
    mq.price_cents AS quote_amount,
    mq.quote_status,
    mq.quote_created_at,
    (j.created_at > NOW() - INTERVAL '24 hours') AS is_new
  FROM jobs j
  INNER JOIN profiles p ON p.id = j.customer_id
  LEFT JOIN vehicles v ON v.id = j.vehicle_id
  LEFT JOIN mechanic_quote mq ON mq.job_id = j.id
  LEFT JOIN LATERAL (
    SELECT 
      AVG(r.overall_rating) AS avg_rating,
      COUNT(*) AS review_count
    FROM reviews r
    WHERE r.reviewee_id = p.id
      AND r.is_hidden = false
      AND r.deleted_at IS NULL
  ) cr ON true
  WHERE
    j.deleted_at IS NULL
    AND p.deleted_at IS NULL
    AND j.location_geo IS NOT NULL
    -- SERVICE AREA: Job must be in an active hub
    AND EXISTS(
      SELECT 1 FROM service_hubs sh
      WHERE sh.is_active = true
        AND ST_DWithin(j.location_geo, sh.location, sh.active_radius_miles * 1609.34)
    )
    -- DISTANCE: Job within mechanic's effective radius
    AND ST_DWithin(v_mechanic_geo, j.location_geo, v_effective_radius_meters)
    -- FILTER LOGIC
    AND (
      CASE p_filter
        WHEN 'all' THEN j.status IN ('searching', 'quoted')
        WHEN 'nearby' THEN j.status IN ('searching', 'quoted')
        WHEN 'quoted' THEN mq.quote_id IS NOT NULL
        ELSE j.status IN ('searching', 'quoted')
      END
    )
  ORDER BY
    CASE WHEN p_sort_by = 'newest' THEN j.created_at END DESC NULLS LAST,
    CASE WHEN p_sort_by = 'closest' THEN ST_Distance(v_mechanic_geo, j.location_geo) END ASC NULLS LAST,
    j.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads TO authenticated;

COMMENT ON FUNCTION public.get_mechanic_leads IS 
'Returns jobs visible to a mechanic within active service hubs. Uses PostGIS for performance.';
\n-- ===================================================================
-- END: 0061_hardened_get_mechanic_leads.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0062_properly_hardened_get_mechanic_leads.sql
-- ===================================================================\n
-- Migration 0062: Properly Hardened get_mechanic_leads
--
-- SECURITY CHANGES:
-- 1. Mechanic location is ALWAYS fetched from profiles (home_lat/home_lng) - NOT client input
-- 2. Client-provided lat/lng is IGNORED for eligibility - only used for display fallback
-- 3. Mechanics without stored location get empty results (fail-secure)
-- 4. Jobs without valid location_geo are excluded
-- 5. Both mechanic AND job must be within an active service hub
--
-- PERFORMANCE CHANGES:
-- 1. Uses PostGIS ST_DWithin for indexed spatial queries
-- 2. Single EXISTS subquery for service hub validation
-- 3. CTE for customer ratings (avoids correlated subquery per row)
--
-- COLUMN MAPPING:
-- - App uses: profiles.home_lat, profiles.home_lng
-- - Jobs use: jobs.location_geo (from location_lat/location_lng via trigger)
-- - Service hubs use: service_hubs.location (generated from lat/lng)

SET search_path TO public, extensions;

-- Drop existing function to replace signature
DROP FUNCTION IF EXISTS public.get_mechanic_leads(uuid, text, numeric, numeric, numeric, integer, integer, text);

CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text DEFAULT 'all',
  p_mechanic_lat numeric DEFAULT NULL,  -- IGNORED for eligibility, kept for API compat
  p_mechanic_lng numeric DEFAULT NULL,  -- IGNORED for eligibility, kept for API compat
  p_radius_miles numeric DEFAULT 25,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  created_at timestamptz,
  preferred_time text,
  location_address text,
  latitude numeric,
  longitude numeric,
  distance_miles numeric,
  customer_id uuid,
  customer_name text,
  customer_photo_url text,
  customer_rating numeric,
  customer_review_count bigint,
  vehicle_id uuid,
  vehicle_year integer,
  vehicle_make text,
  vehicle_model text,
  has_quoted boolean,
  quote_id uuid,
  quote_amount integer,
  quote_status text,
  quote_created_at timestamptz,
  is_new boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, extensions
STABLE
AS $$
DECLARE
  v_mechanic_geo geography;
  v_mechanic_lat numeric;
  v_mechanic_lng numeric;
  v_effective_radius_meters numeric;
  v_max_radius_miles constant numeric := 50; -- Hard cap prevents abuse
BEGIN
  -- ===========================================
  -- SECURITY: Fetch mechanic location from DATABASE (home_lat/home_lng)
  -- Client-provided lat/lng is NOT trusted for eligibility
  -- ===========================================
  SELECT
    prof.home_lat,
    prof.home_lng
  INTO v_mechanic_lat, v_mechanic_lng
  FROM profiles prof
  WHERE prof.id = p_mechanic_id
    AND prof.role = 'mechanic'
    AND prof.deleted_at IS NULL;

  -- FAIL-SECURE: No mechanic profile or no stored location = empty results
  IF v_mechanic_lat IS NULL OR v_mechanic_lng IS NULL THEN
    RETURN;
  END IF;

  -- Build geography from stored coordinates
  v_mechanic_geo := ST_SetSRID(ST_MakePoint(v_mechanic_lng, v_mechanic_lat), 4326)::extensions.geography;

  -- ===========================================
  -- SERVICE AREA CHECK: Mechanic must be within an active hub
  -- This prevents mechanics outside service areas from seeing any jobs
  -- ===========================================
  IF NOT EXISTS (
    SELECT 1 FROM service_hubs sh
    WHERE sh.is_active = true
      AND ST_DWithin(v_mechanic_geo, sh.location, sh.active_radius_miles * 1609.34)
  ) THEN
    RETURN;
  END IF;

  -- ===========================================
  -- RADIUS CALCULATION (capped for safety)
  -- ===========================================
  CASE p_filter
    WHEN 'nearby' THEN
      v_effective_radius_meters := 5 * 1609.34; -- 5 miles for "nearby"
    ELSE
      v_effective_radius_meters := LEAST(p_radius_miles, v_max_radius_miles) * 1609.34;
  END CASE;

  -- ===========================================
  -- MAIN QUERY with PostGIS spatial filtering
  -- ===========================================
  RETURN QUERY
  WITH mechanic_quotes AS (
    SELECT 
      q.job_id,
      q.id AS quote_id,
      q.price_cents,
      q.status::text AS quote_status,
      q.created_at AS quote_created_at
    FROM quotes q
    WHERE q.mechanic_id = p_mechanic_id
  ),
  customer_ratings AS (
    SELECT
      r.reviewee_id,
      AVG(r.overall_rating)::numeric AS avg_rating,
      COUNT(*)::bigint AS review_count
    FROM reviews r
    WHERE r.is_hidden = false
      AND r.deleted_at IS NULL
    GROUP BY r.reviewee_id
  )
  SELECT
    j.id AS job_id,
    j.title::text,
    j.description::text,
    j.status::text,
    j.created_at,
    j.preferred_time::text,
    j.location_address::text,
    COALESCE(j.location_lat, j.job_lat)::numeric AS latitude,
    COALESCE(j.location_lng, j.job_lng)::numeric AS longitude,
    -- Distance in miles using PostGIS (accurate, handles edge cases)
    ROUND((ST_Distance(v_mechanic_geo, j.location_geo) / 1609.34)::numeric, 1) AS distance_miles,
    p.id AS customer_id,
    p.full_name::text AS customer_name,
    p.avatar_url::text AS customer_photo_url,
    COALESCE(cr.avg_rating, 0)::numeric AS customer_rating,
    COALESCE(cr.review_count, 0)::bigint AS customer_review_count,
    j.vehicle_id,
    v.year AS vehicle_year,
    v.make::text AS vehicle_make,
    v.model::text AS vehicle_model,
    (mq.quote_id IS NOT NULL)::boolean AS has_quoted,
    mq.quote_id,
    mq.price_cents::integer AS quote_amount,
    mq.quote_status,
    mq.quote_created_at,
    (j.created_at > NOW() - INTERVAL '24 hours')::boolean AS is_new
  FROM jobs j
  INNER JOIN profiles p ON p.id = j.customer_id
  LEFT JOIN vehicles v ON v.id = j.vehicle_id
  LEFT JOIN mechanic_quotes mq ON mq.job_id = j.id
  LEFT JOIN customer_ratings cr ON cr.reviewee_id = p.id
  WHERE
    -- Soft delete checks
    j.deleted_at IS NULL
    AND p.deleted_at IS NULL
    
    -- NULL SAFETY: Job must have valid coordinates
    AND j.location_geo IS NOT NULL
    
    -- SERVICE AREA: Job must be within an active hub's radius
    -- This is the single enforcement point for service area compliance
    AND EXISTS (
      SELECT 1 FROM service_hubs sh
      WHERE sh.is_active = true
        AND ST_DWithin(j.location_geo, sh.location, sh.active_radius_miles * 1609.34)
    )
    
    -- DISTANCE: Job within mechanic's requested radius (capped)
    AND ST_DWithin(v_mechanic_geo, j.location_geo, v_effective_radius_meters)
    
    -- STATUS FILTER: Only show appropriate job statuses
    AND (
      CASE p_filter
        WHEN 'quoted' THEN 
          mq.quote_id IS NOT NULL  -- Jobs this mechanic has quoted
        ELSE 
          -- 'all' and 'nearby': show open jobs (searching/quoted status)
          j.status IN ('searching', 'quoted', 'open')
      END
    )
    
    -- FUTURE: Anti-disintermediation weighting could go here
    -- AND (p.risk_score IS NULL OR p.risk_score < 0.8)
    
  ORDER BY
    CASE WHEN p_sort_by = 'newest' THEN j.created_at END DESC NULLS LAST,
    CASE WHEN p_sort_by = 'closest' THEN ST_Distance(v_mechanic_geo, j.location_geo) END ASC NULLS LAST,
    j.created_at DESC  -- Secondary sort for stability
  LIMIT LEAST(p_limit, 100)  -- Hard cap on results
  OFFSET p_offset;
END;
$$;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION public.get_mechanic_leads TO authenticated;

-- Add helpful comment
COMMENT ON FUNCTION public.get_mechanic_leads IS
'Hardened job leads function for mechanics.
SECURITY: Uses DB-stored mechanic location (profiles.home_lat/home_lng), NOT client-provided coordinates.
REQUIREMENTS:
  - Mechanic must have home_lat and home_lng set in profiles
  - Mechanic must be within an active service hub
  - Jobs must be within an active service hub
  - Jobs must have valid location_geo
Client-provided p_mechanic_lat/p_mechanic_lng are IGNORED for eligibility (kept for API compatibility only).';

-- ===========================================
-- MIGRATION SAFETY: Ensure prerequisites exist
-- ===========================================

-- Ensure profiles has home_lat/home_lng columns
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'profiles'
      AND column_name = 'home_lat'
  ) THEN
    RAISE EXCEPTION 'Missing prerequisite: profiles.home_lat column.';
  END IF;
END $$;

-- Ensure jobs has location_geo column (from 0060)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'jobs'
      AND column_name = 'location_geo'
  ) THEN
    RAISE EXCEPTION 'Missing prerequisite: jobs.location_geo column. Run migration 0060 first.';
  END IF;
END $$;

-- Ensure service_hubs table exists (from 0031)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.tables
    WHERE table_schema = 'public'
      AND table_name = 'service_hubs'
  ) THEN
    RAISE EXCEPTION 'Missing prerequisite: service_hubs table. Run migration 0031 first.';
  END IF;
END $$;
\n-- ===================================================================
-- END: 0062_properly_hardened_get_mechanic_leads.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0063_fix_postgis_optional.sql
-- ===================================================================\n
-- Migration: Make PostGIS features optional to prevent errors when extension not available
-- Fixes: "type 'geography' does not exist" error on job creation

-- Drop the trigger that requires PostGIS
DROP TRIGGER IF EXISTS trg_sync_job_location_geo ON public.jobs;

-- Drop the function that uses geography type
DROP FUNCTION IF EXISTS sync_job_location_geo();

-- Drop the geography column if it exists (will fail silently if PostGIS not installed)
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'jobs' 
    AND column_name = 'location_geo'
  ) THEN
    ALTER TABLE public.jobs DROP COLUMN IF EXISTS location_geo;
  END IF;
EXCEPTION WHEN OTHERS THEN
  -- Ignore errors if column doesn't exist or can't be dropped
  NULL;
END $$;

-- Drop the index that depends on the geography column
DROP INDEX IF EXISTS idx_jobs_location_geo;

-- Create a simpler distance calculation function using lat/lng directly (no PostGIS required)
CREATE OR REPLACE FUNCTION calculate_distance_km(
  lat1 double precision,
  lng1 double precision,
  lat2 double precision,
  lng2 double precision
) RETURNS double precision AS $$
DECLARE
  R constant double precision := 6371; -- Earth's radius in km
  dlat double precision;
  dlng double precision;
  a double precision;
  c double precision;
BEGIN
  IF lat1 IS NULL OR lng1 IS NULL OR lat2 IS NULL OR lng2 IS NULL THEN
    RETURN NULL;
  END IF;
  
  dlat := radians(lat2 - lat1);
  dlng := radians(lng2 - lng1);
  a := sin(dlat/2) * sin(dlat/2) + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlng/2) * sin(dlng/2);
  c := 2 * atan2(sqrt(a), sqrt(1-a));
  
  RETURN R * c;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

COMMENT ON FUNCTION calculate_distance_km IS 'Calculate distance between two points using Haversine formula (no PostGIS required)';
\n-- ===================================================================
-- END: 0063_fix_postgis_optional.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0064_rating_prompt_system.sql
-- ===================================================================\n
-- Migration 0064: Rating Prompt System
-- Tracks user rating prompt state for in-app review prompts and push reminders

SET search_path TO public, extensions;

CREATE TABLE IF NOT EXISTS public.user_rating_prompt_state (
  user_id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  has_rated boolean DEFAULT false NOT NULL,
  first_job_completed_at timestamptz,
  last_prompt_at timestamptz,
  prompt_count integer DEFAULT 0 NOT NULL,
  snooze_until timestamptz,
  last_push_at timestamptz,
  push_count integer DEFAULT 0 NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

CREATE INDEX idx_rating_prompt_user ON user_rating_prompt_state(user_id);
CREATE INDEX idx_rating_prompt_eligible ON user_rating_prompt_state(has_rated, snooze_until, push_count) 
  WHERE has_rated = false;

ALTER TABLE user_rating_prompt_state ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "rating_state_own" ON user_rating_prompt_state;
CREATE POLICY "rating_state_own" ON user_rating_prompt_state
  FOR ALL TO authenticated
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

GRANT SELECT, INSERT, UPDATE ON user_rating_prompt_state TO authenticated;
GRANT ALL ON user_rating_prompt_state TO service_role;

CREATE OR REPLACE FUNCTION update_rating_prompt_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS rating_prompt_updated_at ON user_rating_prompt_state;
CREATE TRIGGER rating_prompt_updated_at
  BEFORE UPDATE ON user_rating_prompt_state
  FOR EACH ROW EXECUTE FUNCTION update_rating_prompt_timestamp();

CREATE OR REPLACE FUNCTION on_job_completed_rating_prompt()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
    INSERT INTO user_rating_prompt_state (user_id, first_job_completed_at)
    VALUES (NEW.customer_id, now())
    ON CONFLICT (user_id) DO UPDATE
    SET first_job_completed_at = COALESCE(user_rating_prompt_state.first_job_completed_at, now()),
        updated_at = now();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS job_completed_rating_prompt ON jobs;
CREATE TRIGGER job_completed_rating_prompt
  AFTER INSERT OR UPDATE ON jobs
  FOR EACH ROW EXECUTE FUNCTION on_job_completed_rating_prompt();

CREATE OR REPLACE FUNCTION get_rating_prompt_eligibility(p_user_id uuid)
RETURNS TABLE (
  eligible boolean,
  reason text,
  prompt_number integer,
  days_since_last_prompt integer
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
STABLE
AS $$
DECLARE
  v_state user_rating_prompt_state%ROWTYPE;
  v_completed_jobs integer;
  v_days_since_last integer;
  v_required_days integer;
BEGIN
  SELECT * INTO v_state FROM user_rating_prompt_state WHERE user_id = p_user_id;
  
  IF v_state IS NULL THEN
    RETURN QUERY SELECT false, 'no_state'::text, 0, 0;
    RETURN;
  END IF;
  
  IF v_state.has_rated THEN
    RETURN QUERY SELECT false, 'already_rated'::text, v_state.prompt_count, 0;
    RETURN;
  END IF;
  
  IF v_state.first_job_completed_at IS NULL THEN
    RETURN QUERY SELECT false, 'no_completed_job'::text, 0, 0;
    RETURN;
  END IF;
  
  IF v_state.snooze_until IS NOT NULL AND now() < v_state.snooze_until THEN
    RETURN QUERY SELECT false, 'snoozed'::text, v_state.prompt_count, 0;
    RETURN;
  END IF;
  
  IF v_state.prompt_count >= 3 THEN
    RETURN QUERY SELECT false, 'max_prompts_reached'::text, v_state.prompt_count, 0;
    RETURN;
  END IF;
  
  IF v_state.last_prompt_at IS NULL THEN
    RETURN QUERY SELECT true, 'first_prompt'::text, 1, 0;
    RETURN;
  END IF;
  
  v_days_since_last := EXTRACT(DAY FROM (now() - v_state.last_prompt_at))::integer;
  
  CASE v_state.prompt_count
    WHEN 1 THEN v_required_days := 7;
    WHEN 2 THEN v_required_days := 30;
    ELSE v_required_days := 999;
  END CASE;
  
  IF v_days_since_last >= v_required_days THEN
    RETURN QUERY SELECT true, 'cadence_met'::text, v_state.prompt_count + 1, v_days_since_last;
  ELSE
    RETURN QUERY SELECT false, 'cadence_not_met'::text, v_state.prompt_count, v_days_since_last;
  END IF;
END;
$$;

GRANT EXECUTE ON FUNCTION get_rating_prompt_eligibility TO authenticated;

CREATE OR REPLACE FUNCTION record_rating_prompt(p_user_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE user_rating_prompt_state
  SET last_prompt_at = now(),
      prompt_count = prompt_count + 1,
      snooze_until = NULL
  WHERE user_id = p_user_id;
END;
$$;

GRANT EXECUTE ON FUNCTION record_rating_prompt TO authenticated;

CREATE OR REPLACE FUNCTION snooze_rating_prompt(p_user_id uuid, p_days integer DEFAULT 14)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE user_rating_prompt_state
  SET snooze_until = now() + (p_days || ' days')::interval
  WHERE user_id = p_user_id;
END;
$$;

GRANT EXECUTE ON FUNCTION snooze_rating_prompt TO authenticated;

CREATE OR REPLACE FUNCTION confirm_app_rated(p_user_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE user_rating_prompt_state
  SET has_rated = true,
      snooze_until = NULL
  WHERE user_id = p_user_id;
END;
$$;

GRANT EXECUTE ON FUNCTION confirm_app_rated TO authenticated;

CREATE OR REPLACE FUNCTION get_push_eligible_users()
RETURNS TABLE (
  user_id uuid,
  push_token text,
  push_number integer
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
STABLE
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    rps.user_id,
    p.push_token,
    rps.push_count + 1 as push_number
  FROM user_rating_prompt_state rps
  INNER JOIN profiles p ON p.id = rps.user_id
  WHERE rps.has_rated = false
    AND rps.first_job_completed_at IS NOT NULL
    AND rps.prompt_count > 0
    AND rps.push_count < 3
    AND p.push_token IS NOT NULL
    AND p.deleted_at IS NULL
    AND (rps.snooze_until IS NULL OR now() > rps.snooze_until)
    AND (
      (rps.push_count = 0 AND rps.last_prompt_at < now() - interval '3 days')
      OR (rps.push_count = 1 AND rps.last_push_at < now() - interval '14 days')
      OR (rps.push_count = 2 AND rps.last_push_at < now() - interval '45 days')
    );
END;
$$;

GRANT EXECUTE ON FUNCTION get_push_eligible_users TO service_role;

CREATE OR REPLACE FUNCTION record_rating_push(p_user_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE user_rating_prompt_state
  SET last_push_at = now(),
      push_count = push_count + 1
  WHERE user_id = p_user_id;
END;
$$;

GRANT EXECUTE ON FUNCTION record_rating_push TO service_role;

COMMENT ON TABLE user_rating_prompt_state IS 'Tracks app rating prompt state per user for in-app reviews and push reminders';
\n-- ===================================================================
-- END: 0064_rating_prompt_system.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0065_fix_postgis_optional.sql
-- ===================================================================\n
-- Migration: Make PostGIS features optional to prevent errors when extension not available
-- Fixes: "type 'geography' does not exist" error on job creation

-- Drop the trigger that requires PostGIS
DROP TRIGGER IF EXISTS trg_sync_job_location_geo ON public.jobs;

-- Drop the function that uses geography type
DROP FUNCTION IF EXISTS sync_job_location_geo();

-- Drop the geography column if it exists (will fail silently if PostGIS not installed)
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'jobs' 
    AND column_name = 'location_geo'
  ) THEN
    ALTER TABLE public.jobs DROP COLUMN IF EXISTS location_geo;
  END IF;
EXCEPTION WHEN OTHERS THEN
  -- Ignore errors if column doesn't exist or can't be dropped
  NULL;
END $$;

-- Drop the index that depends on the geography column
DROP INDEX IF EXISTS idx_jobs_location_geo;

-- Create a simpler distance calculation function using lat/lng directly (no PostGIS required)
CREATE OR REPLACE FUNCTION calculate_distance_km(
  lat1 double precision,
  lng1 double precision,
  lat2 double precision,
  lng2 double precision
) RETURNS double precision AS $$
DECLARE
  R constant double precision := 6371; -- Earth's radius in km
  dlat double precision;
  dlng double precision;
  a double precision;
  c double precision;
BEGIN
  IF lat1 IS NULL OR lng1 IS NULL OR lat2 IS NULL OR lng2 IS NULL THEN
    RETURN NULL;
  END IF;
  
  dlat := radians(lat2 - lat1);
  dlng := radians(lng2 - lng1);
  a := sin(dlat/2) * sin(dlat/2) + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlng/2) * sin(dlng/2);
  c := 2 * atan2(sqrt(a), sqrt(1-a));
  
  RETURN R * c;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

COMMENT ON FUNCTION calculate_distance_km IS 'Calculate distance between two points using Haversine formula (no PostGIS required)';
\n-- ===================================================================
-- END: 0065_fix_postgis_optional.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0068_fix_job_status_enum.sql
-- ===================================================================\n
-- Migration 0068: Fix job_status enum - remove 'open' which doesn't exist

CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text DEFAULT 'all',
  p_mechanic_lat numeric DEFAULT NULL,
  p_mechanic_lng numeric DEFAULT NULL,
  p_radius_miles numeric DEFAULT 25,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  created_at timestamptz,
  preferred_time text,
  location_address text,
  latitude numeric,
  longitude numeric,
  distance_miles numeric,
  customer_id uuid,
  customer_name text,
  customer_photo_url text,
  customer_rating numeric,
  customer_review_count bigint,
  vehicle_id uuid,
  vehicle_year integer,
  vehicle_make text,
  vehicle_model text,
  has_quoted boolean,
  quote_id uuid,
  quote_amount integer,
  quote_status text,
  quote_created_at timestamptz,
  is_new boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
STABLE
AS $$
DECLARE
  v_mechanic_lat numeric;
  v_mechanic_lng numeric;
  v_effective_radius_km numeric;
  v_max_radius_miles constant numeric := 50;
BEGIN
  SELECT prof.home_lat, prof.home_lng
  INTO v_mechanic_lat, v_mechanic_lng
  FROM profiles prof
  WHERE prof.id = p_mechanic_id
    AND prof.role = 'mechanic'
    AND prof.deleted_at IS NULL;

  IF v_mechanic_lat IS NULL OR v_mechanic_lng IS NULL THEN
    RETURN;
  END IF;

  CASE p_filter
    WHEN 'nearby' THEN
      v_effective_radius_km := 5 * 1.60934;
    ELSE
      v_effective_radius_km := LEAST(p_radius_miles, v_max_radius_miles) * 1.60934;
  END CASE;

  RETURN QUERY
  WITH mechanic_quotes AS (
    SELECT 
      q.job_id,
      q.id AS quote_id,
      q.price_cents,
      q.status::text AS quote_status,
      q.created_at AS quote_created_at
    FROM quotes q
    WHERE q.mechanic_id = p_mechanic_id
  ),
  customer_ratings AS (
    SELECT
      r.reviewee_id,
      AVG(r.overall_rating)::numeric AS avg_rating,
      COUNT(*)::bigint AS review_count
    FROM reviews r
    WHERE r.is_hidden = false
      AND r.deleted_at IS NULL
    GROUP BY r.reviewee_id
  )
  SELECT
    j.id AS job_id,
    j.title::text,
    j.description::text,
    j.status::text,
    j.created_at,
    j.preferred_time::text,
    j.location_address::text,
    COALESCE(j.location_lat, j.job_lat)::numeric AS latitude,
    COALESCE(j.location_lng, j.job_lng)::numeric AS longitude,
    ROUND((calculate_distance_km(v_mechanic_lat, v_mechanic_lng, 
      COALESCE(j.location_lat, j.job_lat), COALESCE(j.location_lng, j.job_lng)) / 1.60934)::numeric, 1) AS distance_miles,
    p.id AS customer_id,
    p.full_name::text AS customer_name,
    p.avatar_url::text AS customer_photo_url,
    COALESCE(cr.avg_rating, 0)::numeric AS customer_rating,
    COALESCE(cr.review_count, 0)::bigint AS customer_review_count,
    j.vehicle_id,
    v.year AS vehicle_year,
    v.make::text AS vehicle_make,
    v.model::text AS vehicle_model,
    (mq.quote_id IS NOT NULL)::boolean AS has_quoted,
    mq.quote_id,
    mq.price_cents::integer AS quote_amount,
    mq.quote_status,
    mq.quote_created_at,
    (j.created_at > NOW() - INTERVAL '24 hours')::boolean AS is_new
  FROM jobs j
  INNER JOIN profiles p ON p.id = j.customer_id
  LEFT JOIN vehicles v ON v.id = j.vehicle_id
  LEFT JOIN mechanic_quotes mq ON mq.job_id = j.id
  LEFT JOIN customer_ratings cr ON cr.reviewee_id = p.id
  WHERE
    j.deleted_at IS NULL
    AND p.deleted_at IS NULL
    AND (j.location_lat IS NOT NULL OR j.job_lat IS NOT NULL)
    AND (j.location_lng IS NOT NULL OR j.job_lng IS NOT NULL)
    AND calculate_distance_km(v_mechanic_lat, v_mechanic_lng, 
        COALESCE(j.location_lat, j.job_lat), COALESCE(j.location_lng, j.job_lng)) <= v_effective_radius_km
    AND (
      CASE p_filter
        WHEN 'quoted' THEN mq.quote_id IS NOT NULL
        ELSE j.status IN ('searching', 'quoted')
      END
    )
  ORDER BY
    CASE WHEN p_sort_by = 'distance' THEN 
      calculate_distance_km(v_mechanic_lat, v_mechanic_lng, COALESCE(j.location_lat, j.job_lat), COALESCE(j.location_lng, j.job_lng))
    END ASC NULLS LAST,
    CASE WHEN p_sort_by = 'newest' OR p_sort_by IS NULL THEN j.created_at END DESC NULLS LAST
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;
\n-- ===================================================================
-- END: 0068_fix_job_status_enum.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0069_update_invite_rewards.sql
-- ===================================================================\n
-- Update invitation rewards:
-- Invite customer: 1 job fee waived (FEELESS)
-- Invite mechanic: 3 job fees waived (FEELESS)

CREATE OR REPLACE FUNCTION public.award_invitation_credits(
  p_invited_id uuid,
  p_payment_id uuid DEFAULT NULL,
  p_stripe_event_id text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_invitation record;
  v_award_type text;
  v_credit_type text;
  v_credit_uses int;
  v_credit_id uuid;
BEGIN
  SELECT * INTO v_invitation
  FROM invitations
  WHERE invited_id = p_invited_id;
  
  IF v_invitation IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'No invitation found for user');
  END IF;
  
  -- Determine award based on invited_role
  -- Invite CUSTOMER -> 1 FEELESS credit (1 job fee waived)
  -- Invite MECHANIC -> 3 FEELESS credits (3 job fees waived)
  IF v_invitation.invited_role = 'customer' THEN
    v_award_type := 'FEELESS_1';
    v_credit_type := 'FEELESS';
    v_credit_uses := 1;
  ELSE -- mechanic
    v_award_type := 'FEELESS_3';
    v_credit_type := 'FEELESS';
    v_credit_uses := 3;
  END IF;
  
  -- Try to insert award (unique constraint prevents duplicates)
  BEGIN
    INSERT INTO invitation_awards (inviter_id, invited_id, award_type, payment_id, stripe_event_id)
    VALUES (v_invitation.inviter_id, p_invited_id, v_award_type, p_payment_id, p_stripe_event_id);
  EXCEPTION WHEN unique_violation THEN
    RETURN jsonb_build_object('success', false, 'error', 'Award already granted for this invited user');
  END;
  
  -- Create promo credit for inviter
  INSERT INTO promo_credits (user_id, credit_type, remaining_uses, source_invited_user_id, source_invitation_id)
  VALUES (v_invitation.inviter_id, v_credit_type, v_credit_uses, p_invited_id, v_invitation.id)
  RETURNING id INTO v_credit_id;
  
  RETURN jsonb_build_object(
    'success', true,
    'inviter_id', v_invitation.inviter_id,
    'award_type', v_award_type,
    'credit_id', v_credit_id,
    'credit_uses', v_credit_uses
  );
END;
$$;

REVOKE EXECUTE ON FUNCTION public.award_invitation_credits(uuid, uuid, text) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION public.award_invitation_credits(uuid, uuid, text) FROM authenticated;\n-- ===================================================================
-- END: 0069_update_invite_rewards.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0070_fix_cancel_job_for_update.sql
-- ===================================================================\n
-- Fix FOR UPDATE on LEFT JOIN in cancel_job function

CREATE OR REPLACE FUNCTION cancel_job(
  p_job_id uuid,
  p_cancelled_by uuid,
  p_reason public.cancellation_reason,
  p_note text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_contract RECORD;
  v_progress RECORD;
  v_refund_amount int;
  v_is_customer boolean;
BEGIN
  -- Get contract (lock it)
  SELECT *
  INTO v_contract
  FROM public.job_contracts
  WHERE job_id = p_job_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract not found');
  END IF;
  
  -- Get progress separately (may not exist)
  SELECT * INTO v_progress
  FROM public.job_progress
  WHERE contract_id = v_contract.id;
  
  IF v_contract.status NOT IN ('pending_payment', 'active') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Cannot cancel - job is ' || v_contract.status);
  END IF;
  
  -- Determine if canceller is customer
  v_is_customer := (p_cancelled_by = v_contract.customer_id);
  
  -- Calculate refund based on reason
  CASE p_reason
    WHEN 'customer_before_departure', 'mechanic_before_departure', 'mechanic_no_show' THEN
      v_refund_amount := v_contract.total_customer_cents;
    WHEN 'customer_after_departure' THEN
      v_refund_amount := v_contract.total_customer_cents - 2500;
    WHEN 'customer_after_arrival', 'customer_no_show' THEN
      v_refund_amount := v_contract.total_customer_cents - 2500;
    WHEN 'customer_after_work_started' THEN
      v_refund_amount := 0;
    WHEN 'mutual_agreement', 'platform_intervention' THEN
      v_refund_amount := v_contract.total_customer_cents;
    ELSE
      v_refund_amount := v_contract.total_customer_cents;
  END CASE;
  
  v_refund_amount := GREATEST(v_refund_amount, 0);
  
  -- Update contract
  UPDATE public.job_contracts
  SET 
    status = 'cancelled',
    cancelled_at = now(),
    cancelled_by = p_cancelled_by,
    cancellation_reason = p_reason,
    cancellation_note = p_note,
    refund_amount_cents = v_refund_amount,
    updated_at = now()
  WHERE id = v_contract.id;
  
  -- Update job
  UPDATE public.jobs
  SET 
    status = 'cancelled',
    cancelled_at = now(),
    canceled_by = p_cancelled_by,
    updated_at = now()
  WHERE id = p_job_id;
  
  -- Log event
  PERFORM log_job_event(
    p_job_id, v_contract.id, 'cancelled',
    p_cancelled_by, CASE WHEN v_is_customer THEN 'customer'::public.user_role ELSE 'mechanic'::public.user_role END,
    'Job cancelled',
    COALESCE(p_note, 'Job was cancelled: ' || p_reason::text),
    jsonb_build_object(
      'reason', p_reason,
      'refund_amount_cents', v_refund_amount,
      'cancelled_by_customer', v_is_customer
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'refund_amount_cents', v_refund_amount,
    'contract_id', v_contract.id
  );
END;
$$;\n-- ===================================================================
-- END: 0070_fix_cancel_job_for_update.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0071_add_payout_method_status.sql
-- ===================================================================\n
-- Migration: Add payout_method_status to profiles for mechanics
-- Similar to payment_method_status for customers

-- ENUM: payout_method_status (reuse payment_method_status enum values)
DO $$ BEGIN
  CREATE TYPE public.payout_method_status AS ENUM (
    'none',
    'pending',
    'active',
    'failed'
  );
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

-- ADD payout_method_status TO profiles
ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS payout_method_status public.payout_method_status DEFAULT 'none' NOT NULL;

-- FUNCTION: Update payout_method_status when mechanic_stripe_accounts changes
CREATE OR REPLACE FUNCTION public.sync_payout_method_status()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
    IF NEW.onboarding_complete = true AND NEW.payouts_enabled = true AND NEW.deleted_at IS NULL THEN
      UPDATE public.profiles
      SET payout_method_status = 'active'
      WHERE id = NEW.mechanic_id;
    ELSIF NEW.onboarding_complete = true AND NEW.payouts_enabled = false THEN
      UPDATE public.profiles
      SET payout_method_status = 'pending'
      WHERE id = NEW.mechanic_id;
    ELSIF NEW.deleted_at IS NOT NULL THEN
      UPDATE public.profiles
      SET payout_method_status = 'none'
      WHERE id = NEW.mechanic_id;
    END IF;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.profiles
    SET payout_method_status = 'none'
    WHERE id = OLD.mechanic_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- TRIGGER: sync payout status on mechanic_stripe_accounts changes
DROP TRIGGER IF EXISTS sync_payout_method_status_trigger ON public.mechanic_stripe_accounts;
CREATE TRIGGER sync_payout_method_status_trigger
  AFTER INSERT OR UPDATE OR DELETE ON public.mechanic_stripe_accounts
  FOR EACH ROW EXECUTE FUNCTION public.sync_payout_method_status();

-- Backfill existing mechanic_stripe_accounts
UPDATE public.profiles p
SET payout_method_status = 'active'
FROM public.mechanic_stripe_accounts msa
WHERE msa.mechanic_id = p.id
  AND msa.onboarding_complete = true
  AND msa.payouts_enabled = true
  AND msa.deleted_at IS NULL;

UPDATE public.profiles p
SET payout_method_status = 'pending'
FROM public.mechanic_stripe_accounts msa
WHERE msa.mechanic_id = p.id
  AND msa.onboarding_complete = true
  AND msa.payouts_enabled = false
  AND msa.deleted_at IS NULL
  AND p.payout_method_status = 'none';
\n-- ===================================================================
-- END: 0071_add_payout_method_status.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0073_chat_attachments.sql
-- ===================================================================\n
-- Add attachment support to messages table
ALTER TABLE public.messages
ADD COLUMN IF NOT EXISTS attachment_url text,
ADD COLUMN IF NOT EXISTS attachment_type text CHECK (attachment_type IN ('image', 'file'));

-- Create storage bucket for chat attachments
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'chat-attachments',
  'chat-attachments',
  true,
  10485760, -- 10MB limit
  ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'application/pdf']
)
ON CONFLICT (id) DO UPDATE SET public = true;

-- RLS policies for chat-attachments bucket
CREATE POLICY "Users can upload chat attachments"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (
  bucket_id = 'chat-attachments'
  AND (storage.foldername(name))[1] = auth.uid()::text
);

CREATE POLICY "Users can view their own chat attachments"
ON storage.objects FOR SELECT
TO authenticated
USING (
  bucket_id = 'chat-attachments'
  AND (
    (storage.foldername(name))[1] = auth.uid()::text
    OR EXISTS (
      SELECT 1 FROM public.messages m
      WHERE m.attachment_url LIKE '%' || name
      AND (m.sender_id = auth.uid() OR m.recipient_id = auth.uid())
    )
  )
);

CREATE POLICY "Users can delete their own chat attachments"
ON storage.objects FOR DELETE
TO authenticated
USING (
  bucket_id = 'chat-attachments'
  AND (storage.foldername(name))[1] = auth.uid()::text
);

COMMENT ON COLUMN public.messages.attachment_url IS 'URL to attached file in storage';
COMMENT ON COLUMN public.messages.attachment_type IS 'Type of attachment: image or file';
\n-- ===================================================================
-- END: 0073_chat_attachments.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0074_make_chat_attachments_public.sql
-- ===================================================================\n
-- Make chat-attachments bucket public so images can be viewed
UPDATE storage.buckets
SET public = true
WHERE id = 'chat-attachments';\n-- ===================================================================
-- END: 0074_make_chat_attachments_public.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0075_fix_accept_quote_for_retry.sql
-- ===================================================================\n
-- Fix: Allow accept_quote_and_create_contract to work for quotes already marked as accepted
-- This handles the case where a user accepted a quote but didn't complete payment

BEGIN;

CREATE OR REPLACE FUNCTION accept_quote_and_create_contract(
  p_quote_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_quote RECORD;
  v_job RECORD;
  v_existing_contract RECORD;
  v_contract_id uuid;
  v_progress_id uuid;
  v_platform_fee_cents int := 1500;
  v_commission_cents int;
  v_total_customer_cents int;
  v_mechanic_payout_cents int;
  v_line_item_id uuid;
BEGIN
  SELECT q.*, j.customer_id as job_customer_id, j.status as job_status
  INTO v_quote
  FROM public.quotes q
  JOIN public.jobs j ON j.id = q.job_id
  WHERE q.id = p_quote_id
  FOR UPDATE OF q, j;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote not found');
  END IF;
  
  IF v_quote.job_customer_id != p_customer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  -- Allow pending or already accepted quotes (for payment retry)
  IF v_quote.status NOT IN ('pending', 'accepted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote is no longer available');
  END IF;
  
  -- Check if contract already exists for this quote
  SELECT * INTO v_existing_contract
  FROM public.job_contracts
  WHERE quote_id = p_quote_id;
  
  IF FOUND THEN
    -- Contract already exists, return success with existing contract
    RETURN jsonb_build_object(
      'success', true,
      'contract_id', v_existing_contract.id,
      'total_cents', v_existing_contract.total_customer_cents,
      'mechanic_id', v_existing_contract.mechanic_id
    );
  END IF;
  
  -- For accepted quotes without contract, allow if job is in accepted state
  IF v_quote.status = 'accepted' AND v_quote.job_status NOT IN ('accepted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job is no longer accepting quotes');
  END IF;
  
  -- For pending quotes, check normal job status
  IF v_quote.status = 'pending' AND v_quote.job_status NOT IN ('searching', 'quoted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job is no longer accepting quotes');
  END IF;
  
  v_commission_cents := calculate_mechanic_commission(v_quote.price_cents);
  v_total_customer_cents := v_quote.price_cents + v_platform_fee_cents;
  v_mechanic_payout_cents := v_quote.price_cents - v_commission_cents;
  
  INSERT INTO public.job_contracts (
    job_id, quote_id, customer_id, mechanic_id,
    status, quoted_price_cents, platform_fee_cents, estimated_hours,
    subtotal_cents, total_customer_cents, mechanic_commission_cents, mechanic_payout_cents
  ) VALUES (
    v_quote.job_id, p_quote_id, p_customer_id, v_quote.mechanic_id,
    'active', v_quote.price_cents, v_platform_fee_cents, v_quote.estimated_hours,
    v_quote.price_cents, v_total_customer_cents, v_commission_cents, v_mechanic_payout_cents
  )
  RETURNING id INTO v_contract_id;
  
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'base_labor', 'Service as quoted', 1, v_quote.price_cents, v_quote.price_cents,
    'approved', false, v_quote.mechanic_id, 'mechanic', 0
  )
  RETURNING id INTO v_line_item_id;
  
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'platform_fee', 'WrenchGo platform fee', 1, v_platform_fee_cents, v_platform_fee_cents,
    'approved', false, p_customer_id, 'customer', 100
  );
  
  INSERT INTO public.job_progress (job_id, contract_id)
  VALUES (v_quote.job_id, v_contract_id)
  RETURNING id INTO v_progress_id;
  
  -- Only update quote status if it's still pending
  IF v_quote.status = 'pending' THEN
    UPDATE public.quotes
    SET status = 'accepted', updated_at = now()
    WHERE id = p_quote_id;
    
    -- Decline other pending quotes
    UPDATE public.quotes
    SET status = 'declined', updated_at = now()
    WHERE job_id = v_quote.job_id AND id != p_quote_id AND status = 'pending';
  END IF;
  
  -- Only update job status if not already accepted
  IF v_quote.job_status NOT IN ('accepted', 'work_in_progress', 'completed') THEN
    UPDATE public.jobs
    SET 
      status = 'accepted',
      accepted_mechanic_id = v_quote.mechanic_id,
      updated_at = now()
    WHERE id = v_quote.job_id;
  END IF;
  
  PERFORM log_job_event(
    v_quote.job_id, v_contract_id, 'contract_created',
    p_customer_id, 'customer',
    'Contract created',
    'Quote accepted and contract created',
    jsonb_build_object(
      'quoted_price_cents', v_quote.price_cents,
      'platform_fee_cents', v_platform_fee_cents,
      'total_cents', v_total_customer_cents
    ),
    v_total_customer_cents
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'contract_id', v_contract_id,
    'total_cents', v_total_customer_cents,
    'mechanic_id', v_quote.mechanic_id
  );
END;
$$;

COMMIT;
\n-- ===================================================================
-- END: 0075_fix_accept_quote_for_retry.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0076_fix_invitation_awards_constraint.sql
-- ===================================================================\n
\n-- ===================================================================
-- END: 0076_fix_invitation_awards_constraint.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0077_add_gross_earnings_to_summary.sql
-- ===================================================================\n
-- Add gross_earnings_cents to financial summary for mechanics
CREATE OR REPLACE FUNCTION public.get_financial_summary(
  p_user_id uuid,
  p_role text,
  p_period_type text DEFAULT 'all_time'
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result jsonb;
  v_start_date date;
BEGIN
  -- Calculate period start
  v_start_date := CASE p_period_type
    WHEN 'week' THEN CURRENT_DATE - INTERVAL '7 days'
    WHEN 'month' THEN CURRENT_DATE - INTERVAL '30 days'
    WHEN 'year' THEN CURRENT_DATE - INTERVAL '365 days'
    ELSE NULL
  END;
  
  IF p_role = 'mechanic' THEN
    SELECT jsonb_build_object(
      'total_jobs', COUNT(DISTINCT j.id),
      'gross_earnings_cents', COALESCE(SUM(c.mechanic_payout_cents + c.mechanic_commission_cents), 0),
      'total_earnings_cents', COALESCE(SUM(c.mechanic_payout_cents), 0),
      'total_commission_cents', COALESCE(SUM(c.mechanic_commission_cents), 0),
      'pending_payouts_cents', COALESCE(SUM(
        CASE WHEN p.status = 'pending' THEN p.net_amount_cents ELSE 0 END
      ), 0),
      'completed_payouts_cents', COALESCE(SUM(
        CASE WHEN p.status = 'completed' THEN p.net_amount_cents ELSE 0 END
      ), 0)
    )
    INTO v_result
    FROM public.jobs j
    JOIN public.job_contracts c ON c.job_id = j.id
    LEFT JOIN public.payouts p ON p.contract_id = c.id
    WHERE j.accepted_mechanic_id = p_user_id
      AND j.status = 'completed'
      AND (v_start_date IS NULL OR j.created_at >= v_start_date);
  ELSE
    SELECT jsonb_build_object(
      'total_jobs', COUNT(DISTINCT j.id),
      'total_spent_cents', COALESCE(SUM(c.total_customer_cents), 0),
      'total_fees_cents', COALESCE(SUM(c.platform_fee_cents), 0)
    )
    INTO v_result
    FROM public.jobs j
    JOIN public.job_contracts c ON c.job_id = j.id
    WHERE j.customer_id = p_user_id
      AND j.status = 'completed'
      AND (v_start_date IS NULL OR j.created_at >= v_start_date);
  END IF;
  
  RETURN COALESCE(v_result, '{}'::jsonb);
END;
$$;
\n-- ===================================================================
-- END: 0077_add_gross_earnings_to_summary.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0078_fix_referral_immediate_reward.sql
-- ===================================================================\n
-- MIGRATION 0078: Fix Referral System - Immediate Rewards
-- 
-- Flow:
-- 1. User1 shares their referral code with User2
-- 2. User2 enters the code (can only do this ONCE ever)
-- 3. User1 gets rewarded IMMEDIATELY (1 credit for customer, 3 for mechanic)
-- 4. User2 can now share their own code with others

BEGIN;

-- Drop and recreate accept_invitation to grant rewards immediately
CREATE OR REPLACE FUNCTION public.accept_invitation(p_invite_code text)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_invited_id uuid;
  v_invited_role public.user_role;
  v_inviter_id uuid;
  v_inviter_role public.user_role;
  v_invite_code_id uuid;
  v_already_used_code boolean;
  v_invitation_id uuid;
  v_credit_uses int;
  v_credit_id uuid;
BEGIN
  v_invited_id := auth.uid();
  
  IF v_invited_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  
  -- Check if this user has EVER used a referral code before
  SELECT EXISTS(SELECT 1 FROM invitations WHERE invited_id = v_invited_id) INTO v_already_used_code;
  IF v_already_used_code THEN
    RETURN jsonb_build_object('success', false, 'error', 'You have already used a referral code');
  END IF;
  
  -- Get invite code details
  SELECT ic.id, ic.inviter_id INTO v_invite_code_id, v_inviter_id
  FROM invite_codes ic
  WHERE ic.code = upper(trim(p_invite_code))
    AND (ic.expires_at IS NULL OR ic.expires_at > now())
    AND (ic.max_uses IS NULL OR ic.current_uses < ic.max_uses);
  
  IF v_inviter_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid or expired referral code');
  END IF;
  
  -- No self-invites
  IF v_inviter_id = v_invited_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Cannot use your own referral code');
  END IF;
  
  -- Get roles
  SELECT role INTO v_inviter_role FROM profiles WHERE id = v_inviter_id;
  SELECT role INTO v_invited_role FROM profiles WHERE id = v_invited_id;
  
  IF v_inviter_role IS NULL OR v_invited_role IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User profiles not found');
  END IF;
  
  -- Create invitation record (this also prevents future code usage due to unique constraint)
  INSERT INTO invitations (inviter_id, invited_id, inviter_role, invited_role, invite_code_id)
  VALUES (v_inviter_id, v_invited_id, v_inviter_role, v_invited_role, v_invite_code_id)
  RETURNING id INTO v_invitation_id;
  
  -- Increment invite code usage
  UPDATE invite_codes SET current_uses = current_uses + 1 WHERE id = v_invite_code_id;
  
  -- IMMEDIATELY grant reward to inviter
  -- Customer invitee = 1 FEELESS credit
  -- Mechanic invitee = 3 FEELESS credits
  IF v_invited_role = 'customer' THEN
    v_credit_uses := 1;
  ELSE
    v_credit_uses := 3;
  END IF;
  
  -- Create promo credit for the INVITER (the person who shared the code)
  INSERT INTO promo_credits (user_id, credit_type, remaining_uses, source_invited_user_id, source_invitation_id)
  VALUES (v_inviter_id, 'FEELESS', v_credit_uses, v_invited_id, v_invitation_id)
  RETURNING id INTO v_credit_id;
  
  -- Record the award for audit
  INSERT INTO invitation_awards (inviter_id, invited_id, award_type, created_at)
  VALUES (v_inviter_id, v_invited_id, 
          CASE WHEN v_invited_role = 'customer' THEN 'FEELESS_1' ELSE 'FEELESS_3' END,
          now())
  ON CONFLICT DO NOTHING;
  
  RETURN jsonb_build_object(
    'success', true, 
    'inviter_id', v_inviter_id,
    'credits_awarded', v_credit_uses,
    'message', 'Referral code applied! The person who invited you has been rewarded.'
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.accept_invitation(text) TO authenticated;

-- Ensure invitation_awards table exists with proper structure
CREATE TABLE IF NOT EXISTS public.invitation_awards (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  inviter_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  invited_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  award_type text NOT NULL,
  payment_id uuid REFERENCES public.payments(id) ON DELETE SET NULL,
  stripe_event_id text,
  created_at timestamptz DEFAULT now() NOT NULL
);

-- Add unique constraint on invited_id if not exists (one award per invited user)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'invitation_awards_invited_id_key'
  ) THEN
    ALTER TABLE public.invitation_awards ADD CONSTRAINT invitation_awards_invited_id_key UNIQUE (invited_id);
  END IF;
EXCEPTION WHEN duplicate_object THEN
  NULL;
END $$;

-- RLS for invitation_awards
ALTER TABLE public.invitation_awards ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS invitation_awards_select ON public.invitation_awards;
CREATE POLICY invitation_awards_select ON public.invitation_awards
  FOR SELECT USING (inviter_id = auth.uid() OR invited_id = auth.uid());

COMMIT;
\n-- ===================================================================
-- END: 0078_fix_referral_immediate_reward.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0079_update_submit_review_ratings.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0079: UPDATE SUBMIT_REVIEW WITH NEW RATING FIELDS
-- =====================================================
-- Purpose: Add performance, timing, cost ratings for mechanic reviews
--          Add communication, punctuality, payment ratings for customer reviews
-- =====================================================

BEGIN;

-- First add new columns to reviews table if they don't exist
ALTER TABLE public.reviews 
  ADD COLUMN IF NOT EXISTS performance_rating int CHECK (performance_rating >= 1 AND performance_rating <= 5),
  ADD COLUMN IF NOT EXISTS timing_rating int CHECK (timing_rating >= 1 AND timing_rating <= 5),
  ADD COLUMN IF NOT EXISTS cost_rating int CHECK (cost_rating >= 1 AND cost_rating <= 5),
  ADD COLUMN IF NOT EXISTS punctuality_rating int CHECK (punctuality_rating >= 1 AND punctuality_rating <= 5),
  ADD COLUMN IF NOT EXISTS payment_rating int CHECK (payment_rating >= 1 AND payment_rating <= 5);

-- Update submit_review function with new parameters
CREATE OR REPLACE FUNCTION public.submit_review(
  p_job_id uuid,
  p_reviewer_id uuid,
  p_reviewee_id uuid,
  p_rating int,
  p_comment text DEFAULT NULL,
  p_professionalism_rating int DEFAULT NULL,
  p_communication_rating int DEFAULT NULL,
  p_would_recommend boolean DEFAULT NULL,
  p_performance_rating int DEFAULT NULL,
  p_timing_rating int DEFAULT NULL,
  p_cost_rating int DEFAULT NULL,
  p_punctuality_rating int DEFAULT NULL,
  p_payment_rating int DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_review_id uuid;
  v_blind_deadline timestamptz;
  v_other_review_exists boolean;
  v_should_publish boolean := false;
  v_job_finalized_at timestamptz;
BEGIN
  -- Get job finalized timestamp
  SELECT jp.finalized_at INTO v_job_finalized_at
  FROM public.job_progress jp
  WHERE jp.job_id = p_job_id;
  
  IF v_job_finalized_at IS NULL THEN
    RAISE EXCEPTION 'Job not finalized yet';
  END IF;
  
  -- Set blind deadline to 7 days after job finalization
  v_blind_deadline := v_job_finalized_at + interval '7 days';
  
  -- Check if other party has already reviewed
  SELECT EXISTS(
    SELECT 1 FROM public.reviews
    WHERE job_id = p_job_id
      AND reviewer_id = p_reviewee_id
      AND reviewee_id = p_reviewer_id
  ) INTO v_other_review_exists;
  
  -- If both reviews exist, publish both immediately
  v_should_publish := v_other_review_exists;
  
  -- Insert or update review
  INSERT INTO public.reviews (
    job_id,
    reviewer_id,
    reviewee_id,
    overall_rating,
    comment,
    professionalism_rating,
    communication_rating,
    would_recommend,
    performance_rating,
    timing_rating,
    cost_rating,
    punctuality_rating,
    payment_rating,
    visibility,
    blind_deadline,
    created_at,
    updated_at
  ) VALUES (
    p_job_id,
    p_reviewer_id,
    p_reviewee_id,
    p_rating,
    p_comment,
    p_professionalism_rating,
    p_communication_rating,
    p_would_recommend,
    p_performance_rating,
    p_timing_rating,
    p_cost_rating,
    p_punctuality_rating,
    p_payment_rating,
    CASE WHEN v_should_publish THEN 'visible'::review_visibility ELSE 'hidden'::review_visibility END,
    v_blind_deadline,
    now(),
    now()
  )
  ON CONFLICT (job_id, reviewer_id) 
  DO UPDATE SET
    overall_rating = EXCLUDED.overall_rating,
    comment = EXCLUDED.comment,
    professionalism_rating = EXCLUDED.professionalism_rating,
    communication_rating = EXCLUDED.communication_rating,
    would_recommend = EXCLUDED.would_recommend,
    performance_rating = EXCLUDED.performance_rating,
    timing_rating = EXCLUDED.timing_rating,
    cost_rating = EXCLUDED.cost_rating,
    punctuality_rating = EXCLUDED.punctuality_rating,
    payment_rating = EXCLUDED.payment_rating,
    updated_at = now()
  RETURNING id INTO v_review_id;
  
  -- If both reviews exist, publish both
  IF v_should_publish THEN
    UPDATE public.reviews
    SET 
      visibility = 'visible',
      made_visible_at = now(),
      visibility_reason = 'both_submitted'
    WHERE job_id = p_job_id
      AND visibility = 'hidden';
  END IF;
  
  RETURN jsonb_build_object(
    'review_id', v_review_id,
    'published', v_should_publish,
    'blind_deadline', v_blind_deadline
  );
END;
$$;

COMMIT;
\n-- ===================================================================
-- END: 0079_update_submit_review_ratings.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0080_update_get_public_profile_card.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0080: UPDATE GET_PUBLIC_PROFILE_CARD
-- =====================================================
-- Purpose: Add customer rating fields and trust score to profile card
-- =====================================================

DROP FUNCTION IF EXISTS public.get_public_profile_card CASCADE;

CREATE OR REPLACE FUNCTION public.get_public_profile_card(user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  result jsonb;
  profile_ratings jsonb;
  profile_badges jsonb;
  profile_skills jsonb;
  profile_trust_score jsonb;
  v_role text;
BEGIN
  -- Get user role first
  SELECT p.role INTO v_role
  FROM profiles p
  WHERE p.auth_id = user_id
    AND p.deleted_at IS NULL;

  -- Get ratings data with all fields
  SELECT jsonb_build_object(
    'overall_avg', COALESCE(AVG(r.overall_rating), 0),
    -- Mechanic ratings (from customer reviews)
    'performance_avg', COALESCE(AVG(r.performance_rating), 0),
    'timing_avg', COALESCE(AVG(r.timing_rating), 0),
    'cost_avg', COALESCE(AVG(r.cost_rating), 0),
    'professionalism_avg', COALESCE(AVG(r.professionalism_rating), 0),
    -- Customer ratings (from mechanic reviews)
    'communication_avg', COALESCE(AVG(r.communication_rating), 0),
    'punctuality_avg', COALESCE(AVG(r.punctuality_rating), 0),
    'payment_avg', COALESCE(AVG(r.payment_rating), 0),
    'review_count', COUNT(r.id)::integer,
    'would_recommend_count', COUNT(r.id) FILTER (WHERE r.would_recommend = true)::integer,
    'would_recommend_total', COUNT(r.id) FILTER (WHERE r.would_recommend IS NOT NULL)::integer
  )
  INTO profile_ratings
  FROM reviews r
  WHERE r.reviewee_id = user_id
    AND r.deleted_at IS NULL;

  -- Get badges data
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ub.id,
      'badge_id', ub.badge_id,
      'awarded_at', ub.created_at,
      'badge', jsonb_build_object(
        'code', b.code,
        'title', b.title,
        'description', COALESCE(b.description, ''),
        'icon', COALESCE(b.icon, ''),
        'category', COALESCE(b.badge_type, 'earned'),
        'tier', 1
      )
    )
  ), '[]'::jsonb)
  INTO profile_badges
  FROM user_badges ub
  INNER JOIN badges b ON b.id = ub.badge_id
  WHERE ub.user_id = user_id;

  -- Get skills data (for mechanics only)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ms.id,
      'is_verified', COALESCE(ms.is_verified, false),
      'verified_job_count', 0,
      'avg_job_rating', null,
      'skill', jsonb_build_object(
        'key', s.id,
        'label', s.name,
        'name', s.name,
        'category', COALESCE(s.category, 'general')
      )
    )
  ), '[]'::jsonb)
  INTO profile_skills
  FROM mechanic_skills ms
  INNER JOIN skills s ON s.id = ms.skill_id
  WHERE ms.mechanic_id = user_id
    AND ms.deleted_at IS NULL;

  -- Build trust score
  SELECT jsonb_build_object(
    'overall_score', 50,
    'rating_score', CASE WHEN (profile_ratings->>'review_count')::int > 0 
      THEN LEAST(100, (profile_ratings->>'overall_avg')::numeric * 20) 
      ELSE 50 END,
    'completion_score', 50,
    'reliability_score', 50,
    'badge_score', LEAST(100, jsonb_array_length(profile_badges) * 20),
    'tenure_score', 50,
    'completed_jobs', 0,
    'total_jobs', 0
  ) INTO profile_trust_score;

  -- Build final result
  SELECT jsonb_build_object(
    'id', p.id,
    'role', p.role,
    'display_name', COALESCE(p.full_name, 'Unknown User'),
    'avatar_url', p.avatar_url,
    'created_at', p.created_at,
    'ratings', profile_ratings,
    'badges', profile_badges,
    'skills', profile_skills,
    'trust_score', profile_trust_score
  )
  INTO result
  FROM profiles p
  WHERE p.auth_id = user_id
    AND p.deleted_at IS NULL;

  RETURN result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO anon;\n-- ===================================================================
-- END: 0080_update_get_public_profile_card.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0081_service_hubs.sql
-- ===================================================================\n
-- ============================================================================
-- Migration: 20250213000001_service_hubs.sql
-- ============================================================================
-- Purpose: Service hubs for geographic launch management and metrics tracking
-- Dependencies: 20250111000001 (profiles, mechanic_profiles tables)
-- Risk Level: Low (new tables, idempotent)
-- Rollback: DROP TABLE launch_metrics, service_hubs CASCADE;
--
-- TABLES: service_hubs, launch_metrics
-- VIEWS: hub_health_dashboard
-- FUNCTIONS: populate_daily_launch_metrics()
-- ============================================================================

-- Service hubs and launch metrics (no PostGIS)

-- Service hubs table
CREATE TABLE IF NOT EXISTS service_hubs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  slug VARCHAR(50) UNIQUE NOT NULL,
  zip VARCHAR(10) NOT NULL,
  lat DECIMAL(9,6) NOT NULL,
  lng DECIMAL(9,6) NOT NULL,
  max_radius_miles INTEGER DEFAULT 100,
  active_radius_miles INTEGER DEFAULT 25,
  is_active BOOLEAN DEFAULT true,
  invite_only BOOLEAN DEFAULT true,
  launch_date DATE,
  settings JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Launch metrics table
CREATE TABLE IF NOT EXISTS launch_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  hub_id UUID REFERENCES service_hubs(id) NOT NULL,
  date DATE NOT NULL,
  active_mechanics INTEGER DEFAULT 0,
  new_mechanics INTEGER DEFAULT 0,
  active_customers INTEGER DEFAULT 0,
  jobs_requested INTEGER DEFAULT 0,
  jobs_completed INTEGER DEFAULT 0,
  median_response_minutes INTEGER,
  completion_rate DECIMAL(5,2),
  jobs_per_mechanic DECIMAL(5,2),
  complaints INTEGER DEFAULT 0,
  no_shows INTEGER DEFAULT 0,
  UNIQUE(hub_id, date)
);

-- Add active_customers column if it doesn't exist (for existing tables)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public'
    AND table_name = 'launch_metrics'
    AND column_name = 'active_customers'
  ) THEN
    ALTER TABLE launch_metrics ADD COLUMN active_customers INTEGER DEFAULT 0;
  END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_launch_metrics_hub_date ON launch_metrics(hub_id, date DESC);

-- Hub health dashboard view
DROP VIEW IF EXISTS hub_health_dashboard;
CREATE VIEW hub_health_dashboard AS
SELECT
  h.id,
  h.name,
  h.slug,
  h.zip,
  h.is_active as status,
  COALESCE(m.active_mechanics, 0) as active_mechanics,
  COALESCE(m.active_customers, 0) as active_customers,
  COALESCE(m.jobs_completed, 0) as jobs_completed,
  COALESCE(m.median_response_minutes, 0) as avg_response_time_minutes
FROM service_hubs h
LEFT JOIN LATERAL (
  SELECT * FROM launch_metrics lm
  WHERE lm.hub_id = h.id
  ORDER BY lm.date DESC
  LIMIT 1
) m ON true;

-- Function to populate launch metrics
CREATE OR REPLACE FUNCTION populate_daily_launch_metrics()
RETURNS void AS $$
DECLARE
  hub RECORD;
  mechanic_count INTEGER;
  customer_count INTEGER;
  jobs_req INTEGER;
  jobs_comp INTEGER;
BEGIN
  FOR hub IN SELECT id, lat, lng, active_radius_miles FROM service_hubs WHERE is_active = true
  LOOP
    -- Count mechanics within hub radius using Haversine
    SELECT COUNT(*) INTO mechanic_count
    FROM profiles p
    JOIN mechanic_profiles mp ON mp.id = p.id
    WHERE p.role = 'mechanic'
      AND p.deleted_at IS NULL
      AND mp.deleted_at IS NULL
      AND mp.is_available = true
      AND p.home_lat IS NOT NULL
      AND p.home_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(p.home_lat)) *
        cos(radians(p.home_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(p.home_lat))
      )) <= hub.active_radius_miles;

    -- Count customers within hub radius using Haversine
    SELECT COUNT(*) INTO customer_count
    FROM profiles p
    WHERE p.role = 'customer'
      AND p.deleted_at IS NULL
      AND p.home_lat IS NOT NULL
      AND p.home_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(p.home_lat)) *
        cos(radians(p.home_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(p.home_lat))
      )) <= hub.active_radius_miles;

    -- Count jobs today
    SELECT COUNT(*) INTO jobs_req
    FROM jobs j
    WHERE j.created_at::date = CURRENT_DATE
      AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(j.location_lat))
      )) <= hub.active_radius_miles;

    SELECT COUNT(*) INTO jobs_comp
    FROM jobs j
    WHERE j.status = 'completed'
      AND j.updated_at::date = CURRENT_DATE
      AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(j.location_lat))
      )) <= hub.active_radius_miles;

    INSERT INTO launch_metrics (hub_id, date, active_mechanics, active_customers, jobs_requested, jobs_completed)
    VALUES (hub.id, CURRENT_DATE, mechanic_count, customer_count, jobs_req, jobs_comp)
    ON CONFLICT (hub_id, date) DO UPDATE SET
      active_mechanics = EXCLUDED.active_mechanics,
      active_customers = EXCLUDED.active_customers,
      jobs_requested = EXCLUDED.jobs_requested,
      jobs_completed = EXCLUDED.jobs_completed;
  END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grants
GRANT SELECT ON service_hubs TO authenticated;
GRANT SELECT ON launch_metrics TO authenticated;
GRANT SELECT ON hub_health_dashboard TO authenticated;
GRANT EXECUTE ON FUNCTION populate_daily_launch_metrics TO authenticated;



-- Populate initial metrics
SELECT populate_daily_launch_metrics();
\n-- ===================================================================
-- END: 0081_service_hubs.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0082_fix_launch_metrics_mechanic_count.sql
-- ===================================================================\n
-- ============================================================================
-- Migration: 20250213000007_fix_launch_metrics_mechanic_count.sql
-- ============================================================================
-- Purpose: Fix mechanic counting in populate_daily_launch_metrics using LEFT JOIN
-- Dependencies: 20250213000001 (service_hubs, launch_metrics, populate_daily_launch_metrics)
-- Risk Level: Low (function replacement)
-- Rollback: Restore previous populate_daily_launch_metrics function
-- ============================================================================

-- Fix populate_daily_launch_metrics to count mechanics from profiles only
-- mechanic_profiles row is optional

CREATE OR REPLACE FUNCTION populate_daily_launch_metrics()
RETURNS void AS $$
DECLARE
  hub RECORD;
  mechanic_count INTEGER;
  jobs_req INTEGER;
  jobs_comp INTEGER;
BEGIN
  FOR hub IN SELECT id, lat, lng, active_radius_miles FROM service_hubs WHERE is_active = true
  LOOP
    -- Count mechanics within hub radius using Haversine
    -- Only requires profiles.role = 'mechanic', mechanic_profiles is optional
    SELECT COUNT(*) INTO mechanic_count
    FROM profiles p
    LEFT JOIN mechanic_profiles mp ON mp.id = p.id
    WHERE p.role = 'mechanic'
      AND p.deleted_at IS NULL
      AND (mp.id IS NULL OR (mp.deleted_at IS NULL AND mp.is_available = true))
      AND p.home_lat IS NOT NULL
      AND p.home_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(p.home_lat)) *
        cos(radians(p.home_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(p.home_lat))
      )) <= hub.active_radius_miles;

    -- Count jobs today
    SELECT COUNT(*) INTO jobs_req
    FROM jobs j
    WHERE j.created_at::date = CURRENT_DATE
      AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(j.location_lat))
      )) <= hub.active_radius_miles;

    SELECT COUNT(*) INTO jobs_comp
    FROM jobs j
    WHERE j.status = 'completed'
      AND j.updated_at::date = CURRENT_DATE
      AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(j.location_lat))
      )) <= hub.active_radius_miles;

    INSERT INTO launch_metrics (hub_id, date, active_mechanics, jobs_requested, jobs_completed)
    VALUES (hub.id, CURRENT_DATE, mechanic_count, jobs_req, jobs_comp)
    ON CONFLICT (hub_id, date) DO UPDATE SET
      active_mechanics = EXCLUDED.active_mechanics,
      jobs_requested = EXCLUDED.jobs_requested,
      jobs_completed = EXCLUDED.jobs_completed;
  END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Re-run to update metrics
SELECT populate_daily_launch_metrics();
\n-- ===================================================================
-- END: 0082_fix_launch_metrics_mechanic_count.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0083_add_customers_to_launch_metrics.sql
-- ===================================================================\n
-- ============================================================================
-- Migration: 20250213000008_add_customers_to_launch_metrics.sql
-- ============================================================================
-- Purpose: Add active_customers tracking to launch_metrics and hub_health_dashboard
-- Dependencies: 20250213000007 (launch_metrics, populate_daily_launch_metrics)
-- Risk Level: Low (additive column, function replacement)
-- Rollback: ALTER TABLE launch_metrics DROP COLUMN active_customers;
-- ============================================================================

-- Add active_customers column to launch_metrics and update function

ALTER TABLE launch_metrics ADD COLUMN IF NOT EXISTS active_customers INTEGER DEFAULT 0;

CREATE OR REPLACE FUNCTION populate_daily_launch_metrics()
RETURNS void AS $$
DECLARE
  hub RECORD;
  mechanic_count INTEGER;
  customer_count INTEGER;
  jobs_req INTEGER;
  jobs_comp INTEGER;
BEGIN
  FOR hub IN SELECT id, lat, lng, active_radius_miles FROM service_hubs WHERE is_active = true
  LOOP
    -- Count mechanics within hub radius
    SELECT COUNT(*) INTO mechanic_count
    FROM profiles p
    LEFT JOIN mechanic_profiles mp ON mp.id = p.id
    WHERE p.role = 'mechanic'
      AND p.deleted_at IS NULL
      AND (mp.id IS NULL OR (mp.deleted_at IS NULL AND mp.is_available = true))
      AND p.home_lat IS NOT NULL
      AND p.home_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(p.home_lat)) *
        cos(radians(p.home_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(p.home_lat))
      )) <= hub.active_radius_miles;

    -- Count customers within hub radius
    SELECT COUNT(*) INTO customer_count
    FROM profiles p
    WHERE p.role = 'customer'
      AND p.deleted_at IS NULL
      AND p.home_lat IS NOT NULL
      AND p.home_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(p.home_lat)) *
        cos(radians(p.home_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(p.home_lat))
      )) <= hub.active_radius_miles;

    -- Count jobs today
    SELECT COUNT(*) INTO jobs_req
    FROM jobs j
    WHERE j.created_at::date = CURRENT_DATE
      AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(j.location_lat))
      )) <= hub.active_radius_miles;

    SELECT COUNT(*) INTO jobs_comp
    FROM jobs j
    WHERE j.status = 'completed'
      AND j.updated_at::date = CURRENT_DATE
      AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(j.location_lat))
      )) <= hub.active_radius_miles;

    INSERT INTO launch_metrics (hub_id, date, active_mechanics, active_customers, jobs_requested, jobs_completed)
    VALUES (hub.id, CURRENT_DATE, mechanic_count, customer_count, jobs_req, jobs_comp)
    ON CONFLICT (hub_id, date) DO UPDATE SET
      active_mechanics = EXCLUDED.active_mechanics,
      active_customers = EXCLUDED.active_customers,
      jobs_requested = EXCLUDED.jobs_requested,
      jobs_completed = EXCLUDED.jobs_completed;
  END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop and recreate view to add new column
DROP VIEW IF EXISTS hub_health_dashboard;

CREATE VIEW hub_health_dashboard AS
SELECT 
  h.id,
  h.name,
  h.slug,
  h.zip,
  h.is_active as status,
  COALESCE(m.active_mechanics, 0) as active_mechanics,
  COALESCE(m.active_customers, 0) as active_customers,
  COALESCE(m.jobs_completed, 0) as jobs_completed,
  COALESCE(m.median_response_minutes, 0) as avg_response_time_minutes
FROM service_hubs h
LEFT JOIN LATERAL (
  SELECT * FROM launch_metrics lm 
  WHERE lm.hub_id = h.id 
  ORDER BY lm.date DESC 
  LIMIT 1
) m ON true;

GRANT SELECT ON hub_health_dashboard TO authenticated;

-- Re-run to update metrics
SELECT populate_daily_launch_metrics();\n-- ===================================================================
-- END: 0083_add_customers_to_launch_metrics.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0084_add_check_mechanic_service_area.sql
-- ===================================================================\n
-- ============================================================================
-- Migration: 20250213000009_add_check_mechanic_service_area.sql
-- ============================================================================
-- Purpose: Add function to check if mechanic is within any active service hub
-- Dependencies: 20250213000001 (service_hubs), 20250111000001 (profiles)
-- Risk Level: Low (new function)
-- Rollback: DROP FUNCTION check_mechanic_service_area;
-- ============================================================================

-- Create check_mechanic_service_area function
-- Returns true if mechanic is within any active service hub's radius

CREATE OR REPLACE FUNCTION check_mechanic_service_area(p_mechanic_id uuid)
RETURNS boolean AS $$
DECLARE
  mechanic_lat double precision;
  mechanic_lng double precision;
  is_in_area boolean := false;
BEGIN
  SELECT home_lat, home_lng INTO mechanic_lat, mechanic_lng
  FROM profiles
  WHERE id = p_mechanic_id AND deleted_at IS NULL;

  IF mechanic_lat IS NULL OR mechanic_lng IS NULL THEN
    RETURN false;
  END IF;

  SELECT EXISTS (
    SELECT 1 FROM service_hubs h
    WHERE h.is_active = true
      AND (3959 * acos(
        cos(radians(h.lat)) * cos(radians(mechanic_lat)) *
        cos(radians(mechanic_lng) - radians(h.lng)) +
        sin(radians(h.lat)) * sin(radians(mechanic_lat))
      )) <= h.active_radius_miles
  ) INTO is_in_area;

  RETURN is_in_area;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

GRANT EXECUTE ON FUNCTION check_mechanic_service_area(uuid) TO authenticated;
\n-- ===================================================================
-- END: 0084_add_check_mechanic_service_area.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0085_add_check_customer_service_area.sql
-- ===================================================================\n
-- ============================================================================
-- Migration: 20250213000010_add_check_customer_service_area.sql
-- ============================================================================
-- Purpose: Add functions to check if customer/user/location is within service area
-- Dependencies: 20250213000001 (service_hubs), 20250111000001 (profiles)
-- Risk Level: Low (new functions)
-- Rollback: DROP FUNCTION check_customer_service_area, check_user_service_area, check_location_in_service_area;
-- ============================================================================

-- Create check_customer_service_area function
-- Returns true if customer location is within any active service hub's radius

CREATE OR REPLACE FUNCTION check_customer_service_area(p_customer_id uuid)
RETURNS boolean AS $$
DECLARE
  customer_lat double precision;
  customer_lng double precision;
  is_in_area boolean := false;
BEGIN
  SELECT home_lat, home_lng INTO customer_lat, customer_lng
  FROM profiles
  WHERE id = p_customer_id AND deleted_at IS NULL;

  IF customer_lat IS NULL OR customer_lng IS NULL THEN
    RETURN false;
  END IF;

  SELECT EXISTS (
    SELECT 1 FROM service_hubs h
    WHERE h.is_active = true
      AND (3959 * acos(
        cos(radians(h.lat)) * cos(radians(customer_lat)) *
        cos(radians(customer_lng) - radians(h.lng)) +
        sin(radians(h.lat)) * sin(radians(customer_lat))
      )) <= h.active_radius_miles
  ) INTO is_in_area;

  RETURN is_in_area;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

-- Generic function that works for any user (customer or mechanic)
CREATE OR REPLACE FUNCTION check_user_service_area(p_user_id uuid)
RETURNS boolean AS $$
DECLARE
  user_lat double precision;
  user_lng double precision;
  is_in_area boolean := false;
BEGIN
  SELECT home_lat, home_lng INTO user_lat, user_lng
  FROM profiles
  WHERE id = p_user_id AND deleted_at IS NULL;

  IF user_lat IS NULL OR user_lng IS NULL THEN
    RETURN false;
  END IF;

  SELECT EXISTS (
    SELECT 1 FROM service_hubs h
    WHERE h.is_active = true
      AND (3959 * acos(
        cos(radians(h.lat)) * cos(radians(user_lat)) *
        cos(radians(user_lng) - radians(h.lng)) +
        sin(radians(h.lat)) * sin(radians(user_lat))
      )) <= h.active_radius_miles
  ) INTO is_in_area;

  RETURN is_in_area;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

-- Check by coordinates (for job location checks)
CREATE OR REPLACE FUNCTION check_location_in_service_area(p_lat double precision, p_lng double precision)
RETURNS boolean AS $$
BEGIN
  IF p_lat IS NULL OR p_lng IS NULL THEN
    RETURN false;
  END IF;

  RETURN EXISTS (
    SELECT 1 FROM service_hubs h
    WHERE h.is_active = true
      AND (3959 * acos(
        cos(radians(h.lat)) * cos(radians(p_lat)) *
        cos(radians(p_lng) - radians(h.lng)) +
        sin(radians(h.lat)) * sin(radians(p_lat))
      )) <= h.active_radius_miles
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

GRANT EXECUTE ON FUNCTION check_customer_service_area(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION check_user_service_area(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION check_location_in_service_area(double precision, double precision) TO authenticated;
\n-- ===================================================================
-- END: 0085_add_check_customer_service_area.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0086_add_get_nearest_hub.sql
-- ===================================================================\n
-- ============================================================================
-- Migration: 20250213000011_add_get_nearest_hub.sql
-- ============================================================================
-- Purpose: Add RPC function to find nearest service hub for a location
-- Dependencies: 20250213000001 (service_hubs table)
-- Risk Level: Low (new function)
-- Rollback: DROP FUNCTION get_nearest_hub;
-- ============================================================================

-- Create get_nearest_hub function for service area checks
-- Returns the nearest hub and distance info for a given location

-- Drop all existing versions to avoid overload conflicts
DROP FUNCTION IF EXISTS get_nearest_hub(double precision, double precision);
DROP FUNCTION IF EXISTS get_nearest_hub(numeric, numeric);
DROP FUNCTION IF EXISTS get_nearest_hub(decimal, decimal);

CREATE OR REPLACE FUNCTION get_nearest_hub(check_lat double precision, check_lng double precision)
RETURNS TABLE (
  hub_id uuid,
  hub_name varchar,
  hub_slug varchar,
  distance_miles numeric,
  radius_miles integer,
  active_radius_miles integer,
  is_within_area boolean,
  invite_only boolean
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    h.id AS hub_id,
    h.name AS hub_name,
    h.slug AS hub_slug,
    ROUND((3959 * acos(
      cos(radians(h.lat)) * cos(radians(check_lat)) *
      cos(radians(check_lng) - radians(h.lng)) +
      sin(radians(h.lat)) * sin(radians(check_lat))
    ))::numeric, 1) AS distance_miles,
    h.max_radius_miles AS radius_miles,
    h.active_radius_miles,
    (3959 * acos(
      cos(radians(h.lat)) * cos(radians(check_lat)) *
      cos(radians(check_lng) - radians(h.lng)) +
      sin(radians(h.lat)) * sin(radians(check_lat))
    )) <= h.active_radius_miles AS is_within_area,
    h.invite_only
  FROM service_hubs h
  WHERE h.is_active = true
  ORDER BY (3959 * acos(
    cos(radians(h.lat)) * cos(radians(check_lat)) *
    cos(radians(check_lng) - radians(h.lng)) +
    sin(radians(h.lat)) * sin(radians(check_lat))
  )) ASC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

GRANT EXECUTE ON FUNCTION get_nearest_hub(double precision, double precision) TO authenticated;
GRANT EXECUTE ON FUNCTION get_nearest_hub(double precision, double precision) TO anon;
\n-- ===================================================================
-- END: 0086_add_get_nearest_hub.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0087_service_hubs.sql
-- ===================================================================\n
-- ============================================================================
-- Migration: 20250213000001_service_hubs.sql
-- ============================================================================
-- Purpose: Service hubs for geographic launch management and metrics tracking
-- Dependencies: 20250111000001 (profiles, mechanic_profiles tables)
-- Risk Level: Low (new tables, idempotent)
-- Rollback: DROP TABLE launch_metrics, service_hubs CASCADE;
--
-- TABLES: service_hubs, launch_metrics
-- VIEWS: hub_health_dashboard
-- FUNCTIONS: populate_daily_launch_metrics()
-- ============================================================================

-- Service hubs and launch metrics (no PostGIS)

-- Service hubs table
CREATE TABLE IF NOT EXISTS service_hubs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  slug VARCHAR(50) UNIQUE NOT NULL,
  zip VARCHAR(10) NOT NULL,
  lat DECIMAL(9,6) NOT NULL,
  lng DECIMAL(9,6) NOT NULL,
  max_radius_miles INTEGER DEFAULT 100,
  active_radius_miles INTEGER DEFAULT 25,
  is_active BOOLEAN DEFAULT true,
  invite_only BOOLEAN DEFAULT true,
  launch_date DATE,
  settings JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Launch metrics table
CREATE TABLE IF NOT EXISTS launch_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  hub_id UUID REFERENCES service_hubs(id) NOT NULL,
  date DATE NOT NULL,
  active_mechanics INTEGER DEFAULT 0,
  new_mechanics INTEGER DEFAULT 0,
  jobs_requested INTEGER DEFAULT 0,
  jobs_completed INTEGER DEFAULT 0,
  median_response_minutes INTEGER,
  completion_rate DECIMAL(5,2),
  jobs_per_mechanic DECIMAL(5,2),
  complaints INTEGER DEFAULT 0,
  no_shows INTEGER DEFAULT 0,
  UNIQUE(hub_id, date)
);

CREATE INDEX IF NOT EXISTS idx_launch_metrics_hub_date ON launch_metrics(hub_id, date DESC);

-- Hub health dashboard view
DROP VIEW IF EXISTS hub_health_dashboard;
CREATE VIEW hub_health_dashboard AS
SELECT
  h.id,
  h.name,
  h.slug,
  h.zip,
  h.is_active as status,
  COALESCE(m.active_mechanics, 0) as active_mechanics,
  COALESCE(m.jobs_completed, 0) as jobs_completed,
  COALESCE(m.median_response_minutes, 0) as avg_response_time_minutes
FROM service_hubs h
LEFT JOIN LATERAL (
  SELECT * FROM launch_metrics lm
  WHERE lm.hub_id = h.id
  ORDER BY lm.date DESC
  LIMIT 1
) m ON true;

-- Function to populate launch metrics
CREATE OR REPLACE FUNCTION populate_daily_launch_metrics()
RETURNS void AS $$
DECLARE
  hub RECORD;
  mechanic_count INTEGER;
  jobs_req INTEGER;
  jobs_comp INTEGER;
BEGIN
  FOR hub IN SELECT id, lat, lng, active_radius_miles FROM service_hubs WHERE is_active = true
  LOOP
    -- Count mechanics within hub radius using Haversine
    SELECT COUNT(*) INTO mechanic_count
    FROM profiles p
    JOIN mechanic_profiles mp ON mp.id = p.id
    WHERE p.role = 'mechanic'
      AND p.deleted_at IS NULL
      AND mp.deleted_at IS NULL
      AND mp.is_available = true
      AND p.home_lat IS NOT NULL
      AND p.home_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(p.home_lat)) *
        cos(radians(p.home_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(p.home_lat))
      )) <= hub.active_radius_miles;

    -- Count jobs today
    SELECT COUNT(*) INTO jobs_req
    FROM jobs j
    WHERE j.created_at::date = CURRENT_DATE
      AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(j.location_lat))
      )) <= hub.active_radius_miles;

    SELECT COUNT(*) INTO jobs_comp
    FROM jobs j
    WHERE j.status = 'completed'
      AND j.updated_at::date = CURRENT_DATE
      AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(j.location_lat))
      )) <= hub.active_radius_miles;

    INSERT INTO launch_metrics (hub_id, date, active_mechanics, jobs_requested, jobs_completed)
    VALUES (hub.id, CURRENT_DATE, mechanic_count, jobs_req, jobs_comp)
    ON CONFLICT (hub_id, date) DO UPDATE SET
      active_mechanics = EXCLUDED.active_mechanics,
      jobs_requested = EXCLUDED.jobs_requested,
      jobs_completed = EXCLUDED.jobs_completed;
  END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grants
GRANT SELECT ON service_hubs TO authenticated;
GRANT SELECT ON launch_metrics TO authenticated;
GRANT SELECT ON hub_health_dashboard TO authenticated;
GRANT EXECUTE ON FUNCTION populate_daily_launch_metrics TO authenticated;

-- Insert Chicago hub
INSERT INTO service_hubs (name, slug, zip, lat, lng, active_radius_miles, is_active)
VALUES ('Chicago', 'chicago', '60453', 41.7200, -87.7400, 50, true)
ON CONFLICT (slug) DO NOTHING;

-- Populate initial metrics
SELECT populate_daily_launch_metrics();
\n-- ===================================================================
-- END: 0087_service_hubs.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0088_service_hubs.sql
-- ===================================================================\n
-- ============================================================================
-- Migration: 20250213000001_service_hubs.sql
-- ============================================================================
-- Purpose: Service hubs for geographic launch management and metrics tracking
-- Dependencies: 20250111000001 (profiles, mechanic_profiles tables)
-- Risk Level: Low (new tables, idempotent)
-- Rollback: DROP TABLE launch_metrics, service_hubs CASCADE;
--
-- TABLES: service_hubs, launch_metrics
-- VIEWS: hub_health_dashboard
-- FUNCTIONS: populate_daily_launch_metrics()
-- ============================================================================

-- Service hubs and launch metrics (no PostGIS)

-- Service hubs table
CREATE TABLE IF NOT EXISTS service_hubs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  slug VARCHAR(50) UNIQUE NOT NULL,
  zip VARCHAR(10) NOT NULL,
  lat DECIMAL(9,6) NOT NULL,
  lng DECIMAL(9,6) NOT NULL,
  max_radius_miles INTEGER DEFAULT 100,
  active_radius_miles INTEGER DEFAULT 25,
  is_active BOOLEAN DEFAULT true,
  invite_only BOOLEAN DEFAULT true,
  launch_date DATE,
  settings JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Launch metrics table
CREATE TABLE IF NOT EXISTS launch_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  hub_id UUID REFERENCES service_hubs(id) NOT NULL,
  date DATE NOT NULL,
  active_mechanics INTEGER DEFAULT 0,
  active_customers INTEGER DEFAULT 0,
  new_mechanics INTEGER DEFAULT 0,
  jobs_requested INTEGER DEFAULT 0,
  jobs_completed INTEGER DEFAULT 0,
  median_response_minutes INTEGER,
  completion_rate DECIMAL(5,2),
  jobs_per_mechanic DECIMAL(5,2),
  complaints INTEGER DEFAULT 0,
  no_shows INTEGER DEFAULT 0,
  UNIQUE(hub_id, date)
);

ALTER TABLE launch_metrics ADD COLUMN IF NOT EXISTS active_customers INTEGER DEFAULT 0;

CREATE INDEX IF NOT EXISTS idx_launch_metrics_hub_date ON launch_metrics(hub_id, date DESC);

-- Hub health dashboard view
DROP VIEW IF EXISTS hub_health_dashboard;
CREATE VIEW hub_health_dashboard AS
SELECT
  h.id,
  h.name,
  h.slug,
  h.zip,
  h.is_active as status,
  COALESCE(m.active_mechanics, 0) as active_mechanics,
  COALESCE(m.active_customers, 0) as active_customers,
  COALESCE(m.jobs_completed, 0) as jobs_completed,
  COALESCE(m.median_response_minutes, 0) as avg_response_time_minutes
FROM service_hubs h
LEFT JOIN LATERAL (
  SELECT * FROM launch_metrics lm
  WHERE lm.hub_id = h.id
  ORDER BY lm.date DESC
  LIMIT 1
) m ON true;

-- Function to populate launch metrics
CREATE OR REPLACE FUNCTION populate_daily_launch_metrics()
RETURNS void AS $$
DECLARE
  hub RECORD;
  mechanic_count INTEGER;
  customer_count INTEGER;
  jobs_req INTEGER;
  jobs_comp INTEGER;
BEGIN
  FOR hub IN SELECT id, lat, lng, active_radius_miles FROM service_hubs WHERE is_active = true
  LOOP
    -- Count mechanics within hub radius using Haversine
    SELECT COUNT(*) INTO mechanic_count
    FROM profiles p
    LEFT JOIN mechanic_profiles mp ON mp.id = p.id
    WHERE p.role = 'mechanic'
      AND p.deleted_at IS NULL
      AND (mp.id IS NULL OR (mp.deleted_at IS NULL AND mp.is_available = true))
      AND p.home_lat IS NOT NULL
      AND p.home_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(p.home_lat)) *
        cos(radians(p.home_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(p.home_lat))
      )) <= hub.active_radius_miles;

    -- Count customers within hub radius
    SELECT COUNT(*) INTO customer_count
    FROM profiles p
    WHERE p.role = 'customer'
      AND p.deleted_at IS NULL
      AND p.home_lat IS NOT NULL
      AND p.home_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(p.home_lat)) *
        cos(radians(p.home_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(p.home_lat))
      )) <= hub.active_radius_miles;

    -- Count jobs today
    SELECT COUNT(*) INTO jobs_req
    FROM jobs j
    WHERE j.created_at::date = CURRENT_DATE
      AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(j.location_lat))
      )) <= hub.active_radius_miles;

    SELECT COUNT(*) INTO jobs_comp
    FROM jobs j
    WHERE j.status = 'completed'
      AND j.updated_at::date = CURRENT_DATE
      AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      AND (3959 * acos(
        cos(radians(hub.lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(hub.lng)) +
        sin(radians(hub.lat)) * sin(radians(j.location_lat))
      )) <= hub.active_radius_miles;

    INSERT INTO launch_metrics (hub_id, date, active_mechanics, active_customers, jobs_requested, jobs_completed)
    VALUES (hub.id, CURRENT_DATE, mechanic_count, customer_count, jobs_req, jobs_comp)
    ON CONFLICT (hub_id, date) DO UPDATE SET
      active_mechanics = EXCLUDED.active_mechanics,
      active_customers = EXCLUDED.active_customers,
      jobs_requested = EXCLUDED.jobs_requested,
      jobs_completed = EXCLUDED.jobs_completed;
  END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grants
GRANT SELECT ON service_hubs TO authenticated;
GRANT SELECT ON launch_metrics TO authenticated;
GRANT SELECT ON hub_health_dashboard TO authenticated;
GRANT EXECUTE ON FUNCTION populate_daily_launch_metrics TO authenticated;

-- Insert Chicago hub
INSERT INTO service_hubs (name, slug, zip, lat, lng, active_radius_miles, is_active)
VALUES ('Chicago', 'chicago', '60453', 41.7200, -87.7400, 50, true)
ON CONFLICT (slug) DO NOTHING;

-- Populate initial metrics
SELECT populate_daily_launch_metrics();
\n-- ===================================================================
-- END: 0088_service_hubs.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0089_create_get_public_profile_card.sql
-- ===================================================================\n
-- Create get_public_profile_card RPC function
-- Returns public profile data for displaying in quotes flow

CREATE OR REPLACE FUNCTION public.get_public_profile_card(user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  result jsonb;
  profile_record record;
  ratings_data jsonb;
  badges_data jsonb;
  skills_data jsonb;
  trust_data jsonb;
BEGIN
  -- Get basic profile info
  SELECT 
    p.id,
    p.role,
    COALESCE(p.display_name, p.full_name, 'User') as display_name,
    p.avatar_url,
    p.created_at
  INTO profile_record
  FROM public.profiles p
  WHERE p.id = user_id;

  IF NOT FOUND THEN
    RETURN NULL;
  END IF;

  -- Get ratings (aggregate from reviews)
  SELECT jsonb_build_object(
    'overall_avg', COALESCE(AVG(r.overall_rating), 0),
    'performance_avg', COALESCE(AVG(r.performance_rating), 0),
    'timing_avg', COALESCE(AVG(r.timing_rating), 0),
    'cost_avg', COALESCE(AVG(r.cost_rating), 0),
    'professionalism_avg', COALESCE(AVG(r.professionalism_rating), 0),
    'communication_avg', COALESCE(AVG(r.communication_rating), 0),
    'punctuality_avg', COALESCE(AVG(r.punctuality_rating), 0),
    'payment_avg', COALESCE(AVG(r.payment_rating), 0),
    'review_count', COUNT(r.id),
    'would_recommend_count', COUNT(CASE WHEN r.would_recommend THEN 1 END),
    'would_recommend_total', COUNT(CASE WHEN r.would_recommend IS NOT NULL THEN 1 END)
  ) INTO ratings_data
  FROM public.reviews r
  WHERE r.reviewee_id = user_id;

  -- Get badges
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ub.id,
      'badge_id', ub.badge_id,
      'awarded_at', ub.awarded_at,
      'badge', jsonb_build_object(
        'code', b.code,
        'title', b.title,
        'description', b.description,
        'icon', b.icon,
        'category', b.category,
        'tier', b.tier
      )
    )
  ), '[]'::jsonb) INTO badges_data
  FROM public.user_badges ub
  JOIN public.badges b ON b.id = ub.badge_id
  WHERE ub.user_id = user_id;

  -- Get skills (for mechanics)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ms.id,
      'skill', jsonb_build_object(
        'key', s.key,
        'label', COALESCE(s.label, s.name),
        'name', s.name,
        'category', s.category
      ),
      'is_verified', ms.is_verified,
      'verified_job_count', COALESCE(ms.verified_job_count, 0),
      'avg_job_rating', ms.avg_job_rating
    )
  ), '[]'::jsonb) INTO skills_data
  FROM public.mechanic_skills ms
  JOIN public.skills s ON s.id = ms.skill_id
  WHERE ms.mechanic_id = user_id;

  -- Calculate trust score
  SELECT jsonb_build_object(
    'overall_score', 50, -- Default score
    'rating_score', COALESCE((ratings_data->>'overall_avg')::numeric * 10, 0),
    'completion_score', 50,
    'reliability_score', 50,
    'badge_score', LEAST(jsonb_array_length(badges_data) * 5, 50),
    'tenure_score', LEAST(EXTRACT(DAYS FROM (now() - profile_record.created_at)) / 30 * 5, 50),
    'completed_jobs', 0,
    'total_jobs', 0
  ) INTO trust_data;

  -- Build final result
  result := jsonb_build_object(
    'id', profile_record.id,
    'role', profile_record.role,
    'display_name', profile_record.display_name,
    'avatar_url', profile_record.avatar_url,
    'created_at', profile_record.created_at,
    'ratings', COALESCE(ratings_data, '{}'::jsonb),
    'badges', COALESCE(badges_data, '[]'::jsonb),
    'skills', COALESCE(skills_data, '[]'::jsonb),
    'trust_score', COALESCE(trust_data, '{}'::jsonb)
  );

  RETURN result;
END;
$$;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO authenticated;
\n-- ===================================================================
-- END: 0089_create_get_public_profile_card.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0090_create_get_public_profile_card.sql
-- ===================================================================\n
-- Create get_public_profile_card RPC function
-- Returns public profile data for displaying in quotes flow

-- Drop existing function first (may have different parameter name)
DROP FUNCTION IF EXISTS public.get_public_profile_card(uuid);

CREATE OR REPLACE FUNCTION public.get_public_profile_card(p_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  result jsonb;
  profile_record record;
  ratings_data jsonb;
  badges_data jsonb;
  skills_data jsonb;
  trust_data jsonb;
BEGIN
  -- Get basic profile info
  SELECT 
    p.id,
    p.role,
    COALESCE(p.display_name, p.full_name, 'User') as display_name,
    p.avatar_url,
    p.created_at
  INTO profile_record
  FROM public.profiles p
  WHERE p.id = p_user_id;

  IF NOT FOUND THEN
    RETURN NULL;
  END IF;

  -- Get ratings (aggregate from reviews)
  SELECT jsonb_build_object(
    'overall_avg', COALESCE(AVG(r.overall_rating), 0),
    'performance_avg', COALESCE(AVG(r.performance_rating), 0),
    'timing_avg', COALESCE(AVG(r.timing_rating), 0),
    'cost_avg', COALESCE(AVG(r.cost_rating), 0),
    'professionalism_avg', COALESCE(AVG(r.professionalism_rating), 0),
    'communication_avg', COALESCE(AVG(r.communication_rating), 0),
    'punctuality_avg', COALESCE(AVG(r.punctuality_rating), 0),
    'payment_avg', COALESCE(AVG(r.payment_rating), 0),
    'review_count', COUNT(r.id),
    'would_recommend_count', COUNT(CASE WHEN r.would_recommend THEN 1 END),
    'would_recommend_total', COUNT(CASE WHEN r.would_recommend IS NOT NULL THEN 1 END)
  ) INTO ratings_data
  FROM public.reviews r
  WHERE r.reviewee_id = p_user_id;

  -- Get badges
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ub.id,
      'badge_id', ub.badge_id,
      'awarded_at', ub.awarded_at,
      'badge', jsonb_build_object(
        'code', b.code,
        'title', b.title,
        'description', b.description,
        'icon', b.icon,
        'category', b.category,
        'tier', b.tier
      )
    )
  ), '[]'::jsonb) INTO badges_data
  FROM public.user_badges ub
  JOIN public.badges b ON b.id = ub.badge_id
  WHERE ub.user_id = p_user_id;

  -- Get skills (for mechanics) - skills table uses 'key' as PK, mechanic_skills uses 'skill_key'
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ms.id,
      'skill', jsonb_build_object(
        'key', s.key,
        'label', s.label,
        'name', s.label,
        'category', s.category
      ),
      'is_verified', false,
      'verified_job_count', 0,
      'avg_job_rating', null
    )
  ), '[]'::jsonb) INTO skills_data
  FROM public.mechanic_skills ms
  JOIN public.skills s ON s.key = ms.skill_key
  WHERE ms.mechanic_id = p_user_id;

  -- Calculate trust score
  SELECT jsonb_build_object(
    'overall_score', 50,
    'rating_score', COALESCE((ratings_data->>'overall_avg')::numeric * 10, 0),
    'completion_score', 50,
    'reliability_score', 50,
    'badge_score', LEAST(jsonb_array_length(badges_data) * 5, 50),
    'tenure_score', LEAST(EXTRACT(DAYS FROM (now() - profile_record.created_at)) / 30 * 5, 50),
    'completed_jobs', 0,
    'total_jobs', 0
  ) INTO trust_data;

  -- Build final result
  result := jsonb_build_object(
    'id', profile_record.id,
    'role', profile_record.role,
    'display_name', profile_record.display_name,
    'avatar_url', profile_record.avatar_url,
    'created_at', profile_record.created_at,
    'ratings', COALESCE(ratings_data, '{}'::jsonb),
    'badges', COALESCE(badges_data, '[]'::jsonb),
    'skills', COALESCE(skills_data, '[]'::jsonb),
    'trust_score', COALESCE(trust_data, '{}'::jsonb)
  );

  RETURN result;
END;
$$;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO authenticated;
\n-- ===================================================================
-- END: 0090_create_get_public_profile_card.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0091_fix_messages_rls.sql
-- ===================================================================\n
-- Add messages RLS policy to allow job participants to see messages
-- This fixes the issue where customers can't see messages for their jobs

DROP POLICY IF EXISTS "messages_select_job_participant" ON public.messages;
CREATE POLICY "messages_select_job_participant" ON public.messages
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.jobs j
      WHERE j.id = messages.job_id
      AND (j.customer_id = auth.uid() OR j.accepted_mechanic_id = auth.uid())
    )
  );
\n-- ===================================================================
-- END: 0091_fix_messages_rls.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0125_add_admin_role_enum.sql
-- ===================================================================\n
-- Migration: Add 'admin' to user_role enum
-- Required for job_media policies that check for admin role

BEGIN;

-- Add 'admin' to the user_role enum if it doesn't exist
DO $$
BEGIN
  ALTER TYPE public.user_role ADD VALUE IF NOT EXISTS 'admin';
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

COMMIT;
\n-- ===================================================================
-- END: 0125_add_admin_role_enum.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0126_job_media_photo_evidence.sql
-- ===================================================================\n
-- Migration: Job Media Photo Evidence System
-- Enables camera photo attachments for customers and mechanics during job lifecycle
-- Photos can be used as evidence in Support Tickets and Disputes

BEGIN;

-- =====================================================
-- 1. UPDATE job_media RLS POLICIES (drop and recreate for stricter enforcement)
-- =====================================================

DROP POLICY IF EXISTS "Job parties can view media" ON public.job_media;
DROP POLICY IF EXISTS "Participants can upload media" ON public.job_media;
DROP POLICY IF EXISTS "Uploaders can delete own media" ON public.job_media;
DROP POLICY IF EXISTS "job_media_admin_select" ON public.job_media;
DROP POLICY IF EXISTS "job_media_admin_all" ON public.job_media;

-- SELECT: job participants (customer/mechanic) and admins can view
CREATE POLICY "job_media_select_participants" ON public.job_media
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.jobs j
      LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
      WHERE j.id = job_media.job_id
        AND (
          j.customer_id = auth.uid()
          OR jc.mechanic_id = auth.uid()
          OR EXISTS (SELECT 1 FROM public.profiles p WHERE p.id = auth.uid() AND p.role = 'admin')
        )
    )
  );

-- INSERT: only job participants can upload with their role
CREATE POLICY "job_media_insert_participants" ON public.job_media
  FOR INSERT WITH CHECK (
    uploaded_by = auth.uid()
    AND EXISTS (
      SELECT 1 FROM public.jobs j
      LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
      WHERE j.id = job_media.job_id
        AND (
          (j.customer_id = auth.uid() AND job_media.uploaded_by_role = 'customer')
          OR (jc.mechanic_id = auth.uid() AND job_media.uploaded_by_role = 'mechanic')
        )
    )
  );

-- UPDATE: only owner within 10 minutes or admin
CREATE POLICY "job_media_update_owner_or_admin" ON public.job_media
  FOR UPDATE USING (
    (uploaded_by = auth.uid() AND created_at > now() - interval '10 minutes')
    OR EXISTS (SELECT 1 FROM public.profiles p WHERE p.id = auth.uid() AND p.role = 'admin')
  );

-- DELETE: only owner within 10 minutes or admin
CREATE POLICY "job_media_delete_owner_or_admin" ON public.job_media
  FOR DELETE USING (
    (uploaded_by = auth.uid() AND created_at > now() - interval '10 minutes')
    OR EXISTS (SELECT 1 FROM public.profiles p WHERE p.id = auth.uid() AND p.role = 'admin')
  );

-- =====================================================
-- 2. STORAGE BUCKET FOR JOB MEDIA
-- =====================================================

-- Create storage bucket if not exists (handled by Supabase dashboard or seed)
-- INSERT INTO storage.buckets (id, name, public) 
-- VALUES ('job-media', 'job-media', false)
-- ON CONFLICT (id) DO NOTHING;

-- Storage policies for job-media bucket
DROP POLICY IF EXISTS "job_media_storage_select" ON storage.objects;
DROP POLICY IF EXISTS "job_media_storage_insert" ON storage.objects;
DROP POLICY IF EXISTS "job_media_storage_delete" ON storage.objects;

-- SELECT: job participants and admins can read
CREATE POLICY "job_media_storage_select" ON storage.objects
  FOR SELECT USING (
    bucket_id = 'job-media'
    AND (
      EXISTS (
        SELECT 1 FROM public.job_media jm
        JOIN public.jobs j ON j.id = jm.job_id
        LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
        WHERE jm.path = storage.objects.name
          AND (
            j.customer_id = auth.uid()
            OR jc.mechanic_id = auth.uid()
            OR EXISTS (SELECT 1 FROM public.profiles p WHERE p.id = auth.uid() AND p.role = 'admin')
          )
      )
    )
  );

-- INSERT: job participants can upload to their job path
CREATE POLICY "job_media_storage_insert" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'job-media'
    AND (
      -- Path format: {job_id}/{role}/{category}/{uuid}.jpg
      -- Verify the job_id in path belongs to the uploader
      EXISTS (
        SELECT 1 FROM public.jobs j
        LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
        WHERE (
          (j.customer_id = auth.uid() AND storage.objects.name LIKE j.id::text || '/customer/%')
          OR (jc.mechanic_id = auth.uid() AND storage.objects.name LIKE j.id::text || '/mechanic/%')
        )
      )
    )
  );

-- DELETE: only admins can delete from storage
CREATE POLICY "job_media_storage_delete" ON storage.objects
  FOR DELETE USING (
    bucket_id = 'job-media'
    AND EXISTS (SELECT 1 FROM public.profiles p WHERE p.id = auth.uid() AND p.role = 'admin')
  );

-- =====================================================
-- 3. RPC: create_job_media_record
-- =====================================================

CREATE OR REPLACE FUNCTION public.create_job_media_record(
  p_job_id uuid,
  p_media_category text,
  p_path text,
  p_mime_type text,
  p_file_size_bytes bigint,
  p_contract_id uuid DEFAULT NULL,
  p_caption text DEFAULT NULL,
  p_taken_at timestamptz DEFAULT NULL
)
RETURNS public.job_media
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_user_role public.user_role;
  v_is_participant boolean := false;
  v_result public.job_media;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Get user role
  SELECT role INTO v_user_role FROM public.profiles WHERE id = v_user_id;
  IF v_user_role IS NULL THEN
    RAISE EXCEPTION 'User profile not found';
  END IF;

  -- Validate media category
  IF p_media_category NOT IN ('customer_request', 'mechanic_before', 'mechanic_after', 'dispute_evidence', 'support_evidence', 'parts_receipt', 'other') THEN
    RAISE EXCEPTION 'Invalid media category: %', p_media_category;
  END IF;

  -- Check if user is job participant
  SELECT EXISTS (
    SELECT 1 FROM public.jobs j
    LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
    WHERE j.id = p_job_id
      AND (
        (j.customer_id = v_user_id AND v_user_role = 'customer')
        OR (jc.mechanic_id = v_user_id AND v_user_role = 'mechanic')
        OR v_user_role = 'admin'
      )
  ) INTO v_is_participant;

  IF NOT v_is_participant THEN
    RAISE EXCEPTION 'Not authorized to upload media for this job';
  END IF;

  -- Insert the record
  INSERT INTO public.job_media (
    job_id,
    contract_id,
    uploaded_by,
    uploaded_by_role,
    media_type,
    media_category,
    bucket,
    path,
    caption,
    file_size_bytes,
    mime_type,
    taken_at
  ) VALUES (
    p_job_id,
    p_contract_id,
    v_user_id,
    v_user_role,
    'image',
    p_media_category,
    'job-media',
    p_path,
    p_caption,
    p_file_size_bytes,
    p_mime_type,
    p_taken_at
  )
  RETURNING * INTO v_result;

  -- Log to job_events
  INSERT INTO public.job_events (
    job_id,
    contract_id,
    event_type,
    actor_id,
    metadata
  ) VALUES (
    p_job_id,
    p_contract_id,
    'media_uploaded',
    v_user_id,
    jsonb_build_object(
      'media_id', v_result.id,
      'category', p_media_category,
      'role', v_user_role::text
    )
  );

  RETURN v_result;
END;
$$;

-- =====================================================
-- 4. RPC: list_job_media
-- =====================================================

CREATE OR REPLACE FUNCTION public.list_job_media(
  p_job_id uuid,
  p_category text DEFAULT NULL
)
RETURNS SETOF public.job_media
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_user_role public.user_role;
  v_is_authorized boolean := false;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT role INTO v_user_role FROM public.profiles WHERE id = v_user_id;

  -- Check authorization
  SELECT EXISTS (
    SELECT 1 FROM public.jobs j
    LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
    WHERE j.id = p_job_id
      AND (
        j.customer_id = v_user_id
        OR jc.mechanic_id = v_user_id
        OR v_user_role = 'admin'
      )
  ) INTO v_is_authorized;

  IF NOT v_is_authorized THEN
    RAISE EXCEPTION 'Not authorized to view media for this job';
  END IF;

  RETURN QUERY
  SELECT * FROM public.job_media jm
  WHERE jm.job_id = p_job_id
    AND (p_category IS NULL OR jm.media_category = p_category)
  ORDER BY jm.created_at DESC;
END;
$$;

-- =====================================================
-- 5. RPC: attach_media_to_support_request
-- =====================================================

CREATE OR REPLACE FUNCTION public.attach_media_to_support_request(
  p_support_request_id uuid,
  p_media_ids uuid[]
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_user_role public.user_role;
  v_sr_user_id uuid;
  v_current_metadata jsonb;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT role INTO v_user_role FROM public.profiles WHERE id = v_user_id;
  SELECT user_id, metadata INTO v_sr_user_id, v_current_metadata
  FROM public.support_requests WHERE id = p_support_request_id;

  IF v_sr_user_id IS NULL THEN
    RAISE EXCEPTION 'Support request not found';
  END IF;

  -- Only owner or admin can attach media
  IF v_sr_user_id != v_user_id AND v_user_role != 'admin' THEN
    RAISE EXCEPTION 'Not authorized to attach media to this support request';
  END IF;

  -- Update metadata with evidence_media_ids
  UPDATE public.support_requests
  SET metadata = COALESCE(v_current_metadata, '{}'::jsonb) || 
                 jsonb_build_object('evidence_media_ids', to_jsonb(p_media_ids))
  WHERE id = p_support_request_id;

  RETURN true;
END;
$$;

-- =====================================================
-- 6. RPC: attach_media_to_dispute
-- =====================================================

CREATE OR REPLACE FUNCTION public.attach_media_to_dispute(
  p_dispute_id uuid,
  p_media_ids uuid[]
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_user_role public.user_role;
  v_dispute_filed_by uuid;
  v_job_id uuid;
  v_media_paths text[];
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT role INTO v_user_role FROM public.profiles WHERE id = v_user_id;
  SELECT filed_by, job_id INTO v_dispute_filed_by, v_job_id
  FROM public.disputes WHERE id = p_dispute_id;

  IF v_dispute_filed_by IS NULL THEN
    RAISE EXCEPTION 'Dispute not found';
  END IF;

  -- Only filer or admin can attach media
  IF v_dispute_filed_by != v_user_id AND v_user_role != 'admin' THEN
    RAISE EXCEPTION 'Not authorized to attach media to this dispute';
  END IF;

  -- Get paths from job_media for the given IDs
  SELECT array_agg(path) INTO v_media_paths
  FROM public.job_media
  WHERE id = ANY(p_media_ids) AND job_id = v_job_id;

  -- Update dispute evidence_urls
  UPDATE public.disputes
  SET evidence_urls = COALESCE(evidence_urls, ARRAY[]::text[]) || v_media_paths
  WHERE id = p_dispute_id;

  RETURN true;
END;
$$;

-- =====================================================
-- 7. RPC: get_job_evidence_for_admin (for admin screens)
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_job_evidence(p_job_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_user_role public.user_role;
  v_result jsonb;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT role INTO v_user_role FROM public.profiles WHERE id = v_user_id;
  IF v_user_role != 'admin' THEN
    RAISE EXCEPTION 'Admin access required';
  END IF;

  SELECT jsonb_build_object(
    'customer_request', COALESCE((
      SELECT jsonb_agg(row_to_json(m.*))
      FROM public.job_media m WHERE m.job_id = p_job_id AND m.media_category = 'customer_request'
    ), '[]'::jsonb),
    'mechanic_before', COALESCE((
      SELECT jsonb_agg(row_to_json(m.*))
      FROM public.job_media m WHERE m.job_id = p_job_id AND m.media_category = 'mechanic_before'
    ), '[]'::jsonb),
    'mechanic_after', COALESCE((
      SELECT jsonb_agg(row_to_json(m.*))
      FROM public.job_media m WHERE m.job_id = p_job_id AND m.media_category = 'mechanic_after'
    ), '[]'::jsonb),
    'dispute_evidence', COALESCE((
      SELECT jsonb_agg(row_to_json(m.*))
      FROM public.job_media m WHERE m.job_id = p_job_id AND m.media_category = 'dispute_evidence'
    ), '[]'::jsonb),
    'support_evidence', COALESCE((
      SELECT jsonb_agg(row_to_json(m.*))
      FROM public.job_media m WHERE m.job_id = p_job_id AND m.media_category = 'support_evidence'
    ), '[]'::jsonb),
    'parts_receipt', COALESCE((
      SELECT jsonb_agg(row_to_json(m.*))
      FROM public.job_media m WHERE m.job_id = p_job_id AND m.media_category = 'parts_receipt'
    ), '[]'::jsonb),
    'other', COALESCE((
      SELECT jsonb_agg(row_to_json(m.*))
      FROM public.job_media m WHERE m.job_id = p_job_id AND m.media_category = 'other'
    ), '[]'::jsonb)
  ) INTO v_result;

  RETURN v_result;
END;
$$;

-- =====================================================
-- 8. GRANTS
-- =====================================================

GRANT EXECUTE ON FUNCTION public.create_job_media_record(uuid, text, text, text, bigint, uuid, text, timestamptz) TO authenticated;
GRANT EXECUTE ON FUNCTION public.list_job_media(uuid, text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.attach_media_to_support_request(uuid, uuid[]) TO authenticated;
GRANT EXECUTE ON FUNCTION public.attach_media_to_dispute(uuid, uuid[]) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_get_job_evidence(uuid) TO authenticated;

-- =====================================================
-- 9. INDEX for media_category lookups
-- =====================================================

CREATE INDEX IF NOT EXISTS idx_job_media_category ON public.job_media(media_category);
CREATE INDEX IF NOT EXISTS idx_job_media_uploaded_by ON public.job_media(uploaded_by);

COMMIT;
\n-- ===================================================================
-- END: 0126_job_media_photo_evidence.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0127_mechanic_tier_admin_rpcs.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0127: Mechanic Tier + Admin RPCs
-- =====================================================
-- Purpose: Add tier/verification columns to mechanic_profiles
--          Create admin RPCs for mechanics list/detail/tier update
-- =====================================================

BEGIN;

-- =====================================================
-- STEP 1: Add columns to mechanic_profiles
-- =====================================================

-- Add tier column with CHECK constraint
ALTER TABLE mechanic_profiles
ADD COLUMN IF NOT EXISTS tier text NOT NULL DEFAULT 'standard'
  CHECK (tier IN ('probation', 'standard', 'trusted'));

-- Add verification columns
ALTER TABLE mechanic_profiles
ADD COLUMN IF NOT EXISTS verification_status text NOT NULL DEFAULT 'pending_verification'
  CHECK (verification_status IN ('pending_verification', 'active', 'paused', 'removed'));

ALTER TABLE mechanic_profiles
ADD COLUMN IF NOT EXISTS verification_reason text;

ALTER TABLE mechanic_profiles
ADD COLUMN IF NOT EXISTS verification_updated_at timestamptz;

-- Index for faster filtering
CREATE INDEX IF NOT EXISTS idx_mechanic_profiles_verification_status 
  ON mechanic_profiles(verification_status);
CREATE INDEX IF NOT EXISTS idx_mechanic_profiles_tier 
  ON mechanic_profiles(tier);

-- =====================================================
-- STEP 2: Admin Get Mechanics RPC
-- =====================================================

CREATE OR REPLACE FUNCTION admin_get_mechanics(
  p_status text DEFAULT NULL,
  p_hub_id uuid DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  full_name text,
  email text,
  phone text,
  verification_status text,
  tier text,
  hub_id uuid,
  hub_name text,
  rating_avg numeric,
  rating_count int,
  jobs_completed int,
  is_available boolean,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Access denied: admin only';
  END IF;

  RETURN QUERY
  SELECT
    p.id,
    p.full_name,
    p.email,
    p.phone,
    mp.verification_status,
    mp.tier,
    h.id AS hub_id,
    h.name AS hub_name,
    mp.rating_avg,
    mp.rating_count,
    mp.jobs_completed,
    mp.is_available,
    p.created_at
  FROM profiles p
  JOIN mechanic_profiles mp ON mp.id = p.id
  LEFT JOIN hub_mechanics hm ON hm.mechanic_id = p.id AND hm.is_active = true
  LEFT JOIN hubs h ON h.id = hm.hub_id
  WHERE p.role = 'mechanic'
    AND p.deleted_at IS NULL
    AND mp.deleted_at IS NULL
    AND (p_status IS NULL OR mp.verification_status = p_status)
    AND (p_hub_id IS NULL OR h.id = p_hub_id)
  ORDER BY p.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

-- =====================================================
-- STEP 3: Admin Get Mechanic Detail RPC
-- =====================================================

CREATE OR REPLACE FUNCTION admin_get_mechanic_detail(p_mechanic_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result jsonb;
  v_mechanic jsonb;
  v_documents jsonb;
  v_vetting jsonb;
  v_jobs jsonb;
  v_reviews jsonb;
  v_disputes jsonb;
  v_support jsonb;
BEGIN
  IF NOT is_admin() THEN
    RETURN jsonb_build_object('error', 'Access denied: admin only');
  END IF;

  -- Get mechanic profile
  SELECT jsonb_build_object(
    'id', p.id,
    'full_name', p.full_name,
    'email', p.email,
    'phone', p.phone,
    'role', p.role::text,
    'city', p.city,
    'state', p.state,
    'hub_id', h.id,
    'hub_name', h.name,
    'verification_status', mp.verification_status,
    'verification_reason', mp.verification_reason,
    'tier', mp.tier,
    'bio', mp.bio,
    'years_experience', mp.years_experience,
    'hourly_rate_cents', mp.hourly_rate_cents,
    'service_radius_km', mp.service_radius_km,
    'mobile_service', mp.mobile_service,
    'is_available', mp.is_available,
    'rating_avg', mp.rating_avg,
    'rating_count', mp.rating_count,
    'jobs_completed', mp.jobs_completed,
    'stripe_account_id', mp.stripe_account_id,
    'stripe_onboarding_complete', mp.stripe_onboarding_complete,
    'created_at', p.created_at,
    'updated_at', p.updated_at
  ) INTO v_mechanic
  FROM profiles p
  JOIN mechanic_profiles mp ON mp.id = p.id
  LEFT JOIN hub_mechanics hm ON hm.mechanic_id = p.id AND hm.is_active = true
  LEFT JOIN hubs h ON h.id = hm.hub_id
  WHERE p.id = p_mechanic_id;

  IF v_mechanic IS NULL THEN
    RETURN jsonb_build_object('error', 'Mechanic not found');
  END IF;

  -- Get documents (if mechanic_documents table exists)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', d.id,
      'doc_type', d.doc_type,
      'status', d.status,
      'uploaded_at', d.created_at,
      'reviewed_at', d.reviewed_at,
      'review_notes', d.review_notes
    ) ORDER BY d.created_at DESC
  ), '[]'::jsonb) INTO v_documents
  FROM mechanic_documents d
  WHERE d.mechanic_id = p_mechanic_id;

  -- Get vetting responses (if mechanic_vetting_responses table exists)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', v.id,
      'prompt_key', v.prompt_key,
      'prompt_text', vp.prompt_text,
      'response_text', v.response_text,
      'created_at', v.created_at
    ) ORDER BY v.created_at
  ), '[]'::jsonb) INTO v_vetting
  FROM mechanic_vetting_responses v
  LEFT JOIN mechanic_vetting_prompts vp ON vp.prompt_key = v.prompt_key
  WHERE v.mechanic_id = p_mechanic_id;

  -- Get recent jobs
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', j.id,
      'title', j.title,
      'status', j.status::text,
      'customer_name', cp.full_name,
      'created_at', j.created_at,
      'completed_at', j.completed_at
    ) ORDER BY j.created_at DESC
  ), '[]'::jsonb) INTO v_jobs
  FROM jobs j
  JOIN profiles cp ON cp.id = j.customer_id
  WHERE j.accepted_mechanic_id = p_mechanic_id
  LIMIT 20;

  -- Get reviews received
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', r.id,
      'overall_rating', r.overall_rating,
      'comment', r.comment,
      'reviewer_name', rp.full_name,
      'created_at', r.created_at
    ) ORDER BY r.created_at DESC
  ), '[]'::jsonb) INTO v_reviews
  FROM reviews r
  JOIN profiles rp ON rp.id = r.reviewer_id
  WHERE r.reviewee_id = p_mechanic_id
  LIMIT 20;

  -- Get disputes
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', d.id,
      'job_id', d.job_id,
      'status', d.status,
      'category', d.category,
      'created_at', d.created_at,
      'resolved_at', d.resolved_at
    ) ORDER BY d.created_at DESC
  ), '[]'::jsonb) INTO v_disputes
  FROM disputes d
  JOIN jobs j ON j.id = d.job_id
  WHERE j.accepted_mechanic_id = p_mechanic_id
  LIMIT 10;

  -- Get support requests
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', sr.id,
      'job_id', sr.job_id,
      'category', sr.category,
      'status', sr.status,
      'message', sr.message,
      'created_at', sr.created_at
    ) ORDER BY sr.created_at DESC
  ), '[]'::jsonb) INTO v_support
  FROM support_requests sr
  WHERE sr.user_id = p_mechanic_id
  LIMIT 10;

  RETURN jsonb_build_object(
    'mechanic', v_mechanic,
    'documents', COALESCE(v_documents, '[]'::jsonb),
    'vetting', COALESCE(v_vetting, '[]'::jsonb),
    'jobs', COALESCE(v_jobs, '[]'::jsonb),
    'reviews', COALESCE(v_reviews, '[]'::jsonb),
    'disputes', COALESCE(v_disputes, '[]'::jsonb),
    'support_requests', COALESCE(v_support, '[]'::jsonb)
  );

EXCEPTION WHEN undefined_table THEN
  -- Handle missing tables gracefully
  RETURN jsonb_build_object(
    'mechanic', v_mechanic,
    'documents', '[]'::jsonb,
    'vetting', '[]'::jsonb,
    'jobs', '[]'::jsonb,
    'reviews', '[]'::jsonb,
    'disputes', '[]'::jsonb,
    'support_requests', '[]'::jsonb
  );
END;
$$;

-- =====================================================
-- STEP 4: Set Mechanic Tier RPC
-- =====================================================

CREATE OR REPLACE FUNCTION set_mechanic_tier(
  p_mechanic_id uuid,
  p_tier text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_old_tier text;
  v_admin_id uuid := auth.uid();
BEGIN
  IF NOT is_admin() THEN
    RETURN jsonb_build_object('success', false, 'error', 'Access denied: admin only');
  END IF;

  -- Validate tier value
  IF p_tier NOT IN ('probation', 'standard', 'trusted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid tier value');
  END IF;

  -- Get current tier
  SELECT tier INTO v_old_tier
  FROM mechanic_profiles
  WHERE id = p_mechanic_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Mechanic not found');
  END IF;

  -- Update tier
  UPDATE mechanic_profiles
  SET tier = p_tier,
      updated_at = now()
  WHERE id = p_mechanic_id;

  -- Log to audit_log
  INSERT INTO audit_log (actor_id, actor_type, action, entity_type, entity_id, metadata)
  VALUES (
    v_admin_id,
    'admin',
    'ADMIN_SET_MECHANIC_TIER',
    'mechanic_profiles',
    p_mechanic_id,
    jsonb_build_object('old_tier', v_old_tier, 'new_tier', p_tier)
  );

  RETURN jsonb_build_object('success', true, 'old_tier', v_old_tier, 'new_tier', p_tier);
END;
$$;

-- =====================================================
-- STEP 5: Set Mechanic Verification Status RPC
-- =====================================================

CREATE OR REPLACE FUNCTION set_mechanic_verification_status(
  p_mechanic_id uuid,
  p_status text,
  p_rejection_reason text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_old_status text;
  v_admin_id uuid := auth.uid();
BEGIN
  IF NOT is_admin() THEN
    RETURN jsonb_build_object('success', false, 'error', 'Access denied: admin only');
  END IF;

  -- Validate status value
  IF p_status NOT IN ('pending_verification', 'active', 'paused', 'removed') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid status value');
  END IF;

  -- Get current status
  SELECT verification_status INTO v_old_status
  FROM mechanic_profiles
  WHERE id = p_mechanic_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Mechanic not found');
  END IF;

  -- Update status
  UPDATE mechanic_profiles
  SET verification_status = p_status,
      verification_reason = CASE 
        WHEN p_status = 'removed' THEN COALESCE(p_rejection_reason, verification_reason)
        ELSE verification_reason
      END,
      verification_updated_at = now(),
      updated_at = now()
  WHERE id = p_mechanic_id;

  -- Log to audit_log
  INSERT INTO audit_log (actor_id, actor_type, action, entity_type, entity_id, metadata)
  VALUES (
    v_admin_id,
    'admin',
    'ADMIN_SET_VERIFICATION_STATUS',
    'mechanic_profiles',
    p_mechanic_id,
    jsonb_build_object(
      'old_status', v_old_status,
      'new_status', p_status,
      'reason', p_rejection_reason
    )
  );

  RETURN jsonb_build_object('success', true, 'old_status', v_old_status, 'new_status', p_status);
END;
$$;

-- =====================================================
-- STEP 6: Grant permissions
-- =====================================================

GRANT EXECUTE ON FUNCTION admin_get_mechanics TO authenticated;
GRANT EXECUTE ON FUNCTION admin_get_mechanic_detail TO authenticated;
GRANT EXECUTE ON FUNCTION set_mechanic_tier TO authenticated;
GRANT EXECUTE ON FUNCTION set_mechanic_verification_status TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 0127_mechanic_tier_admin_rpcs.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 0128_admin_customer_rpcs.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION 0128: Admin Customer RPCs
-- =====================================================

BEGIN;

-- =====================================================
-- Admin List Customers RPC
-- =====================================================

CREATE OR REPLACE FUNCTION admin_list_customers(
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0,
  p_query text DEFAULT NULL
)
RETURNS TABLE (
  customer_id uuid,
  full_name text,
  email text,
  phone text,
  city text,
  state text,
  hub_id uuid,
  created_at timestamptz,
  total_jobs bigint,
  completed_jobs bigint,
  total_spent_cents bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Access denied: admin only';
  END IF;

  RETURN QUERY
  SELECT
    p.id AS customer_id,
    p.full_name,
    p.email,
    p.phone,
    p.city,
    p.state,
    p.hub_id,
    p.created_at,
    COUNT(j.id) AS total_jobs,
    COUNT(j.id) FILTER (WHERE j.status = 'completed') AS completed_jobs,
    COALESCE(SUM(pay.amount_cents) FILTER (WHERE pay.status = 'paid'), 0)::bigint AS total_spent_cents
  FROM profiles p
  LEFT JOIN jobs j ON j.customer_id = p.id
  LEFT JOIN payments pay ON pay.job_id = j.id
  WHERE p.role = 'customer'
    AND p.deleted_at IS NULL
    AND (
      p_query IS NULL 
      OR p.full_name ILIKE '%' || p_query || '%'
      OR p.email ILIKE '%' || p_query || '%'
      OR p.phone ILIKE '%' || p_query || '%'
    )
  GROUP BY p.id
  ORDER BY p.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

-- =====================================================
-- Admin Get Customer Details RPC
-- =====================================================

CREATE OR REPLACE FUNCTION admin_get_customer_details(p_customer_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_profile jsonb;
  v_jobs jsonb;
  v_payments jsonb;
  v_support jsonb;
  v_disputes jsonb;
BEGIN
  IF NOT is_admin() THEN
    RETURN jsonb_build_object('error', 'Access denied: admin only');
  END IF;

  -- Get profile
  SELECT jsonb_build_object(
    'id', p.id,
    'full_name', p.full_name,
    'email', p.email,
    'phone', p.phone,
    'role', p.role::text,
    'city', p.city,
    'state', p.state,
    'hub_id', p.hub_id,
    'avatar_url', p.avatar_url,
    'created_at', p.created_at,
    'updated_at', p.updated_at
  ) INTO v_profile
  FROM profiles p
  WHERE p.id = p_customer_id;

  IF v_profile IS NULL THEN
    RETURN jsonb_build_object('error', 'Customer not found');
  END IF;

  -- Get jobs
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', j.id,
      'title', j.title,
      'status', j.status::text,
      'created_at', j.created_at,
      'accepted_mechanic_id', j.accepted_mechanic_id,
      'completed_at', j.completed_at
    ) ORDER BY j.created_at DESC
  ), '[]'::jsonb) INTO v_jobs
  FROM jobs j
  WHERE j.customer_id = p_customer_id;

  -- Get payments
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', pay.id,
      'job_id', pay.job_id,
      'amount_cents', pay.amount_cents,
      'status', pay.status,
      'paid_at', pay.paid_at,
      'refunded_at', pay.refunded_at
    ) ORDER BY pay.created_at DESC
  ), '[]'::jsonb) INTO v_payments
  FROM payments pay
  JOIN jobs j ON j.id = pay.job_id
  WHERE j.customer_id = p_customer_id;

  -- Get support requests
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', sr.id,
      'category', sr.category,
      'message', sr.message,
      'status', sr.status,
      'created_at', sr.created_at
    ) ORDER BY sr.created_at DESC
  ), '[]'::jsonb) INTO v_support
  FROM support_requests sr
  WHERE sr.user_id = p_customer_id;

  -- Get disputes
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', d.id,
      'job_id', d.job_id,
      'category', d.category,
      'status', d.status,
      'created_at', d.created_at,
      'resolved_at', d.resolved_at
    ) ORDER BY d.created_at DESC
  ), '[]'::jsonb) INTO v_disputes
  FROM disputes d
  JOIN jobs j ON j.id = d.job_id
  WHERE j.customer_id = p_customer_id;

  RETURN jsonb_build_object(
    'profile', v_profile,
    'jobs', v_jobs,
    'payments', v_payments,
    'support_requests', v_support,
    'disputes', v_disputes
  );
END;
$$;

-- =====================================================
-- Grant permissions
-- =====================================================

GRANT EXECUTE ON FUNCTION admin_list_customers TO authenticated;
GRANT EXECUTE ON FUNCTION admin_get_customer_details TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 0128_admin_customer_rpcs.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000008_promo_credit_tracking.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: Promo Credit Tracking for Jobs
-- =====================================================
-- Adds fields to track promo credits applied to jobs
-- and ensures the discount persists throughout the job lifecycle

BEGIN;

-- Add promo tracking columns to jobs table
ALTER TABLE public.jobs 
ADD COLUMN IF NOT EXISTS applied_promo_credit_id uuid REFERENCES public.promo_credits(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS promo_discount_cents int DEFAULT 0,
ADD COLUMN IF NOT EXISTS promo_credit_type text;

COMMENT ON COLUMN public.jobs.applied_promo_credit_id IS 'Reference to the promo credit used for this job';
COMMENT ON COLUMN public.jobs.promo_discount_cents IS 'Amount of platform fee discount in cents';
COMMENT ON COLUMN public.jobs.promo_credit_type IS 'Type of promo credit applied (FEELESS, FEELESS3)';

-- Add promo tracking columns to payments table
ALTER TABLE public.payments
ADD COLUMN IF NOT EXISTS promo_credit_id uuid REFERENCES public.promo_credits(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS promo_discount_cents int DEFAULT 0,
ADD COLUMN IF NOT EXISTS original_platform_fee_cents int;

COMMENT ON COLUMN public.payments.promo_credit_id IS 'Reference to the promo credit used';
COMMENT ON COLUMN public.payments.promo_discount_cents IS 'Amount discounted from platform fee';
COMMENT ON COLUMN public.payments.original_platform_fee_cents IS 'Original platform fee before discount';

-- Create index for promo credit lookups
CREATE INDEX IF NOT EXISTS idx_jobs_promo_credit ON public.jobs(applied_promo_credit_id) WHERE applied_promo_credit_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_payments_promo_credit ON public.payments(promo_credit_id) WHERE promo_credit_id IS NOT NULL;

-- =====================================================
-- FUNCTION: apply_promo_credit_to_job
-- =====================================================
-- Applies a user's available promo credit to a job
-- Returns the discount amount and credit details
CREATE OR REPLACE FUNCTION public.apply_promo_credit_to_job(p_job_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_job_customer_id uuid;
  v_credit_id uuid;
  v_credit_type text;
  v_discount_cents int;
  v_platform_fee_cents int := 1500; -- $15 platform fee
BEGIN
  SELECT auth.uid() INTO v_user_id;
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  
  -- Get job and verify ownership
  SELECT customer_id INTO v_job_customer_id
  FROM jobs WHERE id = p_job_id;
  
  IF v_job_customer_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job not found');
  END IF;
  
  IF v_job_customer_id != v_user_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  -- Check if job already has a promo applied
  IF EXISTS (SELECT 1 FROM jobs WHERE id = p_job_id AND applied_promo_credit_id IS NOT NULL) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job already has a promo credit applied');
  END IF;
  
  -- Find the oldest available promo credit (FIFO)
  -- FEELESS = full fee waiver, FEELESS3 = $3 off
  SELECT id, credit_type::text
  INTO v_credit_id, v_credit_type
  FROM promo_credits
  WHERE user_id = v_user_id
    AND remaining_uses > 0
  ORDER BY 
    CASE WHEN credit_type = 'FEELESS' THEN 0 ELSE 1 END, -- Prefer FEELESS first
    created_at ASC
  LIMIT 1;
  
  IF v_credit_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', true, 
      'has_credit', false,
      'message', 'No promo credits available'
    );
  END IF;
  
  -- Calculate discount based on credit type
  v_discount_cents := CASE 
    WHEN v_credit_type = 'FEELESS' THEN v_platform_fee_cents -- Full fee waiver
    WHEN v_credit_type = 'FEELESS3' THEN 300 -- $3 off
    ELSE 0
  END;
  
  -- Decrement the credit
  UPDATE promo_credits
  SET remaining_uses = remaining_uses - 1,
      updated_at = now()
  WHERE id = v_credit_id;
  
  -- Apply to job
  UPDATE jobs
  SET applied_promo_credit_id = v_credit_id,
      promo_discount_cents = v_discount_cents,
      promo_credit_type = v_credit_type,
      updated_at = now()
  WHERE id = p_job_id;
  
  RETURN jsonb_build_object(
    'success', true,
    'has_credit', true,
    'credit_id', v_credit_id,
    'credit_type', v_credit_type,
    'discount_cents', v_discount_cents,
    'message', CASE 
      WHEN v_credit_type = 'FEELESS' THEN 'Platform fee waived!'
      ELSE '$3 discount applied!'
    END
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.apply_promo_credit_to_job(uuid) TO authenticated;

-- =====================================================
-- FUNCTION: get_job_promo_info
-- =====================================================
-- Returns promo credit info for a job (for display on invoices)
CREATE OR REPLACE FUNCTION public.get_job_promo_info(p_job_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_job record;
BEGIN
  SELECT auth.uid() INTO v_user_id;
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  
  SELECT j.id, j.customer_id, j.accepted_mechanic_id,
         j.applied_promo_credit_id, j.promo_discount_cents, j.promo_credit_type
  INTO v_job
  FROM jobs j
  WHERE j.id = p_job_id;
  
  IF v_job IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job not found');
  END IF;
  
  -- Only job participants can view
  IF v_job.customer_id != v_user_id AND v_job.accepted_mechanic_id != v_user_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  RETURN jsonb_build_object(
    'success', true,
    'has_promo', v_job.applied_promo_credit_id IS NOT NULL,
    'promo_credit_id', v_job.applied_promo_credit_id,
    'discount_cents', COALESCE(v_job.promo_discount_cents, 0),
    'credit_type', v_job.promo_credit_type,
    'discount_description', CASE 
      WHEN v_job.promo_credit_type = 'FEELESS' THEN 'Platform fee waived (referral credit)'
      WHEN v_job.promo_credit_type = 'FEELESS3' THEN '$3 off platform fee (referral credit)'
      ELSE NULL
    END
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_job_promo_info(uuid) TO authenticated;

-- =====================================================
-- FUNCTION: preview_promo_discount (updated)
-- =====================================================
-- Preview what discount would be applied (doesn't consume credit)
CREATE OR REPLACE FUNCTION public.preview_promo_discount(p_platform_fee_cents int DEFAULT 1500)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_credit_id uuid;
  v_credit_type text;
  v_discount_cents int;
BEGIN
  SELECT auth.uid() INTO v_user_id;
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  
  -- Find the best available promo credit
  SELECT id, credit_type::text
  INTO v_credit_id, v_credit_type
  FROM promo_credits
  WHERE user_id = v_user_id
    AND remaining_uses > 0
  ORDER BY 
    CASE WHEN credit_type = 'FEELESS' THEN 0 ELSE 1 END,
    created_at ASC
  LIMIT 1;
  
  IF v_credit_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', true,
      'has_discount', false,
      'credit_type', NULL,
      'discount_cents', 0,
      'fee_after_cents', p_platform_fee_cents,
      'reason', 'No promo credits available'
    );
  END IF;
  
  v_discount_cents := CASE 
    WHEN v_credit_type = 'FEELESS' THEN p_platform_fee_cents
    WHEN v_credit_type = 'FEELESS3' THEN LEAST(300, p_platform_fee_cents)
    ELSE 0
  END;
  
  RETURN jsonb_build_object(
    'success', true,
    'has_discount', true,
    'credit_type', v_credit_type,
    'discount_cents', v_discount_cents,
    'fee_after_cents', GREATEST(0, p_platform_fee_cents - v_discount_cents),
    'reason', CASE 
      WHEN v_credit_type = 'FEELESS' THEN 'Referral credit: Free platform fee'
      ELSE 'Referral credit: $3 off platform fee'
    END
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.preview_promo_discount(int) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260111000008_promo_credit_tracking.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000009_sync_job_progress.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: Sync Job Progress to Jobs Table
-- =====================================================
-- Creates trigger to sync job_progress milestones back to jobs table

BEGIN;

-- Add scheduled_at trigger - when mechanic departs, job is effectively scheduled
CREATE OR REPLACE FUNCTION public.sync_job_progress_to_jobs()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- When mechanic departs, set scheduled_at if not already set
  IF NEW.mechanic_departed_at IS NOT NULL AND OLD.mechanic_departed_at IS NULL THEN
    UPDATE jobs 
    SET scheduled_at = NEW.mechanic_departed_at,
        status = 'in_progress',
        updated_at = now()
    WHERE id = NEW.job_id 
      AND scheduled_at IS NULL;
  END IF;
  
  -- When work starts, update status
  IF NEW.work_started_at IS NOT NULL AND OLD.work_started_at IS NULL THEN
    UPDATE jobs 
    SET status = 'work_in_progress',
        updated_at = now()
    WHERE id = NEW.job_id;
  END IF;
  
  -- When finalized (both parties confirmed), mark completed
  IF NEW.finalized_at IS NOT NULL AND OLD.finalized_at IS NULL THEN
    UPDATE jobs 
    SET completed_at = NEW.finalized_at,
        status = 'completed',
        updated_at = now()
    WHERE id = NEW.job_id;
  END IF;
  
  RETURN NEW;
END;
$$;

-- Create trigger
DROP TRIGGER IF EXISTS trg_sync_job_progress ON public.job_progress;
CREATE TRIGGER trg_sync_job_progress
  AFTER UPDATE ON public.job_progress
  FOR EACH ROW
  EXECUTE FUNCTION public.sync_job_progress_to_jobs();

COMMIT;\n-- ===================================================================
-- END: 20260111000009_sync_job_progress.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000010_use_payment_promo_applications.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: Use payment_promo_applications table
-- =====================================================
-- Updates apply_promo_credit_to_job to also insert into payment_promo_applications

BEGIN;

-- Update the apply function to work with payment_promo_applications
CREATE OR REPLACE FUNCTION public.apply_promo_to_payment(
  p_payment_id uuid,
  p_platform_fee_cents int DEFAULT 1500
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_payment record;
  v_credit_id uuid;
  v_credit_type text;
  v_discount_cents int;
  v_fee_after_cents int;
BEGIN
  SELECT auth.uid() INTO v_user_id;
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  
  -- Get payment and verify ownership
  SELECT p.id, p.job_id, j.customer_id
  INTO v_payment
  FROM payments p
  JOIN jobs j ON j.id = p.job_id
  WHERE p.id = p_payment_id;
  
  IF v_payment IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Payment not found');
  END IF;
  
  IF v_payment.customer_id != v_user_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  -- Check if promo already applied to this payment
  IF EXISTS (SELECT 1 FROM payment_promo_applications WHERE payment_id = p_payment_id) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Promo already applied to this payment');
  END IF;
  
  -- Find the oldest available promo credit (FIFO)
  SELECT id, credit_type::text
  INTO v_credit_id, v_credit_type
  FROM promo_credits
  WHERE user_id = v_user_id
    AND remaining_uses > 0
  ORDER BY 
    CASE WHEN credit_type = 'FEELESS' THEN 0 ELSE 1 END,
    created_at ASC
  LIMIT 1;
  
  IF v_credit_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', true, 
      'has_credit', false,
      'message', 'No promo credits available'
    );
  END IF;
  
  -- Calculate discount
  v_discount_cents := CASE 
    WHEN v_credit_type = 'FEELESS' THEN p_platform_fee_cents
    WHEN v_credit_type = 'FEELESS3' THEN LEAST(300, p_platform_fee_cents)
    ELSE 0
  END;
  v_fee_after_cents := GREATEST(0, p_platform_fee_cents - v_discount_cents);
  
  -- Decrement the credit
  UPDATE promo_credits
  SET remaining_uses = remaining_uses - 1,
      updated_at = now()
  WHERE id = v_credit_id;
  
  -- Insert into payment_promo_applications
  INSERT INTO payment_promo_applications (
    payment_id, promo_credit_id, credit_type, 
    fee_before_cents, discount_cents, fee_after_cents
  )
  VALUES (
    p_payment_id, v_credit_id, v_credit_type::promo_credit_type,
    p_platform_fee_cents, v_discount_cents, v_fee_after_cents
  );
  
  -- Also update the job for easy access
  UPDATE jobs
  SET applied_promo_credit_id = v_credit_id,
      promo_discount_cents = v_discount_cents,
      promo_credit_type = v_credit_type,
      updated_at = now()
  WHERE id = v_payment.job_id;
  
  RETURN jsonb_build_object(
    'success', true,
    'has_credit', true,
    'credit_id', v_credit_id,
    'credit_type', v_credit_type,
    'discount_cents', v_discount_cents,
    'fee_after_cents', v_fee_after_cents,
    'message', CASE 
      WHEN v_credit_type = 'FEELESS' THEN 'Platform fee waived!'
      ELSE '$3 discount applied!'
    END
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.apply_promo_to_payment(uuid, int) TO authenticated;

-- Function to get promo info from payment_promo_applications
CREATE OR REPLACE FUNCTION public.get_payment_promo_info(p_payment_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_promo record;
BEGIN
  SELECT ppa.*, pc.user_id as credit_owner_id
  INTO v_promo
  FROM payment_promo_applications ppa
  LEFT JOIN promo_credits pc ON pc.id = ppa.promo_credit_id
  WHERE ppa.payment_id = p_payment_id;
  
  IF v_promo IS NULL THEN
    RETURN jsonb_build_object(
      'has_promo', false,
      'discount_cents', 0
    );
  END IF;
  
  RETURN jsonb_build_object(
    'has_promo', true,
    'credit_type', v_promo.credit_type,
    'fee_before_cents', v_promo.fee_before_cents,
    'discount_cents', v_promo.discount_cents,
    'fee_after_cents', v_promo.fee_after_cents,
    'discount_description', CASE 
      WHEN v_promo.credit_type = 'FEELESS' THEN 'Platform fee waived (referral credit)'
      ELSE '$3 off platform fee (referral credit)'
    END
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_payment_promo_info(uuid) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260111000010_use_payment_promo_applications.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000011_fix_review_prompts_completed.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: Fix review_prompts completed_at update
-- =====================================================
-- Updates submit_review to mark review_prompts as completed

BEGIN;

CREATE OR REPLACE FUNCTION public.submit_review(
  p_job_id uuid,
  p_reviewer_id uuid,
  p_reviewee_id uuid,
  p_rating int,
  p_comment text DEFAULT NULL,
  p_professionalism_rating int DEFAULT NULL,
  p_communication_rating int DEFAULT NULL,
  p_would_recommend boolean DEFAULT NULL,
  p_performance_rating int DEFAULT NULL,
  p_timing_rating int DEFAULT NULL,
  p_cost_rating int DEFAULT NULL,
  p_punctuality_rating int DEFAULT NULL,
  p_payment_rating int DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_review_id uuid;
  v_blind_deadline timestamptz;
  v_other_review_exists boolean;
  v_should_publish boolean := false;
  v_job_finalized_at timestamptz;
BEGIN
  -- Get job finalized timestamp
  SELECT jp.finalized_at INTO v_job_finalized_at
  FROM public.job_progress jp
  WHERE jp.job_id = p_job_id;
  
  IF v_job_finalized_at IS NULL THEN
    RAISE EXCEPTION 'Job not finalized yet';
  END IF;
  
  -- Set blind deadline to 7 days after job finalization
  v_blind_deadline := v_job_finalized_at + interval '7 days';
  
  -- Check if other party has already reviewed
  SELECT EXISTS(
    SELECT 1 FROM public.reviews
    WHERE job_id = p_job_id
      AND reviewer_id = p_reviewee_id
      AND reviewee_id = p_reviewer_id
  ) INTO v_other_review_exists;
  
  -- If both reviews exist, publish both immediately
  v_should_publish := v_other_review_exists;
  
  -- Insert or update review
  INSERT INTO public.reviews (
    job_id,
    reviewer_id,
    reviewee_id,
    overall_rating,
    comment,
    professionalism_rating,
    communication_rating,
    would_recommend,
    performance_rating,
    timing_rating,
    cost_rating,
    punctuality_rating,
    payment_rating,
    visibility,
    blind_deadline,
    created_at,
    updated_at
  ) VALUES (
    p_job_id,
    p_reviewer_id,
    p_reviewee_id,
    p_rating,
    p_comment,
    p_professionalism_rating,
    p_communication_rating,
    p_would_recommend,
    p_performance_rating,
    p_timing_rating,
    p_cost_rating,
    p_punctuality_rating,
    p_payment_rating,
    CASE WHEN v_should_publish THEN 'visible'::review_visibility ELSE 'hidden'::review_visibility END,
    v_blind_deadline,
    now(),
    now()
  )
  ON CONFLICT (job_id, reviewer_id) 
  DO UPDATE SET
    overall_rating = EXCLUDED.overall_rating,
    comment = EXCLUDED.comment,
    professionalism_rating = EXCLUDED.professionalism_rating,
    communication_rating = EXCLUDED.communication_rating,
    would_recommend = EXCLUDED.would_recommend,
    performance_rating = EXCLUDED.performance_rating,
    timing_rating = EXCLUDED.timing_rating,
    cost_rating = EXCLUDED.cost_rating,
    punctuality_rating = EXCLUDED.punctuality_rating,
    payment_rating = EXCLUDED.payment_rating,
    updated_at = now()
  RETURNING id INTO v_review_id;
  
  -- Mark review_prompt as completed
  UPDATE public.review_prompts
  SET completed_at = now()
  WHERE job_id = p_job_id
    AND user_id = p_reviewer_id
    AND completed_at IS NULL;
  
  -- If both reviews exist, publish both
  IF v_should_publish THEN
    UPDATE public.reviews
    SET 
      visibility = 'visible',
      made_visible_at = now(),
      visibility_reason = 'both_submitted'
    WHERE job_id = p_job_id
      AND visibility = 'hidden';
  END IF;
  
  RETURN jsonb_build_object(
    'review_id', v_review_id,
    'published', v_should_publish,
    'blind_deadline', v_blind_deadline
  );
END;
$$;

-- Also fix any existing review_prompts that have reviews but weren't marked completed
UPDATE public.review_prompts rp
SET completed_at = r.created_at
FROM public.reviews r
WHERE rp.job_id = r.job_id
  AND rp.user_id = r.reviewer_id
  AND rp.completed_at IS NULL;

COMMIT;
\n-- ===================================================================
-- END: 20260111000011_fix_review_prompts_completed.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000012_retroactive_promo_apply.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: Retroactively apply promo credits to existing jobs
-- =====================================================
-- Creates a function to apply promo credit to an existing job/payment

BEGIN;

-- Function to retroactively apply promo to an existing job
CREATE OR REPLACE FUNCTION public.retroactive_apply_promo(
  p_job_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_job record;
  v_payment record;
  v_credit_id uuid;
  v_credit_type text;
  v_discount_cents int;
  v_fee_after_cents int;
  v_platform_fee_cents int := 1500;
BEGIN
  SELECT auth.uid() INTO v_user_id;
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  
  -- Get job and verify ownership
  SELECT id, customer_id, applied_promo_credit_id
  INTO v_job
  FROM jobs
  WHERE id = p_job_id;
  
  IF v_job IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job not found');
  END IF;
  
  IF v_job.customer_id != v_user_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  -- Check if promo already applied
  IF v_job.applied_promo_credit_id IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Promo already applied to this job');
  END IF;
  
  -- Get payment for this job
  SELECT id INTO v_payment FROM payments WHERE job_id = p_job_id LIMIT 1;
  
  IF v_payment IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'No payment found for this job');
  END IF;
  
  -- Check if promo already applied to payment
  IF EXISTS (SELECT 1 FROM payment_promo_applications WHERE payment_id = v_payment.id) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Promo already applied to this payment');
  END IF;
  
  -- Find the oldest available promo credit (FIFO)
  SELECT id, credit_type::text
  INTO v_credit_id, v_credit_type
  FROM promo_credits
  WHERE user_id = v_user_id
    AND remaining_uses > 0
  ORDER BY 
    CASE WHEN credit_type = 'FEELESS' THEN 0 ELSE 1 END,
    created_at ASC
  LIMIT 1;
  
  IF v_credit_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', true, 
      'has_credit', false,
      'message', 'No promo credits available'
    );
  END IF;
  
  -- Calculate discount
  v_discount_cents := CASE 
    WHEN v_credit_type = 'FEELESS' THEN v_platform_fee_cents
    WHEN v_credit_type = 'FEELESS3' THEN LEAST(300, v_platform_fee_cents)
    ELSE 0
  END;
  v_fee_after_cents := GREATEST(0, v_platform_fee_cents - v_discount_cents);
  
  -- Decrement the credit
  UPDATE promo_credits
  SET remaining_uses = remaining_uses - 1,
      updated_at = now()
  WHERE id = v_credit_id;
  
  -- Insert into payment_promo_applications
  INSERT INTO payment_promo_applications (
    payment_id, promo_credit_id, credit_type, 
    fee_before_cents, discount_cents, fee_after_cents
  )
  VALUES (
    v_payment.id, v_credit_id, v_credit_type::promo_credit_type,
    v_platform_fee_cents, v_discount_cents, v_fee_after_cents
  );
  
  -- Update the job
  UPDATE jobs
  SET applied_promo_credit_id = v_credit_id,
      promo_discount_cents = v_discount_cents,
      promo_credit_type = v_credit_type,
      updated_at = now()
  WHERE id = p_job_id;
  
  RETURN jsonb_build_object(
    'success', true,
    'has_credit', true,
    'credit_type', v_credit_type,
    'discount_cents', v_discount_cents,
    'fee_after_cents', v_fee_after_cents
  );
END;
$$;

COMMIT;
\n-- ===================================================================
-- END: 20260111000012_retroactive_promo_apply.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000013_fix_retroactive_promo.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: Fix retroactive promo to update payment and contract
-- =====================================================

BEGIN;

CREATE OR REPLACE FUNCTION public.retroactive_apply_promo(
  p_job_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_job record;
  v_payment record;
  v_contract record;
  v_credit_id uuid;
  v_credit_type text;
  v_discount_cents int;
  v_fee_after_cents int;
  v_platform_fee_cents int := 1500;
BEGIN
  SELECT auth.uid() INTO v_user_id;
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  
  -- Get job and verify ownership
  SELECT id, customer_id, applied_promo_credit_id
  INTO v_job
  FROM jobs
  WHERE id = p_job_id;
  
  IF v_job IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job not found');
  END IF;
  
  IF v_job.customer_id != v_user_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  -- Check if promo already applied
  IF v_job.applied_promo_credit_id IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Promo already applied to this job');
  END IF;
  
  -- Get payment for this job
  SELECT id, amount_cents, platform_fee_cents INTO v_payment 
  FROM payments WHERE job_id = p_job_id LIMIT 1;
  
  IF v_payment IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'No payment found for this job');
  END IF;
  
  -- Get contract for this job
  SELECT id, platform_fee_cents, total_customer_cents INTO v_contract
  FROM job_contracts WHERE job_id = p_job_id LIMIT 1;
  
  -- Use actual platform fee from contract/payment if available
  v_platform_fee_cents := COALESCE(v_contract.platform_fee_cents, v_payment.platform_fee_cents, 1500);
  
  -- Check if promo already applied to payment
  IF EXISTS (SELECT 1 FROM payment_promo_applications WHERE payment_id = v_payment.id) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Promo already applied to this payment');
  END IF;
  
  -- Find the oldest available promo credit (FIFO)
  SELECT id, credit_type::text
  INTO v_credit_id, v_credit_type
  FROM promo_credits
  WHERE user_id = v_user_id
    AND remaining_uses > 0
  ORDER BY 
    CASE WHEN credit_type = 'FEELESS' THEN 0 ELSE 1 END,
    created_at ASC
  LIMIT 1;
  
  IF v_credit_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', true, 
      'has_credit', false,
      'message', 'No promo credits available'
    );
  END IF;
  
  -- Calculate discount
  v_discount_cents := CASE 
    WHEN v_credit_type = 'FEELESS' THEN v_platform_fee_cents
    WHEN v_credit_type = 'FEELESS3' THEN LEAST(300, v_platform_fee_cents)
    ELSE 0
  END;
  v_fee_after_cents := GREATEST(0, v_platform_fee_cents - v_discount_cents);
  
  -- Decrement the credit
  UPDATE promo_credits
  SET remaining_uses = remaining_uses - 1,
      updated_at = now()
  WHERE id = v_credit_id;
  
  -- Insert into payment_promo_applications
  INSERT INTO payment_promo_applications (
    payment_id, promo_credit_id, credit_type, 
    fee_before_cents, discount_cents, fee_after_cents
  )
  VALUES (
    v_payment.id, v_credit_id, v_credit_type::promo_credit_type,
    v_platform_fee_cents, v_discount_cents, v_fee_after_cents
  );
  
  -- Update the payment with discounted amounts
  UPDATE payments
  SET amount_cents = amount_cents - v_discount_cents,
      platform_fee_cents = v_fee_after_cents,
      updated_at = now()
  WHERE id = v_payment.id;
  
  -- Update the contract with discounted amounts
  IF v_contract IS NOT NULL THEN
    UPDATE job_contracts
    SET platform_fee_cents = v_fee_after_cents,
        total_customer_cents = total_customer_cents - v_discount_cents,
        updated_at = now()
    WHERE id = v_contract.id;
  END IF;
  
  -- Update the job
  UPDATE jobs
  SET applied_promo_credit_id = v_credit_id,
      promo_discount_cents = v_discount_cents,
      promo_credit_type = v_credit_type,
      updated_at = now()
  WHERE id = p_job_id;
  
  RETURN jsonb_build_object(
    'success', true,
    'has_credit', true,
    'credit_type', v_credit_type,
    'discount_cents', v_discount_cents,
    'fee_after_cents', v_fee_after_cents
  );
END;
$$;

COMMIT;
\n-- ===================================================================
-- END: 20260111000013_fix_retroactive_promo.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000014_add_symptom_to_create_job.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: Add symptom_key and symptom_id to create_job function
-- =====================================================

BEGIN;

CREATE OR REPLACE FUNCTION public.create_job_with_payment_check(
  p_title text,
  p_description text DEFAULT NULL,
  p_location_address text DEFAULT NULL,
  p_location_lat double precision DEFAULT NULL,
  p_location_lng double precision DEFAULT NULL,
  p_vehicle_id uuid DEFAULT NULL,
  p_preferred_time text DEFAULT NULL,
  p_symptom_key text DEFAULT NULL,
  p_symptom_id uuid DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_customer_id uuid;
  v_payment_status payment_method_status;
  v_job_id uuid;
  v_symptom_id uuid;
BEGIN
  v_customer_id := auth.uid();
  
  IF v_customer_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'code', 'NOT_AUTHENTICATED');
  END IF;

  SELECT payment_method_status INTO v_payment_status
  FROM profiles WHERE id = v_customer_id;

  IF v_payment_status IS NULL OR v_payment_status != 'active' THEN
    RETURN jsonb_build_object(
      'success', false,
      'code', 'PAYMENT_METHOD_REQUIRED',
      'message', 'A valid payment method is required to request service'
    );
  END IF;

  -- Look up symptom_id from symptom_key if not provided
  v_symptom_id := p_symptom_id;
  IF v_symptom_id IS NULL AND p_symptom_key IS NOT NULL THEN
    SELECT id INTO v_symptom_id FROM symptoms WHERE key = p_symptom_key LIMIT 1;
  END IF;

  INSERT INTO jobs (customer_id, title, description, location_address, location_lat, location_lng, vehicle_id, preferred_time, symptom_key, symptom_id, status)
  VALUES (v_customer_id, p_title, p_description, p_location_address, p_location_lat, p_location_lng, p_vehicle_id, p_preferred_time, p_symptom_key, v_symptom_id, 'searching')
  RETURNING id INTO v_job_id;

  RETURN jsonb_build_object('success', true, 'job_id', v_job_id);
END;
$$;

-- Grant execute to authenticated users (with new signature)
GRANT EXECUTE ON FUNCTION public.create_job_with_payment_check(text, text, text, double precision, double precision, uuid, text, text, uuid) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260111000014_add_symptom_to_create_job.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000015_mechanic_verification_phase1.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: MECHANIC VERIFICATION PHASE 1
-- =====================================================
-- Purpose: Admin system, mechanic verification status, document uploads, vetting questionnaire
-- Enforces server-side gating for leads/quotes
-- =====================================================

BEGIN;

-- =====================================================
-- A) ADMIN USERS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS public.admin_users (
  user_id uuid PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at timestamptz DEFAULT now() NOT NULL,
  created_by uuid REFERENCES public.profiles(id),
  is_super boolean DEFAULT false NOT NULL
);

COMMENT ON TABLE public.admin_users IS 'Users with admin access to the platform';

ALTER TABLE public.admin_users ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- A.1) is_admin helper function (SECURITY DEFINER)
-- =====================================================
CREATE OR REPLACE FUNCTION public.is_admin(uid uuid DEFAULT auth.uid())
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.admin_users WHERE user_id = uid
  );
END;
$$;

CREATE OR REPLACE FUNCTION public.is_super_admin(uid uuid DEFAULT auth.uid())
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.admin_users WHERE user_id = uid AND is_super = true
  );
END;
$$;

-- Admin RLS: admins can view, only super admins or service_role can modify
CREATE POLICY "admin_users_select_admin" ON public.admin_users
  FOR SELECT TO authenticated
  USING (public.is_admin(auth.uid()));

CREATE POLICY "admin_users_insert_super" ON public.admin_users
  FOR INSERT TO authenticated
  WITH CHECK (public.is_super_admin(auth.uid()));

CREATE POLICY "admin_users_delete_super" ON public.admin_users
  FOR DELETE TO authenticated
  USING (public.is_super_admin(auth.uid()));

-- Service role can manage all
CREATE POLICY "admin_users_service_role" ON public.admin_users
  FOR ALL TO service_role
  USING (true)
  WITH CHECK (true);

GRANT SELECT ON public.admin_users TO authenticated;
GRANT ALL ON public.admin_users TO service_role;

-- =====================================================
-- B) VERIFICATION STATUS ON MECHANIC_PROFILES
-- =====================================================
ALTER TABLE public.mechanic_profiles
  ADD COLUMN IF NOT EXISTS verification_status text NOT NULL DEFAULT 'pending_verification',
  ADD COLUMN IF NOT EXISTS verification_updated_at timestamptz DEFAULT now(),
  ADD COLUMN IF NOT EXISTS verification_reason text;

-- Add check constraint for verification status values
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'mechanic_profiles_verification_status_check'
  ) THEN
    ALTER TABLE public.mechanic_profiles
      ADD CONSTRAINT mechanic_profiles_verification_status_check
      CHECK (verification_status IN ('pending_verification', 'active', 'paused', 'removed'));
  END IF;
END $$;

-- Index for filtering by verification status
CREATE INDEX IF NOT EXISTS idx_mechanic_profiles_verification_status
  ON public.mechanic_profiles(verification_status);

-- =====================================================
-- C) MECHANIC VERIFICATION DOCUMENTS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS public.mechanic_verification_documents (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  doc_type text NOT NULL,
  bucket text DEFAULT 'mechanic-verification' NOT NULL,
  path text NOT NULL,
  status text NOT NULL DEFAULT 'pending',
  uploaded_at timestamptz DEFAULT now() NOT NULL,
  reviewed_at timestamptz,
  reviewed_by uuid REFERENCES public.profiles(id),
  review_notes text,
  
  CONSTRAINT mechanic_verification_documents_doc_type_check
    CHECK (doc_type IN ('id_front', 'id_back', 'insurance')),
  CONSTRAINT mechanic_verification_documents_status_check
    CHECK (status IN ('pending', 'approved', 'rejected')),
  UNIQUE(mechanic_id, doc_type)
);

COMMENT ON TABLE public.mechanic_verification_documents IS 'Documents uploaded by mechanics for verification';

ALTER TABLE public.mechanic_verification_documents ENABLE ROW LEVEL SECURITY;

-- Mechanics can insert/select their own docs
CREATE POLICY "verification_docs_select_own" ON public.mechanic_verification_documents
  FOR SELECT TO authenticated
  USING (mechanic_id = auth.uid() OR public.is_admin(auth.uid()));

CREATE POLICY "verification_docs_insert_own" ON public.mechanic_verification_documents
  FOR INSERT TO authenticated
  WITH CHECK (mechanic_id = auth.uid());

-- Only admins can update (for review)
CREATE POLICY "verification_docs_update_admin" ON public.mechanic_verification_documents
  FOR UPDATE TO authenticated
  USING (public.is_admin(auth.uid()))
  WITH CHECK (public.is_admin(auth.uid()));

-- Service role full access
CREATE POLICY "verification_docs_service_role" ON public.mechanic_verification_documents
  FOR ALL TO service_role
  USING (true)
  WITH CHECK (true);

GRANT SELECT, INSERT ON public.mechanic_verification_documents TO authenticated;
GRANT UPDATE (status, reviewed_at, reviewed_by, review_notes) ON public.mechanic_verification_documents TO authenticated;
GRANT ALL ON public.mechanic_verification_documents TO service_role;

-- =====================================================
-- D) MECHANIC VETTING RESPONSES TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS public.mechanic_vetting_responses (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  prompt_key text NOT NULL,
  prompt_text text NOT NULL,
  response_text text NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  
  UNIQUE(mechanic_id, prompt_key)
);

COMMENT ON TABLE public.mechanic_vetting_responses IS 'Mechanic responses to vetting questionnaire';

ALTER TABLE public.mechanic_vetting_responses ENABLE ROW LEVEL SECURITY;

-- Mechanics can insert/update/select their own responses
CREATE POLICY "vetting_responses_select_own" ON public.mechanic_vetting_responses
  FOR SELECT TO authenticated
  USING (mechanic_id = auth.uid() OR public.is_admin(auth.uid()));

CREATE POLICY "vetting_responses_insert_own" ON public.mechanic_vetting_responses
  FOR INSERT TO authenticated
  WITH CHECK (mechanic_id = auth.uid());

CREATE POLICY "vetting_responses_update_own" ON public.mechanic_vetting_responses
  FOR UPDATE TO authenticated
  USING (mechanic_id = auth.uid())
  WITH CHECK (mechanic_id = auth.uid());

-- Service role full access
CREATE POLICY "vetting_responses_service_role" ON public.mechanic_vetting_responses
  FOR ALL TO service_role
  USING (true)
  WITH CHECK (true);

GRANT SELECT, INSERT, UPDATE ON public.mechanic_vetting_responses TO authenticated;
GRANT ALL ON public.mechanic_vetting_responses TO service_role;

-- =====================================================
-- D.2) MECHANIC VETTING REVIEWS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS public.mechanic_vetting_reviews (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  mechanic_id uuid UNIQUE NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  status text NOT NULL DEFAULT 'pending',
  notes text,
  reviewed_by uuid REFERENCES public.profiles(id),
  reviewed_at timestamptz,
  created_at timestamptz DEFAULT now() NOT NULL,
  
  CONSTRAINT mechanic_vetting_reviews_status_check
    CHECK (status IN ('pending', 'pass', 'fail', 'needs_more_info'))
);

COMMENT ON TABLE public.mechanic_vetting_reviews IS 'Admin review of mechanic vetting questionnaire';

ALTER TABLE public.mechanic_vetting_reviews ENABLE ROW LEVEL SECURITY;

-- Mechanics can view their own review status
CREATE POLICY "vetting_reviews_select_own" ON public.mechanic_vetting_reviews
  FOR SELECT TO authenticated
  USING (mechanic_id = auth.uid() OR public.is_admin(auth.uid()));

-- Only admins can insert/update
CREATE POLICY "vetting_reviews_insert_admin" ON public.mechanic_vetting_reviews
  FOR INSERT TO authenticated
  WITH CHECK (public.is_admin(auth.uid()));

CREATE POLICY "vetting_reviews_update_admin" ON public.mechanic_vetting_reviews
  FOR UPDATE TO authenticated
  USING (public.is_admin(auth.uid()))
  WITH CHECK (public.is_admin(auth.uid()));

-- Service role full access
CREATE POLICY "vetting_reviews_service_role" ON public.mechanic_vetting_reviews
  FOR ALL TO service_role
  USING (true)
  WITH CHECK (true);

GRANT SELECT ON public.mechanic_vetting_reviews TO authenticated;
GRANT INSERT, UPDATE ON public.mechanic_vetting_reviews TO authenticated;
GRANT ALL ON public.mechanic_vetting_reviews TO service_role;

-- =====================================================
-- E) SERVER-SIDE GATING: get_mechanic_verification_status RPC
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_mechanic_verification_status(p_mechanic_id uuid DEFAULT auth.uid())
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_status text;
  v_reason text;
  v_docs_count int;
  v_docs_approved int;
  v_vetting_count int;
  v_vetting_review_status text;
BEGIN
  -- Get verification status
  SELECT verification_status, verification_reason
  INTO v_status, v_reason
  FROM public.mechanic_profiles
  WHERE id = p_mechanic_id;
  
  IF v_status IS NULL THEN
    RETURN json_build_object(
      'status', 'not_found',
      'is_active', false,
      'can_view_leads', false,
      'can_submit_quotes', false
    );
  END IF;
  
  -- Count documents
  SELECT COUNT(*), COUNT(*) FILTER (WHERE status = 'approved')
  INTO v_docs_count, v_docs_approved
  FROM public.mechanic_verification_documents
  WHERE mechanic_id = p_mechanic_id;
  
  -- Count vetting responses
  SELECT COUNT(*)
  INTO v_vetting_count
  FROM public.mechanic_vetting_responses
  WHERE mechanic_id = p_mechanic_id;
  
  -- Get vetting review status
  SELECT status INTO v_vetting_review_status
  FROM public.mechanic_vetting_reviews
  WHERE mechanic_id = p_mechanic_id;
  
  RETURN json_build_object(
    'status', v_status,
    'reason', v_reason,
    'is_active', v_status = 'active',
    'can_view_leads', v_status = 'active',
    'can_submit_quotes', v_status = 'active',
    'documents_uploaded', v_docs_count,
    'documents_approved', v_docs_approved,
    'documents_required', 3,
    'vetting_responses', v_vetting_count,
    'vetting_required', 5,
    'vetting_review_status', COALESCE(v_vetting_review_status, 'pending')
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_verification_status(uuid) TO authenticated;

-- =====================================================
-- E.2) UPDATE get_mechanic_leads to enforce verification
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text,
  p_mechanic_lat double precision,
  p_mechanic_lng double precision,
  p_radius_miles double precision,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  urgency text,
  preferred_time text,
  vehicle_year int,
  vehicle_make text,
  vehicle_model text,
  vehicle_vin text,
  location_lat double precision,
  location_lng double precision,
  location_address text,
  customer_id uuid,
  customer_name text,
  customer_avatar text,
  created_at timestamptz,
  distance_miles numeric,
  quote_count bigint,
  has_quoted boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_verification_status text;
BEGIN
  -- VERIFICATION GATE: Check mechanic is active
  SELECT mp.verification_status INTO v_verification_status
  FROM public.mechanic_profiles mp
  WHERE mp.id = p_mechanic_id;
  
  IF v_verification_status IS NULL OR v_verification_status != 'active' THEN
    -- Return empty result set for non-active mechanics
    RETURN;
  END IF;

  RETURN QUERY
  WITH mechanic_quotes AS (
    SELECT DISTINCT q.job_id as qjob_id
    FROM public.quotes q
    WHERE q.mechanic_id = p_mechanic_id
      AND q.status NOT IN ('cancelled', 'expired')
  ),
  quote_counts AS (
    SELECT q.job_id as cjob_id, COUNT(*) as cnt
    FROM public.quotes q
    WHERE q.status NOT IN ('cancelled', 'expired')
    GROUP BY q.job_id
  )
  SELECT
    j.id as job_id,
    j.title,
    j.description,
    j.status::text,
    j.urgency::text,
    j.preferred_time,
    j.vehicle_year,
    j.vehicle_make,
    j.vehicle_model,
    j.vehicle_vin,
    j.location_lat,
    j.location_lng,
    j.location_address,
    j.customer_id,
    p.full_name as customer_name,
    p.avatar_url as customer_avatar,
    j.created_at,
    CASE 
      WHEN p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL 
           AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      THEN (
        3959 * acos(
          cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
        )
      )::numeric
      ELSE NULL
    END as distance_miles,
    COALESCE(qc.cnt, 0) as quote_count,
    mq.qjob_id IS NOT NULL as has_quoted
  FROM public.jobs j
  JOIN public.profiles p ON p.id = j.customer_id
  LEFT JOIN mechanic_quotes mq ON mq.qjob_id = j.id
  LEFT JOIN quote_counts qc ON qc.cjob_id = j.id
  WHERE j.status = 'searching'
    AND j.deleted_at IS NULL
    AND (
      p_filter = 'all'
      OR (p_filter = 'nearby' AND p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL AND (
        3959 * acos(
          cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
        )
      ) <= p_radius_miles)
      OR (p_filter = 'quoted' AND mq.qjob_id IS NOT NULL)
      OR (p_filter = 'not_quoted' AND mq.qjob_id IS NULL)
    )
  ORDER BY
    CASE WHEN p_sort_by = 'newest' THEN j.created_at END DESC,
    CASE WHEN p_sort_by = 'oldest' THEN j.created_at END ASC,
    CASE WHEN p_sort_by = 'distance' AND p_mechanic_lat IS NOT NULL THEN
      3959 * acos(
        cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
        sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
      )
    END ASC NULLS LAST
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text) TO authenticated;

-- =====================================================
-- E.3) RLS POLICY: quotes INSERT requires active verification
-- =====================================================
-- First, check if existing insert policy exists and drop it
DROP POLICY IF EXISTS "quotes_mechanic_insert" ON public.quotes;
DROP POLICY IF EXISTS "quotes_insert_own" ON public.quotes;

-- Create new insert policy with verification check
CREATE POLICY "quotes_insert_verified_mechanic" ON public.quotes
  FOR INSERT TO authenticated
  WITH CHECK (
    mechanic_id = auth.uid()
    AND EXISTS (
      SELECT 1 FROM public.mechanic_profiles mp
      WHERE mp.id = auth.uid()
      AND mp.verification_status = 'active'
    )
  );

-- =====================================================
-- E.4) RLS POLICY: quote_requests INSERT requires active verification
-- =====================================================
DROP POLICY IF EXISTS "quote_requests_mechanic_insert" ON public.quote_requests;
DROP POLICY IF EXISTS "quote_requests_insert_own" ON public.quote_requests;

CREATE POLICY "quote_requests_insert_verified_mechanic" ON public.quote_requests
  FOR INSERT TO authenticated
  WITH CHECK (
    mechanic_id = auth.uid()
    AND EXISTS (
      SELECT 1 FROM public.mechanic_profiles mp
      WHERE mp.id = auth.uid()
      AND mp.verification_status = 'active'
    )
  );

-- =====================================================
-- F) ADMIN RPCs
-- =====================================================

-- Get pending verifications for admin
CREATE OR REPLACE FUNCTION public.admin_get_pending_verifications()
RETURNS TABLE (
  mechanic_id uuid,
  full_name text,
  email text,
  avatar_url text,
  verification_status text,
  verification_reason text,
  created_at timestamptz,
  docs_pending int,
  docs_approved int,
  docs_rejected int,
  vetting_responses int,
  vetting_review_status text
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Access denied: admin only';
  END IF;
  
  RETURN QUERY
  SELECT
    p.id as mechanic_id,
    p.full_name,
    p.email,
    p.avatar_url,
    mp.verification_status,
    mp.verification_reason,
    p.created_at,
    COUNT(d.id) FILTER (WHERE d.status = 'pending')::int as docs_pending,
    COUNT(d.id) FILTER (WHERE d.status = 'approved')::int as docs_approved,
    COUNT(d.id) FILTER (WHERE d.status = 'rejected')::int as docs_rejected,
    COUNT(vr.id)::int as vetting_responses,
    COALESCE(vrv.status, 'pending') as vetting_review_status
  FROM public.profiles p
  JOIN public.mechanic_profiles mp ON mp.id = p.id
  LEFT JOIN public.mechanic_verification_documents d ON d.mechanic_id = p.id
  LEFT JOIN public.mechanic_vetting_responses vr ON vr.mechanic_id = p.id
  LEFT JOIN public.mechanic_vetting_reviews vrv ON vrv.mechanic_id = p.id
  WHERE p.role = 'mechanic'
    AND (
      mp.verification_status = 'pending_verification'
      OR EXISTS (SELECT 1 FROM public.mechanic_verification_documents WHERE mechanic_id = p.id AND status = 'pending')
      OR (vrv.status IS NULL OR vrv.status = 'pending')
    )
  GROUP BY p.id, p.full_name, p.email, p.avatar_url, mp.verification_status, mp.verification_reason, p.created_at, vrv.status
  ORDER BY p.created_at ASC;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_pending_verifications() TO authenticated;

-- Admin: Get mechanic verification details
CREATE OR REPLACE FUNCTION public.admin_get_mechanic_verification_details(p_mechanic_id uuid)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result json;
BEGIN
  IF NOT public.is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Access denied: admin only';
  END IF;
  
  SELECT json_build_object(
    'profile', (
      SELECT json_build_object(
        'id', p.id,
        'full_name', p.full_name,
        'email', p.email,
        'phone', p.phone,
        'avatar_url', p.avatar_url,
        'created_at', p.created_at
      )
      FROM public.profiles p WHERE p.id = p_mechanic_id
    ),
    'mechanic_profile', (
      SELECT json_build_object(
        'verification_status', mp.verification_status,
        'verification_reason', mp.verification_reason,
        'verification_updated_at', mp.verification_updated_at,
        'bio', mp.bio,
        'years_experience', mp.years_experience
      )
      FROM public.mechanic_profiles mp WHERE mp.id = p_mechanic_id
    ),
    'documents', (
      SELECT COALESCE(json_agg(json_build_object(
        'id', d.id,
        'doc_type', d.doc_type,
        'path', d.path,
        'bucket', d.bucket,
        'status', d.status,
        'uploaded_at', d.uploaded_at,
        'reviewed_at', d.reviewed_at,
        'review_notes', d.review_notes
      )), '[]'::json)
      FROM public.mechanic_verification_documents d WHERE d.mechanic_id = p_mechanic_id
    ),
    'vetting_responses', (
      SELECT COALESCE(json_agg(json_build_object(
        'id', vr.id,
        'prompt_key', vr.prompt_key,
        'prompt_text', vr.prompt_text,
        'response_text', vr.response_text,
        'created_at', vr.created_at
      )), '[]'::json)
      FROM public.mechanic_vetting_responses vr WHERE vr.mechanic_id = p_mechanic_id
    ),
    'vetting_review', (
      SELECT json_build_object(
        'id', vrv.id,
        'status', vrv.status,
        'notes', vrv.notes,
        'reviewed_at', vrv.reviewed_at
      )
      FROM public.mechanic_vetting_reviews vrv WHERE vrv.mechanic_id = p_mechanic_id
    )
  ) INTO v_result;
  
  RETURN v_result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_mechanic_verification_details(uuid) TO authenticated;

-- Admin: Update document status
CREATE OR REPLACE FUNCTION public.admin_review_document(
  p_doc_id uuid,
  p_status text,
  p_notes text DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Access denied: admin only';
  END IF;
  
  IF p_status NOT IN ('approved', 'rejected') THEN
    RAISE EXCEPTION 'Invalid status: must be approved or rejected';
  END IF;
  
  UPDATE public.mechanic_verification_documents
  SET 
    status = p_status,
    reviewed_at = now(),
    reviewed_by = auth.uid(),
    review_notes = p_notes
  WHERE id = p_doc_id;
  
  RETURN json_build_object('success', true);
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_review_document(uuid, text, text) TO authenticated;

-- Admin: Update vetting review
CREATE OR REPLACE FUNCTION public.admin_review_vetting(
  p_mechanic_id uuid,
  p_status text,
  p_notes text DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Access denied: admin only';
  END IF;
  
  IF p_status NOT IN ('pass', 'fail', 'needs_more_info') THEN
    RAISE EXCEPTION 'Invalid status: must be pass, fail, or needs_more_info';
  END IF;
  
  INSERT INTO public.mechanic_vetting_reviews (mechanic_id, status, notes, reviewed_by, reviewed_at)
  VALUES (p_mechanic_id, p_status, p_notes, auth.uid(), now())
  ON CONFLICT (mechanic_id) DO UPDATE SET
    status = p_status,
    notes = p_notes,
    reviewed_by = auth.uid(),
    reviewed_at = now();
  
  RETURN json_build_object('success', true);
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_review_vetting(uuid, text, text) TO authenticated;

-- Admin: Set mechanic verification status
CREATE OR REPLACE FUNCTION public.admin_set_verification_status(
  p_mechanic_id uuid,
  p_status text,
  p_reason text DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Access denied: admin only';
  END IF;
  
  IF p_status NOT IN ('pending_verification', 'active', 'paused', 'removed') THEN
    RAISE EXCEPTION 'Invalid status';
  END IF;
  
  UPDATE public.mechanic_profiles
  SET 
    verification_status = p_status,
    verification_reason = p_reason,
    verification_updated_at = now()
  WHERE id = p_mechanic_id;
  
  RETURN json_build_object('success', true, 'status', p_status);
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_set_verification_status(uuid, text, text) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260111000015_mechanic_verification_phase1.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000016_fix_admin_verifications_rpc.sql
-- ===================================================================\n
-- Add p_status_filter parameter to admin_get_pending_verifications
BEGIN;

CREATE OR REPLACE FUNCTION public.admin_get_pending_verifications(
  p_status_filter text DEFAULT NULL
)
RETURNS TABLE (
  id uuid,
  full_name text,
  email text,
  avatar_url text,
  verification_status text,
  docs_count bigint,
  vetting_count bigint,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Access denied: admin only';
  END IF;
  
  RETURN QUERY
  SELECT
    p.id,
    p.full_name,
    p.email,
    p.avatar_url,
    mp.verification_status,
    COUNT(DISTINCT d.id) as docs_count,
    COUNT(DISTINCT vr.id) as vetting_count,
    p.created_at
  FROM public.profiles p
  JOIN public.mechanic_profiles mp ON mp.id = p.id
  LEFT JOIN public.mechanic_verification_documents d ON d.mechanic_id = p.id
  LEFT JOIN public.mechanic_vetting_responses vr ON vr.mechanic_id = p.id
  WHERE p.role = 'mechanic'
    AND (p_status_filter IS NULL OR mp.verification_status = p_status_filter)
  GROUP BY p.id, p.full_name, p.email, p.avatar_url, mp.verification_status, p.created_at
  ORDER BY p.created_at DESC;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_pending_verifications(text) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260111000016_fix_admin_verifications_rpc.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000017_fix_mechanic_leads_overload.sql
-- ===================================================================\n
-- Fix get_mechanic_leads function overloading conflict
BEGIN;

-- Drop both versions and recreate with consistent types
DROP FUNCTION IF EXISTS public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text);
DROP FUNCTION IF EXISTS public.get_mechanic_leads(uuid, text, numeric, numeric, numeric, integer, integer, text);

CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text,
  p_mechanic_lat double precision,
  p_mechanic_lng double precision,
  p_radius_miles double precision,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  urgency text,
  preferred_time text,
  vehicle_year int,
  vehicle_make text,
  vehicle_model text,
  vehicle_vin text,
  location_lat double precision,
  location_lng double precision,
  location_address text,
  customer_id uuid,
  customer_name text,
  customer_avatar text,
  created_at timestamptz,
  distance_miles numeric,
  quote_count bigint,
  has_quoted boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_verification_status text;
BEGIN
  SELECT mp.verification_status INTO v_verification_status
  FROM public.mechanic_profiles mp
  WHERE mp.id = p_mechanic_id;
  
  IF v_verification_status IS NULL OR v_verification_status != 'active' THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT
    j.id as job_id,
    j.title,
    j.description,
    j.status,
    j.urgency,
    j.preferred_time,
    j.vehicle_year,
    j.vehicle_make,
    j.vehicle_model,
    j.vehicle_vin,
    j.location_lat,
    j.location_lng,
    j.location_address,
    j.customer_id,
    p.full_name as customer_name,
    p.avatar_url as customer_avatar,
    j.created_at,
    CASE 
      WHEN p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL 
           AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      THEN ROUND((
        3959 * acos(
          cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
        )
      )::numeric, 1)
      ELSE NULL
    END as distance_miles,
    (SELECT COUNT(*) FROM public.quotes q WHERE q.job_id = j.id) as quote_count,
    EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id) as has_quoted
  FROM public.jobs j
  JOIN public.profiles p ON p.id = j.customer_id
  WHERE j.status = 'pending'
    AND (p_filter = 'all' OR p_filter IS NULL OR
         (p_filter = 'nearby' AND p_mechanic_lat IS NOT NULL) OR
         (p_filter = 'quoted' AND EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id)))
    AND (p_radius_miles IS NULL OR p_mechanic_lat IS NULL OR p_mechanic_lng IS NULL OR
         j.location_lat IS NULL OR j.location_lng IS NULL OR
         (3959 * acos(
           cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
           cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
           sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
         )) <= p_radius_miles)
  ORDER BY
    CASE WHEN p_sort_by = 'newest' THEN j.created_at END DESC,
    CASE WHEN p_sort_by = 'closest' AND p_mechanic_lat IS NOT NULL THEN
      3959 * acos(
        cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
        sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
      )
    END ASC NULLS LAST,
    j.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260111000017_fix_mechanic_leads_overload.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000018_create_verification_bucket.sql
-- ===================================================================\n
-- Create mechanic-verification storage bucket
BEGIN;

INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'mechanic-verification',
  'mechanic-verification',
  false,
  10485760, -- 10MB
  ARRAY['image/jpeg', 'image/png', 'image/webp', 'application/pdf']
)
ON CONFLICT (id) DO NOTHING;

-- RLS policies for the bucket
CREATE POLICY "Mechanics can upload own docs"
ON storage.objects FOR INSERT TO authenticated
WITH CHECK (
  bucket_id = 'mechanic-verification'
  AND (storage.foldername(name))[1] = auth.uid()::text
);

CREATE POLICY "Mechanics can view own docs"
ON storage.objects FOR SELECT TO authenticated
USING (
  bucket_id = 'mechanic-verification'
  AND (
    (storage.foldername(name))[1] = auth.uid()::text
    OR public.is_admin(auth.uid())
  )
);

CREATE POLICY "Admins can view all verification docs"
ON storage.objects FOR SELECT TO authenticated
USING (
  bucket_id = 'mechanic-verification'
  AND public.is_admin(auth.uid())
);

COMMIT;
\n-- ===================================================================
-- END: 20260111000018_create_verification_bucket.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000019_mechanic_verification_selfie_patch.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: MECHANIC VERIFICATION SELFIE PATCH (Phase 1.1)
-- =====================================================
-- Adds 'selfie_with_id' to mechanic_verification_documents doc_type
-- Updates completeness logic to require 4 documents
-- =====================================================

BEGIN;

-- =====================================================
-- A) UPDATE doc_type CHECK CONSTRAINT
-- =====================================================
-- Drop existing constraint and recreate with selfie_with_id
ALTER TABLE public.mechanic_verification_documents
  DROP CONSTRAINT IF EXISTS mechanic_verification_documents_doc_type_check;

ALTER TABLE public.mechanic_verification_documents
  ADD CONSTRAINT mechanic_verification_documents_doc_type_check
  CHECK (doc_type IN ('id_front', 'id_back', 'insurance', 'selfie_with_id'));

-- =====================================================
-- B) UPDATE admin_get_pending_verifications to show docs completeness
-- =====================================================
-- Must drop first because return type is changing
DROP FUNCTION IF EXISTS public.admin_get_pending_verifications(text);

CREATE OR REPLACE FUNCTION public.admin_get_pending_verifications(
  p_status_filter text DEFAULT NULL
)
RETURNS TABLE (
  id uuid,
  full_name text,
  email text,
  avatar_url text,
  verification_status text,
  docs_count bigint,
  docs_complete boolean,
  vetting_count bigint,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Access denied: admin only';
  END IF;
  
  RETURN QUERY
  SELECT
    p.id,
    p.full_name,
    p.email,
    p.avatar_url,
    mp.verification_status,
    COUNT(DISTINCT d.id) as docs_count,
    -- docs_complete: true if all 4 required doc types exist
    (
      EXISTS(SELECT 1 FROM public.mechanic_verification_documents WHERE mechanic_id = p.id AND doc_type = 'id_front')
      AND EXISTS(SELECT 1 FROM public.mechanic_verification_documents WHERE mechanic_id = p.id AND doc_type = 'id_back')
      AND EXISTS(SELECT 1 FROM public.mechanic_verification_documents WHERE mechanic_id = p.id AND doc_type = 'insurance')
      AND EXISTS(SELECT 1 FROM public.mechanic_verification_documents WHERE mechanic_id = p.id AND doc_type = 'selfie_with_id')
    ) as docs_complete,
    COUNT(DISTINCT vr.id) as vetting_count,
    p.created_at
  FROM public.profiles p
  JOIN public.mechanic_profiles mp ON mp.id = p.id
  LEFT JOIN public.mechanic_verification_documents d ON d.mechanic_id = p.id
  LEFT JOIN public.mechanic_vetting_responses vr ON vr.mechanic_id = p.id
  WHERE p.role = 'mechanic'
    AND (p_status_filter IS NULL OR mp.verification_status = p_status_filter)
  GROUP BY p.id, p.full_name, p.email, p.avatar_url, mp.verification_status, p.created_at
  ORDER BY p.created_at DESC;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_pending_verifications(text) TO authenticated;

-- =====================================================
-- C) UPDATE get_mechanic_verification_status to return docs_complete
-- =====================================================
-- Drop first to avoid parameter default issues
DROP FUNCTION IF EXISTS public.get_mechanic_verification_status(uuid);

CREATE FUNCTION public.get_mechanic_verification_status(p_mechanic_id uuid)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result json;
BEGIN
  SELECT json_build_object(
    'status', mp.verification_status,
    'reason', mp.verification_reason,
    'updated_at', mp.verification_updated_at,
    'is_active', (mp.verification_status = 'active'),
    'documents_uploaded', COALESCE(docs.total, 0),
    'documents_approved', COALESCE(docs.approved, 0),
    'documents_required', 4,
    'docs_complete', (
      EXISTS(SELECT 1 FROM public.mechanic_verification_documents WHERE mechanic_id = p_mechanic_id AND doc_type = 'id_front')
      AND EXISTS(SELECT 1 FROM public.mechanic_verification_documents WHERE mechanic_id = p_mechanic_id AND doc_type = 'id_back')
      AND EXISTS(SELECT 1 FROM public.mechanic_verification_documents WHERE mechanic_id = p_mechanic_id AND doc_type = 'insurance')
      AND EXISTS(SELECT 1 FROM public.mechanic_verification_documents WHERE mechanic_id = p_mechanic_id AND doc_type = 'selfie_with_id')
    ),
    'vetting_responses', COALESCE(vetting.cnt, 0),
    'vetting_required', 5,
    'vetting_review_status', COALESCE(vr.status, 'pending')
  ) INTO v_result
  FROM public.mechanic_profiles mp
  LEFT JOIN (
    SELECT mechanic_id, COUNT(*) as total, COUNT(*) FILTER (WHERE status = 'approved') as approved
    FROM public.mechanic_verification_documents
    WHERE mechanic_id = p_mechanic_id
    GROUP BY mechanic_id
  ) docs ON docs.mechanic_id = mp.id
  LEFT JOIN (
    SELECT mechanic_id, COUNT(*) as cnt
    FROM public.mechanic_vetting_responses
    WHERE mechanic_id = p_mechanic_id
    GROUP BY mechanic_id
  ) vetting ON vetting.mechanic_id = mp.id
  LEFT JOIN public.mechanic_vetting_reviews vr ON vr.mechanic_id = mp.id
  WHERE mp.id = p_mechanic_id;

  RETURN COALESCE(v_result, json_build_object(
    'status', 'pending_verification',
    'is_active', false,
    'documents_uploaded', 0,
    'documents_approved', 0,
    'documents_required', 4,
    'docs_complete', false,
    'vetting_responses', 0,
    'vetting_required', 5,
    'vetting_review_status', 'pending'
  ));
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_verification_status(uuid) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260111000019_mechanic_verification_selfie_patch.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000020_fix_verification_storage_policies.sql
-- ===================================================================\n
-- Fix storage policies for mechanic-verification bucket
BEGIN;

-- Ensure bucket exists
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'mechanic-verification',
  'mechanic-verification',
  false,
  10485760,
  ARRAY['image/jpeg', 'image/png', 'image/webp', 'application/pdf']
)
ON CONFLICT (id) DO NOTHING;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Mechanics can upload own docs" ON storage.objects;
DROP POLICY IF EXISTS "Mechanics can view own docs" ON storage.objects;
DROP POLICY IF EXISTS "Admins can view all verification docs" ON storage.objects;
DROP POLICY IF EXISTS "mechanic_verification_insert" ON storage.objects;
DROP POLICY IF EXISTS "mechanic_verification_select" ON storage.objects;
DROP POLICY IF EXISTS "mechanic_verification_update" ON storage.objects;

-- Create upload policy - mechanics can upload to their own folder
CREATE POLICY "mechanic_verification_insert"
ON storage.objects FOR INSERT TO authenticated
WITH CHECK (
  bucket_id = 'mechanic-verification'
  AND (storage.foldername(name))[1] = auth.uid()::text
);

-- Create update policy - mechanics can update their own files
CREATE POLICY "mechanic_verification_update"
ON storage.objects FOR UPDATE TO authenticated
USING (
  bucket_id = 'mechanic-verification'
  AND (storage.foldername(name))[1] = auth.uid()::text
);

-- Create select policy - mechanics see own, admins see all
CREATE POLICY "mechanic_verification_select"
ON storage.objects FOR SELECT TO authenticated
USING (
  bucket_id = 'mechanic-verification'
  AND (
    (storage.foldername(name))[1] = auth.uid()::text
    OR public.is_admin(auth.uid())
  )
);

COMMIT;
\n-- ===================================================================
-- END: 20260111000020_fix_verification_storage_policies.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000021_fix_mechanic_leads_urgency.sql
-- ===================================================================\n
-- Fix get_mechanic_leads function - remove non-existent urgency column
BEGIN;

DROP FUNCTION IF EXISTS public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text);

CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text,
  p_mechanic_lat double precision,
  p_mechanic_lng double precision,
  p_radius_miles double precision,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  preferred_time text,
  vehicle_year int,
  vehicle_make text,
  vehicle_model text,
  vehicle_vin text,
  location_lat double precision,
  location_lng double precision,
  location_address text,
  customer_id uuid,
  customer_name text,
  customer_avatar text,
  created_at timestamptz,
  distance_miles numeric,
  quote_count bigint,
  has_quoted boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_verification_status text;
BEGIN
  SELECT mp.verification_status INTO v_verification_status
  FROM public.mechanic_profiles mp
  WHERE mp.id = p_mechanic_id;
  
  IF v_verification_status IS NULL OR v_verification_status != 'active' THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT
    j.id as job_id,
    j.title,
    j.description,
    j.status,
    j.preferred_time,
    v.year as vehicle_year,
    v.make as vehicle_make,
    v.model as vehicle_model,
    v.vin as vehicle_vin,
    j.location_lat,
    j.location_lng,
    j.location_address,
    j.customer_id,
    p.full_name as customer_name,
    p.avatar_url as customer_avatar,
    j.created_at,
    CASE
      WHEN p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL
           AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      THEN ROUND((
        3959 * acos(
          cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
        )
      )::numeric, 1)
      ELSE NULL
    END as distance_miles,
    (SELECT COUNT(*) FROM public.quotes q WHERE q.job_id = j.id) as quote_count,
    EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id) as has_quoted
  FROM public.jobs j
  JOIN public.profiles p ON p.id = j.customer_id
  LEFT JOIN public.vehicles v ON v.id = j.vehicle_id
  WHERE j.status = 'pending'
    AND (p_filter = 'all' OR p_filter IS NULL OR
         (p_filter = 'nearby' AND p_mechanic_lat IS NOT NULL) OR
         (p_filter = 'quoted' AND EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id)))
    AND (p_radius_miles IS NULL OR p_mechanic_lat IS NULL OR p_mechanic_lng IS NULL OR
         j.location_lat IS NULL OR j.location_lng IS NULL OR
         (3959 * acos(
           cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
           cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
           sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
         )) <= p_radius_miles)
  ORDER BY
    CASE WHEN p_sort_by = 'newest' THEN j.created_at END DESC,
    CASE WHEN p_sort_by = 'closest' AND p_mechanic_lat IS NOT NULL THEN
      3959 * acos(
        cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
        sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
      )
    END ASC NULLS LAST,
    j.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260111000021_fix_mechanic_leads_urgency.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000022_fix_mechanic_leads_vehicles.sql
-- ===================================================================\n
-- Fix get_mechanic_leads function - join with vehicles table
BEGIN;

DROP FUNCTION IF EXISTS public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text);

CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text,
  p_mechanic_lat double precision,
  p_mechanic_lng double precision,
  p_radius_miles double precision,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  preferred_time text,
  vehicle_year int,
  vehicle_make text,
  vehicle_model text,
  vehicle_vin text,
  location_lat double precision,
  location_lng double precision,
  location_address text,
  customer_id uuid,
  customer_name text,
  customer_avatar text,
  created_at timestamptz,
  distance_miles numeric,
  quote_count bigint,
  has_quoted boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_verification_status text;
BEGIN
  SELECT mp.verification_status INTO v_verification_status
  FROM public.mechanic_profiles mp
  WHERE mp.id = p_mechanic_id;
  
  IF v_verification_status IS NULL OR v_verification_status != 'active' THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT
    j.id as job_id,
    j.title,
    j.description,
    j.status,
    j.preferred_time,
    v.year as vehicle_year,
    v.make as vehicle_make,
    v.model as vehicle_model,
    v.vin as vehicle_vin,
    j.location_lat,
    j.location_lng,
    j.location_address,
    j.customer_id,
    p.full_name as customer_name,
    p.avatar_url as customer_avatar,
    j.created_at,
    CASE 
      WHEN p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL 
           AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      THEN ROUND((
        3959 * acos(
          cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
        )
      )::numeric, 1)
      ELSE NULL
    END as distance_miles,
    (SELECT COUNT(*) FROM public.quotes q WHERE q.job_id = j.id) as quote_count,
    EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id) as has_quoted
  FROM public.jobs j
  JOIN public.profiles p ON p.id = j.customer_id
  LEFT JOIN public.vehicles v ON v.id = j.vehicle_id
  WHERE j.status = 'searching'
    AND (p_filter = 'all' OR p_filter IS NULL OR
         (p_filter = 'nearby' AND p_mechanic_lat IS NOT NULL) OR
         (p_filter = 'quoted' AND EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id)))
    AND (p_radius_miles IS NULL OR p_mechanic_lat IS NULL OR p_mechanic_lng IS NULL OR
         j.location_lat IS NULL OR j.location_lng IS NULL OR
         (3959 * acos(
           cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
           cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
           sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
         )) <= p_radius_miles)
  ORDER BY
    CASE WHEN p_sort_by = 'newest' THEN j.created_at END DESC,
    CASE WHEN p_sort_by = 'closest' AND p_mechanic_lat IS NOT NULL THEN
      3959 * acos(
        cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
        sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
      )
    END ASC NULLS LAST,
    j.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260111000022_fix_mechanic_leads_vehicles.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260111000023_fix_mechanic_leads_status.sql
-- ===================================================================\n
-- Fix get_mechanic_leads function - use correct job status enum value 'searching'
BEGIN;

DROP FUNCTION IF EXISTS public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text);

CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text,
  p_mechanic_lat double precision,
  p_mechanic_lng double precision,
  p_radius_miles double precision,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  preferred_time text,
  vehicle_year int,
  vehicle_make text,
  vehicle_model text,
  vehicle_vin text,
  location_lat double precision,
  location_lng double precision,
  location_address text,
  customer_id uuid,
  customer_name text,
  customer_avatar text,
  created_at timestamptz,
  distance_miles numeric,
  quote_count bigint,
  has_quoted boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_verification_status text;
BEGIN
  SELECT mp.verification_status INTO v_verification_status
  FROM public.mechanic_profiles mp
  WHERE mp.id = p_mechanic_id;
  
  IF v_verification_status IS NULL OR v_verification_status != 'active' THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT
    j.id as job_id,
    j.title,
    j.description,
    j.status::text,
    j.preferred_time,
    v.year as vehicle_year,
    v.make as vehicle_make,
    v.model as vehicle_model,
    v.vin as vehicle_vin,
    j.location_lat,
    j.location_lng,
    j.location_address,
    j.customer_id,
    p.full_name as customer_name,
    p.avatar_url as customer_avatar,
    j.created_at,
    CASE 
      WHEN p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL 
           AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      THEN ROUND((
        3959 * acos(
          cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
        )
      )::numeric, 1)
      ELSE NULL
    END as distance_miles,
    (SELECT COUNT(*) FROM public.quotes q WHERE q.job_id = j.id) as quote_count,
    EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id) as has_quoted
  FROM public.jobs j
  JOIN public.profiles p ON p.id = j.customer_id
  LEFT JOIN public.vehicles v ON v.id = j.vehicle_id
  WHERE j.status = 'searching'::job_status
    AND (p_filter = 'all' OR p_filter IS NULL OR
         (p_filter = 'nearby' AND p_mechanic_lat IS NOT NULL) OR
         (p_filter = 'quoted' AND EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id)))
    AND (p_radius_miles IS NULL OR p_mechanic_lat IS NULL OR p_mechanic_lng IS NULL OR
         j.location_lat IS NULL OR j.location_lng IS NULL OR
         (3959 * acos(
           cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
           cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
           sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
         )) <= p_radius_miles)
  ORDER BY
    CASE WHEN p_sort_by = 'newest' THEN j.created_at END DESC,
    CASE WHEN p_sort_by = 'closest' AND p_mechanic_lat IS NOT NULL THEN
      3959 * acos(
        cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
        sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
      )
    END ASC NULLS LAST,
    j.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260111000023_fix_mechanic_leads_status.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260112000001_mechanic_verification_phase2.sql
-- ===================================================================\n
-- =====================================================
-- PHASE 2: Probation Tier + Restrictions + Strike System
-- =====================================================
-- Implements:
-- A) Mechanic Tier system (probation/standard/trusted)
-- B) Platform policy config table
-- C) Quote submission enforcement RPC
-- D) Leads visibility enforcement
-- E) Strike system with auto-pause/remove
-- F) Acceptance/decline logging
-- =====================================================

BEGIN;

-- =====================================================
-- A) MECHANIC TIER COLUMNS
-- =====================================================

-- Add tier and related columns to mechanic_profiles
ALTER TABLE public.mechanic_profiles
  ADD COLUMN IF NOT EXISTS tier text NOT NULL DEFAULT 'probation',
  ADD COLUMN IF NOT EXISTS probation_started_at timestamptz,
  ADD COLUMN IF NOT EXISTS probation_completed_at timestamptz,
  ADD COLUMN IF NOT EXISTS max_quote_cents_override integer,
  ADD COLUMN IF NOT EXISTS blocked_symptom_keys text[],
  ADD COLUMN IF NOT EXISTS max_lead_radius_miles_override numeric;

-- Add tier constraint
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'mechanic_profiles_tier_check'
  ) THEN
    ALTER TABLE public.mechanic_profiles
      ADD CONSTRAINT mechanic_profiles_tier_check
      CHECK (tier IN ('probation', 'standard', 'trusted'));
  END IF;
END $$;

-- Index for tier queries
CREATE INDEX IF NOT EXISTS idx_mechanic_profiles_tier ON public.mechanic_profiles(tier);

-- =====================================================
-- B) PLATFORM POLICY CONFIG
-- =====================================================

CREATE TABLE IF NOT EXISTS public.mechanic_policy_config (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  key text NOT NULL UNIQUE,
  value jsonb NOT NULL,
  description text,
  effective_from timestamptz DEFAULT now(),
  updated_by uuid REFERENCES public.profiles(id),
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

COMMENT ON TABLE public.mechanic_policy_config IS 'Platform-wide mechanic policy configuration';

-- Insert default policy values
INSERT INTO public.mechanic_policy_config (key, value, description) VALUES
  ('probation.max_quote_cents', '25000', 'Maximum quote amount in cents for probation mechanics'),
  ('probation.blocked_symptom_keys', '["engine_internal", "transmission_rebuild", "electrical_complex"]', 'Symptom keys blocked for probation mechanics'),
  ('probation.max_radius_miles', '15', 'Maximum lead radius in miles for probation mechanics'),
  ('strikes.auto_pause_threshold', '2', 'Number of strikes before auto-pause'),
  ('strikes.auto_remove_threshold', '3', 'Number of strikes before auto-remove')
ON CONFLICT (key) DO NOTHING;

-- Helper function to get effective mechanic policy
CREATE OR REPLACE FUNCTION public.get_effective_mechanic_policy(p_hub_id uuid DEFAULT NULL)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_policy jsonb := '{}'::jsonb;
  v_hub_settings jsonb;
  v_row record;
BEGIN
  -- Start with platform-wide defaults
  FOR v_row IN SELECT key, value FROM public.mechanic_policy_config
  LOOP
    v_policy := jsonb_set(v_policy, ARRAY[v_row.key], v_row.value);
  END LOOP;

  -- Override with hub-specific settings if provided
  IF p_hub_id IS NOT NULL THEN
    SELECT settings INTO v_hub_settings
    FROM public.service_hubs
    WHERE id = p_hub_id;

    IF v_hub_settings IS NOT NULL AND v_hub_settings ? 'mechanic_policy' THEN
      v_policy := v_policy || (v_hub_settings->'mechanic_policy');
    END IF;
  END IF;

  RETURN v_policy;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_effective_mechanic_policy(uuid) TO authenticated;

-- =====================================================
-- C) MECHANIC STRIKES TABLE
-- =====================================================

CREATE TABLE IF NOT EXISTS public.mechanic_strikes (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  job_id uuid REFERENCES public.jobs(id) ON DELETE SET NULL,
  reason text NOT NULL,
  notes text,
  severity integer NOT NULL DEFAULT 1,
  expires_at timestamptz,
  created_by uuid NOT NULL REFERENCES public.profiles(id),
  created_at timestamptz DEFAULT now() NOT NULL
);

-- Add reason constraint
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'mechanic_strikes_reason_check'
  ) THEN
    ALTER TABLE public.mechanic_strikes
      ADD CONSTRAINT mechanic_strikes_reason_check
      CHECK (reason IN (
        'poor_quality_work',
        'no_show',
        'customer_complaint',
        'policy_violation',
        'unprofessional_conduct',
        'safety_concern',
        'fraud_suspected',
        'other'
      ));
  END IF;
END $$;

COMMENT ON TABLE public.mechanic_strikes IS 'Strike records for mechanics with auto-enforcement';

CREATE INDEX IF NOT EXISTS idx_mechanic_strikes_mechanic_id ON public.mechanic_strikes(mechanic_id);
CREATE INDEX IF NOT EXISTS idx_mechanic_strikes_created_at ON public.mechanic_strikes(created_at DESC);

-- =====================================================
-- D) LEAD DECISIONS TABLE
-- =====================================================

CREATE TABLE IF NOT EXISTS public.lead_decisions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  decision text NOT NULL,
  decline_reason text,
  created_at timestamptz DEFAULT now() NOT NULL,
  
  CONSTRAINT lead_decisions_decision_check CHECK (decision IN ('viewed', 'quoted', 'declined'))
);

COMMENT ON TABLE public.lead_decisions IS 'Tracks mechanic decisions on leads for acceptance rate metrics';

CREATE INDEX IF NOT EXISTS idx_lead_decisions_mechanic_id ON public.lead_decisions(mechanic_id);
CREATE INDEX IF NOT EXISTS idx_lead_decisions_job_id ON public.lead_decisions(job_id);
CREATE INDEX IF NOT EXISTS idx_lead_decisions_created_at ON public.lead_decisions(created_at DESC);
CREATE UNIQUE INDEX IF NOT EXISTS idx_lead_decisions_mechanic_job_decision 
  ON public.lead_decisions(mechanic_id, job_id, decision);

-- =====================================================
-- E) STRIKE AUTO-ENFORCEMENT TRIGGER
-- =====================================================

CREATE OR REPLACE FUNCTION public.enforce_strike_thresholds()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_strike_count integer;
  v_policy jsonb;
  v_pause_threshold integer;
  v_remove_threshold integer;
  v_current_status text;
BEGIN
  -- Get policy
  v_policy := get_effective_mechanic_policy(NULL);
  v_pause_threshold := COALESCE((v_policy->>'strikes.auto_pause_threshold')::integer, 2);
  v_remove_threshold := COALESCE((v_policy->>'strikes.auto_remove_threshold')::integer, 3);

  -- Count active strikes (not expired)
  SELECT COUNT(*) INTO v_strike_count
  FROM public.mechanic_strikes
  WHERE mechanic_id = NEW.mechanic_id
    AND (expires_at IS NULL OR expires_at > now());

  -- Get current status
  SELECT verification_status INTO v_current_status
  FROM public.mechanic_profiles
  WHERE id = NEW.mechanic_id;

  -- Skip if already removed
  IF v_current_status = 'removed' THEN
    RETURN NEW;
  END IF;

  -- Apply thresholds
  IF v_strike_count >= v_remove_threshold THEN
    UPDATE public.mechanic_profiles
    SET verification_status = 'removed',
        verification_reason = 'Auto-removed: ' || v_strike_count || ' strikes (threshold: ' || v_remove_threshold || ')',
        verification_updated_at = now()
    WHERE id = NEW.mechanic_id;
  ELSIF v_strike_count >= v_pause_threshold AND v_current_status != 'paused' THEN
    UPDATE public.mechanic_profiles
    SET verification_status = 'paused',
        verification_reason = 'Auto-paused: ' || v_strike_count || ' strikes (threshold: ' || v_pause_threshold || ')',
        verification_updated_at = now()
    WHERE id = NEW.mechanic_id;
  END IF;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_enforce_strike_thresholds ON public.mechanic_strikes;
CREATE TRIGGER trg_enforce_strike_thresholds
  AFTER INSERT ON public.mechanic_strikes
  FOR EACH ROW
  EXECUTE FUNCTION public.enforce_strike_thresholds();

-- =====================================================
-- F) TIER INITIALIZATION TRIGGER
-- =====================================================
-- Sets probation_started_at when mechanic first becomes active

CREATE OR REPLACE FUNCTION public.handle_mechanic_activation()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Only trigger when transitioning TO active status
  IF NEW.verification_status = 'active' AND 
     (OLD.verification_status IS NULL OR OLD.verification_status != 'active') THEN
    
    -- If never been active before (probation_started_at is null), initialize probation
    IF NEW.probation_started_at IS NULL THEN
      NEW.tier := 'probation';
      NEW.probation_started_at := now();
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_handle_mechanic_activation ON public.mechanic_profiles;
CREATE TRIGGER trg_handle_mechanic_activation
  BEFORE UPDATE ON public.mechanic_profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_mechanic_activation();

-- =====================================================
-- G) QUOTE SUBMISSION RPC (with enforcement)
-- =====================================================

CREATE OR REPLACE FUNCTION public.create_quote_for_job(
  p_job_id uuid,
  p_price_cents integer,
  p_notes text DEFAULT NULL,
  p_estimated_hours numeric DEFAULT NULL,
  p_use_quote_requests boolean DEFAULT false
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic_id uuid := auth.uid();
  v_mechanic record;
  v_job record;
  v_policy jsonb;
  v_max_quote_cents integer;
  v_blocked_keys text[];
  v_existing_quote_id uuid;
  v_new_quote_id uuid;
  v_distance_miles numeric;
BEGIN
  -- 1) Validate mechanic exists and is active
  SELECT mp.*, p.role
  INTO v_mechanic
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON p.id = mp.id
  WHERE mp.id = v_mechanic_id;

  IF v_mechanic IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Mechanic profile not found');
  END IF;

  IF v_mechanic.role != 'mechanic' THEN
    RETURN jsonb_build_object('success', false, 'error', 'User is not a mechanic');
  END IF;

  IF v_mechanic.verification_status != 'active' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Mechanic is not verified/active. Status: ' || COALESCE(v_mechanic.verification_status, 'unknown'));
  END IF;

  -- 2) Fetch job details
  SELECT j.*, p.id as customer_profile_id
  INTO v_job
  FROM public.jobs j
  JOIN public.profiles p ON p.id = j.customer_id
  WHERE j.id = p_job_id;

  IF v_job IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job not found');
  END IF;

  IF v_job.status NOT IN ('searching', 'quoted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job is not accepting quotes. Status: ' || v_job.status);
  END IF;

  -- 3) Check for existing quote
  SELECT id INTO v_existing_quote_id
  FROM public.quotes
  WHERE job_id = p_job_id AND mechanic_id = v_mechanic_id;

  IF v_existing_quote_id IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'You have already quoted on this job', 'quote_id', v_existing_quote_id);
  END IF;

  -- 4) Get effective policy
  v_policy := get_effective_mechanic_policy(v_job.hub_id);

  -- 5) Probation enforcement
  IF v_mechanic.tier = 'probation' THEN
    -- Max quote check
    v_max_quote_cents := COALESCE(
      v_mechanic.max_quote_cents_override,
      (v_policy->>'probation.max_quote_cents')::integer,
      25000
    );

    IF p_price_cents > v_max_quote_cents THEN
      RETURN jsonb_build_object(
        'success', false, 
        'error', 'Probation limit: Maximum quote is $' || (v_max_quote_cents / 100.0)::text,
        'max_quote_cents', v_max_quote_cents
      );
    END IF;

    -- Blocked symptom keys check
    v_blocked_keys := COALESCE(
      v_mechanic.blocked_symptom_keys,
      ARRAY(SELECT jsonb_array_elements_text(COALESCE(v_policy->'probation.blocked_symptom_keys', '[]'::jsonb)))
    );

    IF v_job.symptom_key IS NOT NULL AND v_job.symptom_key = ANY(v_blocked_keys) THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Probation limit: This job category is restricted for probation mechanics',
        'blocked_symptom', v_job.symptom_key
      );
    END IF;
  END IF;

  -- 6) Insert quote
  IF p_use_quote_requests THEN
    INSERT INTO public.quote_requests (
      job_id,
      mechanic_id,
      customer_id,
      price_cents,
      notes,
      status
    ) VALUES (
      p_job_id,
      v_mechanic_id,
      v_job.customer_id,
      p_price_cents,
      p_notes,
      'pending'
    )
    RETURNING id INTO v_new_quote_id;
  ELSE
    INSERT INTO public.quotes (
      job_id,
      mechanic_id,
      price_cents,
      estimated_hours,
      notes,
      status
    ) VALUES (
      p_job_id,
      v_mechanic_id,
      p_price_cents,
      p_estimated_hours,
      p_notes,
      'pending'
    )
    RETURNING id INTO v_new_quote_id;
  END IF;

  -- 7) Log decision
  INSERT INTO public.lead_decisions (mechanic_id, job_id, decision)
  VALUES (v_mechanic_id, p_job_id, 'quoted')
  ON CONFLICT (mechanic_id, job_id, decision) DO NOTHING;

  -- 8) Update job status to quoted if first quote
  UPDATE public.jobs
  SET status = 'quoted', updated_at = now()
  WHERE id = p_job_id AND status = 'searching';

  RETURN jsonb_build_object(
    'success', true,
    'quote_id', v_new_quote_id,
    'message', 'Quote submitted successfully'
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.create_quote_for_job(uuid, integer, text, numeric, boolean) TO authenticated;

-- =====================================================
-- H) DECLINE LEAD RPC
-- =====================================================

CREATE OR REPLACE FUNCTION public.decline_lead(
  p_job_id uuid,
  p_reason text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic_id uuid := auth.uid();
BEGIN
  -- Validate mechanic
  IF NOT EXISTS (
    SELECT 1 FROM public.mechanic_profiles WHERE id = v_mechanic_id
  ) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Mechanic profile not found');
  END IF;

  -- Validate job exists
  IF NOT EXISTS (
    SELECT 1 FROM public.jobs WHERE id = p_job_id
  ) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job not found');
  END IF;

  -- Log decision
  INSERT INTO public.lead_decisions (mechanic_id, job_id, decision, decline_reason)
  VALUES (v_mechanic_id, p_job_id, 'declined', p_reason)
  ON CONFLICT (mechanic_id, job_id, decision) DO UPDATE
    SET decline_reason = EXCLUDED.decline_reason;

  RETURN jsonb_build_object('success', true, 'message', 'Lead declined');
END;
$$;

GRANT EXECUTE ON FUNCTION public.decline_lead(uuid, text) TO authenticated;

-- =====================================================
-- I) LOG LEAD VIEW RPC
-- =====================================================

CREATE OR REPLACE FUNCTION public.log_lead_view(p_job_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic_id uuid := auth.uid();
BEGIN
  INSERT INTO public.lead_decisions (mechanic_id, job_id, decision)
  VALUES (v_mechanic_id, p_job_id, 'viewed')
  ON CONFLICT (mechanic_id, job_id, decision) DO NOTHING;
END;
$$;

GRANT EXECUTE ON FUNCTION public.log_lead_view(uuid) TO authenticated;

-- =====================================================
-- J) ADMIN STRIKE RPCs
-- =====================================================

-- Add strike
CREATE OR REPLACE FUNCTION public.admin_add_mechanic_strike(
  p_mechanic_id uuid,
  p_reason text,
  p_notes text DEFAULT NULL,
  p_job_id uuid DEFAULT NULL,
  p_severity integer DEFAULT 1
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id uuid := auth.uid();
  v_strike_id uuid;
  v_strike_count integer;
BEGIN
  -- Verify admin
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('success', false, 'error', 'Admin access required');
  END IF;

  -- Verify mechanic exists
  IF NOT EXISTS (
    SELECT 1 FROM public.mechanic_profiles WHERE id = p_mechanic_id
  ) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Mechanic not found');
  END IF;

  -- Insert strike
  INSERT INTO public.mechanic_strikes (mechanic_id, job_id, reason, notes, severity, created_by)
  VALUES (p_mechanic_id, p_job_id, p_reason, p_notes, p_severity, v_admin_id)
  RETURNING id INTO v_strike_id;

  -- Get updated count
  SELECT COUNT(*) INTO v_strike_count
  FROM public.mechanic_strikes
  WHERE mechanic_id = p_mechanic_id
    AND (expires_at IS NULL OR expires_at > now());

  RETURN jsonb_build_object(
    'success', true,
    'strike_id', v_strike_id,
    'total_strikes', v_strike_count,
    'message', 'Strike added successfully'
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_add_mechanic_strike(uuid, text, text, uuid, integer) TO authenticated;

-- List strikes
CREATE OR REPLACE FUNCTION public.admin_list_mechanic_strikes(p_mechanic_id uuid)
RETURNS TABLE (
  id uuid,
  mechanic_id uuid,
  job_id uuid,
  reason text,
  notes text,
  severity integer,
  expires_at timestamptz,
  created_by uuid,
  created_by_name text,
  created_at timestamptz,
  is_active boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Admin access required';
  END IF;

  RETURN QUERY
  SELECT 
    ms.id,
    ms.mechanic_id,
    ms.job_id,
    ms.reason,
    ms.notes,
    ms.severity,
    ms.expires_at,
    ms.created_by,
    p.full_name as created_by_name,
    ms.created_at,
    (ms.expires_at IS NULL OR ms.expires_at > now()) as is_active
  FROM public.mechanic_strikes ms
  LEFT JOIN public.profiles p ON p.id = ms.created_by
  WHERE ms.mechanic_id = p_mechanic_id
  ORDER BY ms.created_at DESC;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_list_mechanic_strikes(uuid) TO authenticated;

-- Remove strike (super admin only)
CREATE OR REPLACE FUNCTION public.admin_remove_strike(p_strike_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_super_admin() THEN
    RETURN jsonb_build_object('success', false, 'error', 'Super admin access required');
  END IF;

  DELETE FROM public.mechanic_strikes WHERE id = p_strike_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Strike not found');
  END IF;

  RETURN jsonb_build_object('success', true, 'message', 'Strike removed');
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_remove_strike(uuid) TO authenticated;

-- =====================================================
-- K) ADMIN SET MECHANIC TIER RPC
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_set_mechanic_tier(
  p_mechanic_id uuid,
  p_tier text,
  p_reason text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_old_tier text;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('success', false, 'error', 'Admin access required');
  END IF;

  IF p_tier NOT IN ('probation', 'standard', 'trusted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid tier. Must be: probation, standard, trusted');
  END IF;

  SELECT tier INTO v_old_tier
  FROM public.mechanic_profiles
  WHERE id = p_mechanic_id;

  IF v_old_tier IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Mechanic not found');
  END IF;

  UPDATE public.mechanic_profiles
  SET 
    tier = p_tier,
    probation_completed_at = CASE 
      WHEN v_old_tier = 'probation' AND p_tier IN ('standard', 'trusted') 
      THEN now() 
      ELSE probation_completed_at 
    END,
    verification_reason = COALESCE(p_reason, verification_reason),
    updated_at = now()
  WHERE id = p_mechanic_id;

  RETURN jsonb_build_object(
    'success', true,
    'old_tier', v_old_tier,
    'new_tier', p_tier,
    'message', 'Tier updated from ' || v_old_tier || ' to ' || p_tier
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_set_mechanic_tier(uuid, text, text) TO authenticated;

-- =====================================================
-- L) ADMIN SET MECHANIC OVERRIDES RPC
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_set_mechanic_overrides(
  p_mechanic_id uuid,
  p_max_quote_cents_override integer DEFAULT NULL,
  p_blocked_symptom_keys text[] DEFAULT NULL,
  p_max_lead_radius_miles_override numeric DEFAULT NULL,
  p_clear_overrides boolean DEFAULT false
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('success', false, 'error', 'Admin access required');
  END IF;

  IF NOT EXISTS (SELECT 1 FROM public.mechanic_profiles WHERE id = p_mechanic_id) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Mechanic not found');
  END IF;

  IF p_clear_overrides THEN
    UPDATE public.mechanic_profiles
    SET 
      max_quote_cents_override = NULL,
      blocked_symptom_keys = NULL,
      max_lead_radius_miles_override = NULL,
      updated_at = now()
    WHERE id = p_mechanic_id;
  ELSE
    UPDATE public.mechanic_profiles
    SET 
      max_quote_cents_override = COALESCE(p_max_quote_cents_override, max_quote_cents_override),
      blocked_symptom_keys = COALESCE(p_blocked_symptom_keys, blocked_symptom_keys),
      max_lead_radius_miles_override = COALESCE(p_max_lead_radius_miles_override, max_lead_radius_miles_override),
      updated_at = now()
    WHERE id = p_mechanic_id;
  END IF;

  RETURN jsonb_build_object('success', true, 'message', 'Overrides updated');
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_set_mechanic_overrides(uuid, integer, text[], numeric, boolean) TO authenticated;

-- =====================================================
-- M) UPDATE get_mechanic_leads TO ENFORCE PROBATION
-- =====================================================

DROP FUNCTION IF EXISTS public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text);

CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text,
  p_mechanic_lat double precision,
  p_mechanic_lng double precision,
  p_radius_miles double precision,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  preferred_time text,
  vehicle_year int,
  vehicle_make text,
  vehicle_model text,
  vehicle_vin text,
  location_lat double precision,
  location_lng double precision,
  location_address text,
  customer_id uuid,
  customer_name text,
  customer_avatar text,
  created_at timestamptz,
  distance_miles numeric,
  quote_count bigint,
  has_quoted boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic record;
  v_policy jsonb;
  v_effective_radius double precision;
  v_blocked_keys text[];
BEGIN
  -- Get mechanic details
  SELECT mp.*, p.role
  INTO v_mechanic
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON p.id = mp.id
  WHERE mp.id = p_mechanic_id;
  
  -- Verify active status
  IF v_mechanic IS NULL OR v_mechanic.verification_status IS NULL OR v_mechanic.verification_status != 'active' THEN
    RETURN;
  END IF;

  -- Get policy
  v_policy := get_effective_mechanic_policy(NULL);

  -- Calculate effective radius for probation
  v_effective_radius := p_radius_miles;
  IF v_mechanic.tier = 'probation' THEN
    v_effective_radius := LEAST(
      p_radius_miles,
      COALESCE(
        v_mechanic.max_lead_radius_miles_override,
        (v_policy->>'probation.max_radius_miles')::numeric,
        15
      )
    );
  END IF;

  -- Get blocked symptom keys for probation
  v_blocked_keys := CASE 
    WHEN v_mechanic.tier = 'probation' THEN
      COALESCE(
        v_mechanic.blocked_symptom_keys,
        ARRAY(SELECT jsonb_array_elements_text(COALESCE(v_policy->'probation.blocked_symptom_keys', '[]'::jsonb)))
      )
    ELSE
      ARRAY[]::text[]
  END;

  RETURN QUERY
  SELECT
    j.id as job_id,
    j.title,
    j.description,
    j.status::text,
    j.preferred_time,
    v.year as vehicle_year,
    v.make as vehicle_make,
    v.model as vehicle_model,
    v.vin as vehicle_vin,
    j.location_lat,
    j.location_lng,
    j.location_address,
    j.customer_id,
    p.full_name as customer_name,
    p.avatar_url as customer_avatar,
    j.created_at,
    CASE 
      WHEN p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL 
           AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      THEN ROUND((
        3959 * acos(
          cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
        )
      )::numeric, 1)
      ELSE NULL
    END as distance_miles,
    (SELECT COUNT(*) FROM public.quotes q WHERE q.job_id = j.id) as quote_count,
    EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id) as has_quoted
  FROM public.jobs j
  JOIN public.profiles p ON p.id = j.customer_id
  LEFT JOIN public.vehicles ve ON ve.id = j.vehicle_id
  WHERE j.status = 'searching'::job_status
    -- Filter out blocked symptom keys for probation mechanics
    AND (array_length(v_blocked_keys, 1) IS NULL OR j.symptom_key IS NULL OR NOT (j.symptom_key = ANY(v_blocked_keys)))
    -- Standard filters
    AND (p_filter = 'all' OR p_filter IS NULL OR
         (p_filter = 'nearby' AND p_mechanic_lat IS NOT NULL) OR
         (p_filter = 'quoted' AND EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id)))
    -- Radius filter (using effective radius for probation)
    AND (v_effective_radius IS NULL OR p_mechanic_lat IS NULL OR p_mechanic_lng IS NULL OR
         j.location_lat IS NULL OR j.location_lng IS NULL OR
         (3959 * acos(
           cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
           cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
           sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
         )) <= v_effective_radius)
  ORDER BY
    CASE WHEN p_sort_by = 'newest' THEN j.created_at END DESC,
    CASE WHEN p_sort_by = 'closest' AND p_mechanic_lat IS NOT NULL THEN
      3959 * acos(
        cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
        sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
      )
    END ASC NULLS LAST,
    j.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text) TO authenticated;

-- =====================================================
-- N) EXTENDED VERIFICATION STATUS RPC
-- =====================================================

DROP FUNCTION IF EXISTS public.get_mechanic_verification_status(uuid);

CREATE OR REPLACE FUNCTION public.get_mechanic_verification_status(p_mechanic_id uuid DEFAULT auth.uid())
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result jsonb;
  v_docs_uploaded int;
  v_docs_approved int;
  v_vetting_count int;
  v_docs_complete boolean;
  v_policy jsonb;
  v_strike_count int;
BEGIN
  -- Get policy
  v_policy := get_effective_mechanic_policy(NULL);

  -- Get strike count
  SELECT COUNT(*) INTO v_strike_count
  FROM public.mechanic_strikes
  WHERE mechanic_id = p_mechanic_id
    AND (expires_at IS NULL OR expires_at > now());

  SELECT 
    jsonb_build_object(
      'status', mp.verification_status,
      'reason', mp.verification_reason,
      'is_active', (mp.verification_status = 'active'),
      'can_view_leads', (mp.verification_status = 'active'),
      'can_submit_quotes', (mp.verification_status = 'active'),
      'tier', mp.tier,
      'probation_started_at', mp.probation_started_at,
      'probation_completed_at', mp.probation_completed_at,
      'strike_count', v_strike_count,
      'max_quote_cents', CASE 
        WHEN mp.tier = 'probation' THEN COALESCE(
          mp.max_quote_cents_override,
          (v_policy->>'probation.max_quote_cents')::integer,
          25000
        )
        ELSE NULL
      END,
      'max_radius_miles', CASE 
        WHEN mp.tier = 'probation' THEN COALESCE(
          mp.max_lead_radius_miles_override,
          (v_policy->>'probation.max_radius_miles')::numeric,
          15
        )
        ELSE NULL
      END,
      'blocked_symptom_keys', CASE 
        WHEN mp.tier = 'probation' THEN COALESCE(
          to_jsonb(mp.blocked_symptom_keys),
          v_policy->'probation.blocked_symptom_keys'
        )
        ELSE NULL
      END,
      'documents_uploaded', (
        SELECT COUNT(DISTINCT doc_type) FROM public.mechanic_verification_documents 
        WHERE mechanic_id = p_mechanic_id
      ),
      'documents_approved', (
        SELECT COUNT(DISTINCT doc_type) FROM public.mechanic_verification_documents 
        WHERE mechanic_id = p_mechanic_id AND status = 'approved'
      ),
      'documents_required', 4,
      'vetting_responses', (
        SELECT COUNT(*) FROM public.mechanic_vetting_responses 
        WHERE mechanic_id = p_mechanic_id
      ),
      'vetting_required', 5,
      'vetting_review_status', COALESCE(
        (SELECT status FROM public.mechanic_vetting_reviews WHERE mechanic_id = p_mechanic_id),
        'pending'
      )
    )
  INTO v_result
  FROM public.mechanic_profiles mp
  WHERE mp.id = p_mechanic_id;

  RETURN COALESCE(v_result, jsonb_build_object(
    'status', 'pending_verification',
    'is_active', false,
    'can_view_leads', false,
    'can_submit_quotes', false,
    'tier', 'probation',
    'strike_count', 0
  ));
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_verification_status(uuid) TO authenticated;

-- =====================================================
-- O) RLS POLICIES
-- =====================================================

-- mechanic_policy_config: read-only for authenticated, write for admins
ALTER TABLE public.mechanic_policy_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Anyone can read policy config" ON public.mechanic_policy_config;
CREATE POLICY "Anyone can read policy config" ON public.mechanic_policy_config
  FOR SELECT TO authenticated USING (true);

DROP POLICY IF EXISTS "Admins can manage policy config" ON public.mechanic_policy_config;
CREATE POLICY "Admins can manage policy config" ON public.mechanic_policy_config
  FOR ALL TO authenticated USING (public.is_admin()) WITH CHECK (public.is_admin());

-- mechanic_strikes: mechanics read own, admins full access
ALTER TABLE public.mechanic_strikes ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Mechanics can view own strikes" ON public.mechanic_strikes;
CREATE POLICY "Mechanics can view own strikes" ON public.mechanic_strikes
  FOR SELECT TO authenticated USING (mechanic_id = auth.uid() OR public.is_admin());

DROP POLICY IF EXISTS "Admins can insert strikes" ON public.mechanic_strikes;
CREATE POLICY "Admins can insert strikes" ON public.mechanic_strikes
  FOR INSERT TO authenticated WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Super admins can delete strikes" ON public.mechanic_strikes;
CREATE POLICY "Super admins can delete strikes" ON public.mechanic_strikes
  FOR DELETE TO authenticated USING (public.is_super_admin());

-- lead_decisions: mechanics manage own
ALTER TABLE public.lead_decisions ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Mechanics can manage own lead decisions" ON public.lead_decisions;
CREATE POLICY "Mechanics can manage own lead decisions" ON public.lead_decisions
  FOR ALL TO authenticated 
  USING (mechanic_id = auth.uid() OR public.is_admin())
  WITH CHECK (mechanic_id = auth.uid());

-- =====================================================
-- P) BACKFILL EXISTING MECHANICS
-- =====================================================
-- Set existing active mechanics to 'standard' tier (not probation)
-- since they were active before the probation system

UPDATE public.mechanic_profiles
SET 
  tier = 'standard',
  probation_started_at = created_at,
  probation_completed_at = created_at
WHERE verification_status = 'active'
  AND tier = 'probation'
  AND probation_started_at IS NULL;

-- For pending_verification mechanics, keep them on probation (will start when activated)

-- =====================================================
-- Q) UPDATE submit_quote_with_payment_check WITH PROBATION ENFORCEMENT
-- =====================================================

CREATE OR REPLACE FUNCTION public.submit_quote_with_payment_check(
  p_job_id uuid,
  p_price_cents int,
  p_estimated_hours numeric DEFAULT NULL,
  p_notes text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic_id uuid;
  v_mechanic record;
  v_job record;
  v_has_payout boolean;
  v_quote_id uuid;
  v_policy jsonb;
  v_max_quote_cents integer;
  v_blocked_keys text[];
BEGIN
  v_mechanic_id := auth.uid();

  IF v_mechanic_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'code', 'NOT_AUTHENTICATED');
  END IF;

  -- Get mechanic details including tier
  SELECT mp.*, p.role
  INTO v_mechanic
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON p.id = mp.id
  WHERE mp.id = v_mechanic_id;

  IF v_mechanic IS NULL THEN
    RETURN jsonb_build_object('success', false, 'code', 'MECHANIC_NOT_FOUND', 'message', 'Mechanic profile not found');
  END IF;

  -- Check verification status
  IF v_mechanic.verification_status != 'active' THEN
    RETURN jsonb_build_object(
      'success', false,
      'code', 'NOT_VERIFIED',
      'message', 'Your account must be verified to submit quotes. Status: ' || COALESCE(v_mechanic.verification_status, 'unknown')
    );
  END IF;

  -- Check if mechanic has payout setup
  SELECT EXISTS (
    SELECT 1 FROM mechanic_stripe_accounts
    WHERE mechanic_id = v_mechanic_id AND stripe_account_id IS NOT NULL
  ) OR EXISTS (
    SELECT 1 FROM mechanic_profiles
    WHERE id = v_mechanic_id AND stripe_account_id IS NOT NULL
  ) INTO v_has_payout;

  IF NOT v_has_payout THEN
    RETURN jsonb_build_object(
      'success', false,
      'code', 'PAYOUT_NOT_SETUP',
      'message', 'Please set up your payout account before submitting quotes'
    );
  END IF;

  -- Get job details
  SELECT j.*
  INTO v_job
  FROM public.jobs j
  WHERE j.id = p_job_id;

  IF v_job IS NULL THEN
    RETURN jsonb_build_object('success', false, 'code', 'JOB_NOT_FOUND', 'message', 'Job not found');
  END IF;

  -- Probation enforcement
  IF v_mechanic.tier = 'probation' THEN
    v_policy := get_effective_mechanic_policy(v_job.hub_id);

    -- Max quote check
    v_max_quote_cents := COALESCE(
      v_mechanic.max_quote_cents_override,
      (v_policy->>'probation.max_quote_cents')::integer,
      25000
    );

    IF p_price_cents > v_max_quote_cents THEN
      RETURN jsonb_build_object(
        'success', false,
        'code', 'PROBATION_QUOTE_LIMIT',
        'message', 'Probation limit: Maximum quote is $' || (v_max_quote_cents / 100.0)::text,
        'max_quote_cents', v_max_quote_cents
      );
    END IF;

    -- Blocked symptom keys check
    v_blocked_keys := COALESCE(
      v_mechanic.blocked_symptom_keys,
      ARRAY(SELECT jsonb_array_elements_text(COALESCE(v_policy->'probation.blocked_symptom_keys', '[]'::jsonb)))
    );

    IF v_job.symptom_key IS NOT NULL AND v_job.symptom_key = ANY(v_blocked_keys) THEN
      RETURN jsonb_build_object(
        'success', false,
        'code', 'PROBATION_CATEGORY_BLOCKED',
        'message', 'Probation limit: This job category is restricted',
        'blocked_symptom', v_job.symptom_key
      );
    END IF;
  END IF;

  -- Insert/update quote
  INSERT INTO quotes (job_id, mechanic_id, price_cents, estimated_hours, notes, status)
  VALUES (p_job_id, v_mechanic_id, p_price_cents, p_estimated_hours, p_notes, 'pending')
  ON CONFLICT (job_id, mechanic_id) DO UPDATE SET
    price_cents = EXCLUDED.price_cents,
    estimated_hours = EXCLUDED.estimated_hours,
    notes = EXCLUDED.notes,
    status = 'pending',
    updated_at = now()
  RETURNING id INTO v_quote_id;

  -- Log decision
  INSERT INTO public.lead_decisions (mechanic_id, job_id, decision)
  VALUES (v_mechanic_id, p_job_id, 'quoted')
  ON CONFLICT (mechanic_id, job_id, decision) DO NOTHING;

  RETURN jsonb_build_object('success', true, 'quote_id', v_quote_id);
END;
$$;

COMMIT;
\n-- ===================================================================
-- END: 20260112000001_mechanic_verification_phase2.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260112000002_fix_mechanic_leads_alias.sql
-- ===================================================================\n
-- Fix get_mechanic_leads alias mismatch
BEGIN;

DROP FUNCTION IF EXISTS public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text);

CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text,
  p_mechanic_lat double precision,
  p_mechanic_lng double precision,
  p_radius_miles double precision,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  preferred_time text,
  vehicle_year int,
  vehicle_make text,
  vehicle_model text,
  vehicle_vin text,
  location_lat double precision,
  location_lng double precision,
  location_address text,
  customer_id uuid,
  customer_name text,
  customer_avatar text,
  created_at timestamptz,
  distance_miles numeric,
  quote_count bigint,
  has_quoted boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic record;
  v_policy jsonb;
  v_effective_radius double precision;
  v_blocked_keys text[];
BEGIN
  SELECT mp.*, p.role
  INTO v_mechanic
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON p.id = mp.id
  WHERE mp.id = p_mechanic_id;
  
  IF v_mechanic IS NULL OR v_mechanic.verification_status IS NULL OR v_mechanic.verification_status != 'active' THEN
    RETURN;
  END IF;

  v_policy := get_effective_mechanic_policy(NULL);

  v_effective_radius := p_radius_miles;
  IF v_mechanic.tier = 'probation' THEN
    v_effective_radius := LEAST(
      p_radius_miles,
      COALESCE(
        v_mechanic.max_lead_radius_miles_override,
        (v_policy->>'probation.max_radius_miles')::numeric,
        15
      )
    );
  END IF;

  v_blocked_keys := CASE 
    WHEN v_mechanic.tier = 'probation' THEN
      COALESCE(
        v_mechanic.blocked_symptom_keys,
        ARRAY(SELECT jsonb_array_elements_text(COALESCE(v_policy->'probation.blocked_symptom_keys', '[]'::jsonb)))
      )
    ELSE
      ARRAY[]::text[]
  END;

  RETURN QUERY
  SELECT
    j.id as job_id,
    j.title,
    j.description,
    j.status::text,
    j.preferred_time,
    ve.year as vehicle_year,
    ve.make as vehicle_make,
    ve.model as vehicle_model,
    ve.vin as vehicle_vin,
    j.location_lat,
    j.location_lng,
    j.location_address,
    j.customer_id,
    p.full_name as customer_name,
    p.avatar_url as customer_avatar,
    j.created_at,
    CASE 
      WHEN p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL 
           AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      THEN ROUND((
        3959 * acos(
          cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
        )
      )::numeric, 1)
      ELSE NULL
    END as distance_miles,
    (SELECT COUNT(*) FROM public.quotes q WHERE q.job_id = j.id) as quote_count,
    EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id) as has_quoted
  FROM public.jobs j
  JOIN public.profiles p ON p.id = j.customer_id
  LEFT JOIN public.vehicles ve ON ve.id = j.vehicle_id
  WHERE j.status = 'searching'::job_status
    AND (array_length(v_blocked_keys, 1) IS NULL OR j.symptom_key IS NULL OR NOT (j.symptom_key = ANY(v_blocked_keys)))
    AND (p_filter = 'all' OR p_filter IS NULL OR
         (p_filter = 'nearby' AND p_mechanic_lat IS NOT NULL) OR
         (p_filter = 'quoted' AND EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id)))
    AND (v_effective_radius IS NULL OR p_mechanic_lat IS NULL OR p_mechanic_lng IS NULL OR
         j.location_lat IS NULL OR j.location_lng IS NULL OR
         (3959 * acos(
           cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
           cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
           sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
         )) <= v_effective_radius)
  ORDER BY
    CASE WHEN p_sort_by = 'newest' THEN j.created_at END DESC,
    CASE WHEN p_sort_by = 'closest' AND p_mechanic_lat IS NOT NULL THEN
      3959 * acos(
        cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
        sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
      )
    END ASC NULLS LAST,
    j.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260112000002_fix_mechanic_leads_alias.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260112000003_fix_create_job_symptom_id.sql
-- ===================================================================\n
-- Fix: symptoms table uses 'key' as PK, not 'id'
-- The symptom_id should come from symptom_mappings table which has 'id'

BEGIN;

CREATE OR REPLACE FUNCTION public.create_job_with_payment_check(
  p_title text,
  p_description text DEFAULT NULL,
  p_location_address text DEFAULT NULL,
  p_location_lat double precision DEFAULT NULL,
  p_location_lng double precision DEFAULT NULL,
  p_vehicle_id uuid DEFAULT NULL,
  p_preferred_time text DEFAULT NULL,
  p_symptom_key text DEFAULT NULL,
  p_symptom_id uuid DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_customer_id uuid;
  v_payment_status payment_method_status;
  v_job_id uuid;
  v_symptom_id uuid;
BEGIN
  v_customer_id := auth.uid();
  
  IF v_customer_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'code', 'NOT_AUTHENTICATED');
  END IF;

  SELECT payment_method_status INTO v_payment_status
  FROM profiles WHERE id = v_customer_id;

  IF v_payment_status IS NULL OR v_payment_status != 'active' THEN
    RETURN jsonb_build_object(
      'success', false,
      'code', 'PAYMENT_METHOD_REQUIRED',
      'message', 'A valid payment method is required to request service'
    );
  END IF;

  -- Look up symptom_id from symptom_mappings using symptom_key
  v_symptom_id := p_symptom_id;
  IF v_symptom_id IS NULL AND p_symptom_key IS NOT NULL THEN
    SELECT id INTO v_symptom_id FROM symptom_mappings WHERE symptom_key = p_symptom_key LIMIT 1;
  END IF;

  INSERT INTO jobs (customer_id, title, description, location_address, location_lat, location_lng, vehicle_id, preferred_time, symptom_key, symptom_id, status)
  VALUES (v_customer_id, p_title, p_description, p_location_address, p_location_lat, p_location_lng, p_vehicle_id, p_preferred_time, p_symptom_key, v_symptom_id, 'searching')
  RETURNING id INTO v_job_id;

  RETURN jsonb_build_object('success', true, 'job_id', v_job_id);
END;
$$;

GRANT EXECUTE ON FUNCTION public.create_job_with_payment_check(text, text, text, double precision, double precision, uuid, text, text, uuid) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260112000003_fix_create_job_symptom_id.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260113000001_phase3_disputes_chat_enforcement.sql
-- ===================================================================\n
-- =====================================================
-- PHASE 3: Job Quality, Comebacks, Disputes, Chat Safety
-- =====================================================
-- Implements:
-- A) Comeback workflow (customer reports issue on completed job)
-- B) Dispute resolution enforcement (admin tools)
-- C) Chat lifecycle enforcement (strict)
-- D) Off-platform communication detection
-- E) Mechanic SLA enforcement
-- =====================================================

BEGIN;

-- =====================================================
-- A) DISPUTES TABLE ENHANCEMENTS
-- =====================================================

-- Add mechanic response fields
ALTER TABLE public.disputes
  ADD COLUMN IF NOT EXISTS mechanic_response text,
  ADD COLUMN IF NOT EXISTS mechanic_responded_at timestamptz,
  ADD COLUMN IF NOT EXISTS sla_breached boolean DEFAULT false,
  ADD COLUMN IF NOT EXISTS escalated_at timestamptz;

-- Add comeback event type if not exists
DO $$ BEGIN
  ALTER TYPE public.job_event_type ADD VALUE IF NOT EXISTS 'comeback_reported';
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  ALTER TYPE public.job_event_type ADD VALUE IF NOT EXISTS 'dispute_escalated';
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  ALTER TYPE public.job_event_type ADD VALUE IF NOT EXISTS 'mechanic_responded';
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  ALTER TYPE public.job_event_type ADD VALUE IF NOT EXISTS 'chat_closed';
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- =====================================================
-- B) PLATFORM POLICY CONFIG FOR PHASE 3
-- =====================================================

INSERT INTO public.mechanic_policy_config (key, value, description) VALUES
  ('disputes.comeback_window_days', '14', 'Days after job completion customer can report comeback'),
  ('disputes.mechanic_response_sla_hours', '12', 'Hours mechanic has to respond to dispute'),
  ('disputes.evidence_deadline_hours', '48', 'Hours to submit evidence after dispute filed'),
  ('chat.post_completion_window_hours', '48', 'Hours chat remains open after job completion'),
  ('chat.readonly_period_days', '30', 'Days chat remains read-only before archiving')
ON CONFLICT (key) DO NOTHING;

-- =====================================================
-- C) FUNCTION: Check if customer can file comeback
-- =====================================================

CREATE OR REPLACE FUNCTION public.can_file_comeback(p_job_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_job record;
  v_customer_id uuid := auth.uid();
  v_policy jsonb;
  v_comeback_window_days int;
  v_days_since_completion int;
  v_existing_dispute uuid;
BEGIN
  -- Get job details
  SELECT j.*, jc.id as contract_id, jp.finalized_at
  INTO v_job
  FROM public.jobs j
  LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
  LEFT JOIN public.job_progress jp ON jp.job_id = j.id
  WHERE j.id = p_job_id;

  IF v_job IS NULL THEN
    RETURN jsonb_build_object('can_file', false, 'reason', 'Job not found');
  END IF;

  IF v_job.customer_id != v_customer_id THEN
    RETURN jsonb_build_object('can_file', false, 'reason', 'Not your job');
  END IF;

  IF v_job.status != 'completed' THEN
    RETURN jsonb_build_object('can_file', false, 'reason', 'Job not completed');
  END IF;

  -- Check for existing open dispute
  SELECT id INTO v_existing_dispute
  FROM public.disputes
  WHERE job_id = p_job_id
    AND status IN ('open', 'under_review', 'evidence_requested');

  IF v_existing_dispute IS NOT NULL THEN
    RETURN jsonb_build_object('can_file', false, 'reason', 'Dispute already exists', 'dispute_id', v_existing_dispute);
  END IF;

  -- Get policy
  v_policy := get_effective_mechanic_policy(NULL);
  v_comeback_window_days := COALESCE((v_policy->>'disputes.comeback_window_days')::int, 14);

  -- Calculate days since completion
  v_days_since_completion := EXTRACT(DAY FROM (now() - COALESCE(v_job.finalized_at, v_job.updated_at)));

  IF v_days_since_completion > v_comeback_window_days THEN
    RETURN jsonb_build_object(
      'can_file', false,
      'reason', 'Comeback window expired',
      'window_days', v_comeback_window_days,
      'days_since', v_days_since_completion
    );
  END IF;

  RETURN jsonb_build_object(
    'can_file', true,
    'window_days', v_comeback_window_days,
    'days_remaining', v_comeback_window_days - v_days_since_completion,
    'contract_id', v_job.contract_id,
    'mechanic_id', v_job.accepted_mechanic_id
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.can_file_comeback(uuid) TO authenticated;

-- =====================================================
-- D) FUNCTION: Customer files comeback
-- =====================================================

CREATE OR REPLACE FUNCTION public.customer_file_comeback(
  p_job_id uuid,
  p_description text,
  p_desired_resolution text DEFAULT NULL,
  p_evidence_urls text[] DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_customer_id uuid := auth.uid();
  v_can_file jsonb;
  v_job record;
  v_policy jsonb;
  v_response_sla_hours int;
  v_evidence_deadline_hours int;
  v_dispute_id uuid;
BEGIN
  -- Check if can file
  v_can_file := can_file_comeback(p_job_id);

  IF NOT (v_can_file->>'can_file')::boolean THEN
    RETURN jsonb_build_object('success', false, 'error', v_can_file->>'reason');
  END IF;

  -- Get job details
  SELECT j.*, jc.id as contract_id
  INTO v_job
  FROM public.jobs j
  LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
  WHERE j.id = p_job_id;

  -- Get policy for SLA
  v_policy := get_effective_mechanic_policy(NULL);
  v_response_sla_hours := COALESCE((v_policy->>'disputes.mechanic_response_sla_hours')::int, 12);
  v_evidence_deadline_hours := COALESCE((v_policy->>'disputes.evidence_deadline_hours')::int, 48);

  -- Create dispute
  INSERT INTO public.disputes (
    job_id,
    contract_id,
    filed_by,
    filed_by_role,
    filed_against,
    status,
    category,
    description,
    desired_resolution,
    evidence_urls,
    priority,
    response_deadline,
    evidence_deadline
  ) VALUES (
    p_job_id,
    v_job.contract_id,
    v_customer_id,
    'customer',
    v_job.accepted_mechanic_id,
    'open',
    'comeback',
    p_description,
    p_desired_resolution,
    p_evidence_urls,
    'normal',
    now() + (v_response_sla_hours || ' hours')::interval,
    now() + (v_evidence_deadline_hours || ' hours')::interval
  )
  RETURNING id INTO v_dispute_id;

  -- Log job event
  INSERT INTO public.job_events (
    job_id,
    contract_id,
    event_type,
    actor_id,
    actor_role,
    title,
    description,
    metadata
  ) VALUES (
    p_job_id,
    v_job.contract_id,
    'comeback_reported',
    v_customer_id,
    'customer',
    'Issue reported',
    'Customer reported: ' || LEFT(p_description, 100),
    jsonb_build_object('dispute_id', v_dispute_id, 'category', 'comeback')
  );

  -- Update chat lifecycle to mark dispute
  UPDATE public.chat_lifecycle_config
  SET has_dispute = true, updated_at = now()
  WHERE job_id = p_job_id;

  RETURN jsonb_build_object(
    'success', true,
    'dispute_id', v_dispute_id,
    'response_deadline', now() + (v_response_sla_hours || ' hours')::interval
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.customer_file_comeback(uuid, text, text, text[]) TO authenticated;

-- =====================================================
-- E) FUNCTION: Mechanic responds to dispute
-- =====================================================

CREATE OR REPLACE FUNCTION public.mechanic_respond_to_dispute(
  p_dispute_id uuid,
  p_response text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic_id uuid := auth.uid();
  v_dispute record;
BEGIN
  -- Get dispute
  SELECT * INTO v_dispute
  FROM public.disputes
  WHERE id = p_dispute_id;

  IF v_dispute IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Dispute not found');
  END IF;

  IF v_dispute.filed_against != v_mechanic_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;

  IF v_dispute.mechanic_response IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Already responded');
  END IF;

  IF v_dispute.status NOT IN ('open', 'under_review', 'evidence_requested') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Dispute is closed');
  END IF;

  -- Check if past SLA
  UPDATE public.disputes
  SET 
    mechanic_response = p_response,
    mechanic_responded_at = now(),
    sla_breached = CASE WHEN now() > response_deadline THEN true ELSE false END,
    status = 'under_review',
    updated_at = now()
  WHERE id = p_dispute_id;

  -- Log job event
  INSERT INTO public.job_events (
    job_id,
    contract_id,
    event_type,
    actor_id,
    actor_role,
    title,
    description,
    metadata
  ) VALUES (
    v_dispute.job_id,
    v_dispute.contract_id,
    'mechanic_responded',
    v_mechanic_id,
    'mechanic',
    'Mechanic responded to dispute',
    LEFT(p_response, 100),
    jsonb_build_object('dispute_id', p_dispute_id, 'sla_breached', now() > v_dispute.response_deadline)
  );

  RETURN jsonb_build_object(
    'success', true,
    'sla_breached', now() > v_dispute.response_deadline
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.mechanic_respond_to_dispute(uuid, text) TO authenticated;

-- =====================================================
-- F) FUNCTION: Admin resolve dispute
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_resolve_dispute(
  p_dispute_id uuid,
  p_resolution_type text,
  p_resolution_notes text,
  p_customer_refund_cents int DEFAULT 0,
  p_mechanic_adjustment_cents int DEFAULT 0
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id uuid := auth.uid();
  v_dispute record;
  v_new_status dispute_status;
BEGIN
  -- Check admin
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;

  -- Validate resolution type
  IF p_resolution_type NOT IN ('rework', 'partial_refund', 'full_refund', 'credit', 'no_action', 'mechanic_favor') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid resolution type');
  END IF;

  -- Get dispute
  SELECT * INTO v_dispute
  FROM public.disputes
  WHERE id = p_dispute_id;

  IF v_dispute IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Dispute not found');
  END IF;

  IF v_dispute.status IN ('resolved_customer', 'resolved_mechanic', 'resolved_split', 'closed') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Dispute already resolved');
  END IF;

  -- Determine final status
  v_new_status := CASE p_resolution_type
    WHEN 'full_refund' THEN 'resolved_customer'::dispute_status
    WHEN 'partial_refund' THEN 'resolved_split'::dispute_status
    WHEN 'credit' THEN 'resolved_split'::dispute_status
    WHEN 'rework' THEN 'resolved_split'::dispute_status
    WHEN 'mechanic_favor' THEN 'resolved_mechanic'::dispute_status
    WHEN 'no_action' THEN 'closed'::dispute_status
    ELSE 'closed'::dispute_status
  END;

  -- Update dispute
  UPDATE public.disputes
  SET 
    status = v_new_status,
    resolved_at = now(),
    resolved_by = v_admin_id,
    resolution_type = p_resolution_type,
    resolution_notes = p_resolution_notes,
    customer_refund_cents = p_customer_refund_cents,
    mechanic_adjustment_cents = p_mechanic_adjustment_cents,
    updated_at = now()
  WHERE id = p_dispute_id;

  -- Log job event
  INSERT INTO public.job_events (
    job_id,
    contract_id,
    event_type,
    actor_id,
    actor_role,
    title,
    description,
    metadata,
    visible_to_customer,
    visible_to_mechanic
  ) VALUES (
    v_dispute.job_id,
    v_dispute.contract_id,
    'dispute_resolved',
    v_admin_id,
    'admin',
    'Dispute resolved',
    'Resolution: ' || p_resolution_type,
    jsonb_build_object(
      'dispute_id', p_dispute_id,
      'resolution_type', p_resolution_type,
      'customer_refund_cents', p_customer_refund_cents,
      'mechanic_adjustment_cents', p_mechanic_adjustment_cents
    ),
    true,
    true
  );

  -- Update chat lifecycle - close dispute flag if resolution is final
  UPDATE public.chat_lifecycle_config
  SET has_dispute = false, updated_at = now()
  WHERE job_id = v_dispute.job_id;

  RETURN jsonb_build_object(
    'success', true,
    'status', v_new_status
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_resolve_dispute(uuid, text, text, int, int) TO authenticated;

-- =====================================================
-- G) FUNCTION: Get disputes for admin
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_disputes(
  p_status text DEFAULT NULL,
  p_priority text DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  job_id uuid,
  contract_id uuid,
  filed_by uuid,
  filed_by_role user_role,
  filed_by_name text,
  filed_against uuid,
  filed_against_name text,
  status dispute_status,
  category text,
  description text,
  desired_resolution text,
  mechanic_response text,
  mechanic_responded_at timestamptz,
  evidence_urls text[],
  resolution_type text,
  resolution_notes text,
  customer_refund_cents int,
  priority text,
  response_deadline timestamptz,
  sla_breached boolean,
  created_at timestamptz,
  resolved_at timestamptz,
  job_title text,
  job_status text
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    d.id,
    d.job_id,
    d.contract_id,
    d.filed_by,
    d.filed_by_role,
    pf.full_name as filed_by_name,
    d.filed_against,
    pa.full_name as filed_against_name,
    d.status,
    d.category,
    d.description,
    d.desired_resolution,
    d.mechanic_response,
    d.mechanic_responded_at,
    d.evidence_urls,
    d.resolution_type,
    d.resolution_notes,
    d.customer_refund_cents,
    d.priority,
    d.response_deadline,
    d.sla_breached,
    d.created_at,
    d.resolved_at,
    j.title as job_title,
    j.status::text as job_status
  FROM public.disputes d
  JOIN public.profiles pf ON pf.id = d.filed_by
  JOIN public.profiles pa ON pa.id = d.filed_against
  JOIN public.jobs j ON j.id = d.job_id
  WHERE (p_status IS NULL OR d.status::text = p_status)
    AND (p_priority IS NULL OR d.priority = p_priority)
  ORDER BY 
    CASE d.priority 
      WHEN 'high' THEN 1 
      WHEN 'normal' THEN 2 
      WHEN 'low' THEN 3 
    END,
    d.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_disputes(text, text, int, int) TO authenticated;

-- =====================================================
-- H) FUNCTION: Get single dispute for admin
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_dispute_detail(p_dispute_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result jsonb;
  v_events jsonb;
  v_messages jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Not authorized');
  END IF;

  -- Get dispute with related data
  SELECT jsonb_build_object(
    'dispute', row_to_json(d),
    'job', row_to_json(j),
    'contract', row_to_json(jc),
    'customer', jsonb_build_object('id', pc.id, 'full_name', pc.full_name, 'avatar_url', pc.avatar_url),
    'mechanic', jsonb_build_object('id', pm.id, 'full_name', pm.full_name, 'avatar_url', pm.avatar_url)
  )
  INTO v_result
  FROM public.disputes d
  JOIN public.jobs j ON j.id = d.job_id
  LEFT JOIN public.job_contracts jc ON jc.job_id = d.job_id
  JOIN public.profiles pc ON pc.id = d.filed_by
  JOIN public.profiles pm ON pm.id = d.filed_against
  WHERE d.id = p_dispute_id;

  IF v_result IS NULL THEN
    RETURN jsonb_build_object('error', 'Dispute not found');
  END IF;

  -- Get job events
  SELECT jsonb_agg(row_to_json(je) ORDER BY je.created_at DESC)
  INTO v_events
  FROM public.job_events je
  WHERE je.job_id = (v_result->'dispute'->>'job_id')::uuid;

  -- Get recent messages
  SELECT jsonb_agg(jsonb_build_object(
    'id', m.id,
    'sender_id', m.sender_id,
    'body', m.body,
    'created_at', m.created_at
  ) ORDER BY m.created_at DESC)
  INTO v_messages
  FROM public.messages m
  WHERE m.job_id = (v_result->'dispute'->>'job_id')::uuid
  LIMIT 50;

  v_result := v_result || jsonb_build_object('events', COALESCE(v_events, '[]'::jsonb));
  v_result := v_result || jsonb_build_object('messages', COALESCE(v_messages, '[]'::jsonb));

  RETURN v_result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_dispute_detail(uuid) TO authenticated;

-- =====================================================
-- I) FUNCTION: Send message with chat lifecycle enforcement
-- =====================================================

CREATE OR REPLACE FUNCTION public.send_message_enforced(
  p_job_id uuid,
  p_body text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_sender_id uuid := auth.uid();
  v_job record;
  v_lifecycle record;
  v_recipient_id uuid;
  v_detection jsonb;
  v_message_id uuid;
  v_action message_action := 'allowed';
BEGIN
  -- Get job
  SELECT * INTO v_job
  FROM public.jobs
  WHERE id = p_job_id;

  IF v_job IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job not found');
  END IF;

  -- Check user is part of job
  IF v_sender_id != v_job.customer_id AND v_sender_id != v_job.accepted_mechanic_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;

  -- Determine recipient
  v_recipient_id := CASE WHEN v_sender_id = v_job.customer_id 
    THEN v_job.accepted_mechanic_id 
    ELSE v_job.customer_id 
  END;

  IF v_recipient_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'No recipient - job may not be assigned yet');
  END IF;

  -- Get chat lifecycle
  SELECT * INTO v_lifecycle
  FROM public.chat_lifecycle_config
  WHERE job_id = p_job_id;

  -- Check if chat is closed (readonly)
  IF v_lifecycle IS NOT NULL AND v_lifecycle.chat_readonly_at IS NOT NULL AND now() > v_lifecycle.chat_readonly_at THEN
    -- Log blocked attempt
    INSERT INTO public.message_audit_logs (
      message_id,
      conversation_id,
      sender_id,
      recipient_id,
      original_content,
      patterns_detected,
      action_taken,
      job_id,
      job_stage
    ) VALUES (
      gen_random_uuid(),
      p_job_id,
      v_sender_id,
      v_recipient_id,
      p_body,
      ARRAY['chat_closed'],
      'blocked',
      p_job_id,
      'closed'
    );

    RETURN jsonb_build_object('success', false, 'error', 'Chat is closed', 'reason', 'readonly');
  END IF;

  -- Detect contact info / off-platform communication
  v_detection := detect_contact_info(p_body);

  IF (v_detection->>'risk_score')::numeric >= 30 THEN
    v_action := 'blocked';

    -- Log blocked message
    INSERT INTO public.message_audit_logs (
      message_id,
      conversation_id,
      sender_id,
      recipient_id,
      original_content,
      patterns_detected,
      risk_score,
      action_taken,
      job_id,
      job_stage,
      flagged_for_review
    ) VALUES (
      gen_random_uuid(),
      p_job_id,
      v_sender_id,
      v_recipient_id,
      p_body,
      (v_detection->'patterns')::text[],
      (v_detection->>'risk_score')::numeric,
      'blocked',
      p_job_id,
      v_job.status::text,
      true
    );

    -- Create warning violation
    INSERT INTO public.user_violations (
      user_id,
      violation_type,
      tier,
      description,
      job_id
    ) VALUES (
      v_sender_id,
      'contact_info_sharing',
      'warning',
      'Attempted to share contact information',
      p_job_id
    );

    RETURN jsonb_build_object(
      'success', false,
      'error', 'Message blocked',
      'reason', 'Contact information detected. Please keep all communication on the platform.'
    );
  END IF;

  -- Insert message
  INSERT INTO public.messages (job_id, sender_id, recipient_id, body)
  VALUES (p_job_id, v_sender_id, v_recipient_id, p_body)
  RETURNING id INTO v_message_id;

  RETURN jsonb_build_object('success', true, 'message_id', v_message_id);
END;
$$;

GRANT EXECUTE ON FUNCTION public.send_message_enforced(uuid, text) TO authenticated;

-- =====================================================
-- J) FUNCTION: Close chat after job completion
-- =====================================================

CREATE OR REPLACE FUNCTION public.close_chat_for_job(p_job_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_policy jsonb;
  v_post_completion_hours int;
  v_readonly_days int;
BEGIN
  v_policy := get_effective_mechanic_policy(NULL);
  v_post_completion_hours := COALESCE((v_policy->>'chat.post_completion_window_hours')::int, 48);
  v_readonly_days := COALESCE((v_policy->>'chat.readonly_period_days')::int, 30);

  INSERT INTO public.chat_lifecycle_config (
    conversation_id,
    job_id,
    job_completed_at,
    chat_readonly_at,
    chat_archived_at,
    post_completion_window_hours,
    readonly_period_days
  ) VALUES (
    p_job_id,
    p_job_id,
    now(),
    now() + (v_post_completion_hours || ' hours')::interval,
    now() + (v_readonly_days || ' days')::interval,
    v_post_completion_hours,
    v_readonly_days
  )
  ON CONFLICT (conversation_id) DO UPDATE SET
    job_completed_at = now(),
    chat_readonly_at = now() + (v_post_completion_hours || ' hours')::interval,
    chat_archived_at = now() + (v_readonly_days || ' days')::interval,
    updated_at = now();
END;
$$;

-- =====================================================
-- K) TRIGGER: Auto-close chat on job completion
-- =====================================================

CREATE OR REPLACE FUNCTION public.on_job_completed_close_chat()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
    PERFORM close_chat_for_job(NEW.id);
  END IF;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_job_completed_close_chat ON public.jobs;
CREATE TRIGGER trg_job_completed_close_chat
  AFTER UPDATE ON public.jobs
  FOR EACH ROW
  EXECUTE FUNCTION public.on_job_completed_close_chat();

-- =====================================================
-- L) FUNCTION: Escalate dispute (for SLA breach)
-- =====================================================

CREATE OR REPLACE FUNCTION public.escalate_overdue_disputes()
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_count int := 0;
  v_dispute record;
BEGIN
  -- Find disputes past response deadline without mechanic response
  FOR v_dispute IN
    SELECT d.*
    FROM public.disputes d
    WHERE d.status = 'open'
      AND d.mechanic_response IS NULL
      AND d.response_deadline < now()
      AND d.sla_breached = false
  LOOP
    -- Mark as breached and escalate
    UPDATE public.disputes
    SET 
      sla_breached = true,
      priority = 'high',
      escalated_at = now(),
      updated_at = now()
    WHERE id = v_dispute.id;

    -- Log event
    INSERT INTO public.job_events (
      job_id,
      contract_id,
      event_type,
      title,
      description,
      metadata,
      is_system_message
    ) VALUES (
      v_dispute.job_id,
      v_dispute.contract_id,
      'dispute_escalated',
      'Dispute escalated - SLA breached',
      'Mechanic did not respond within the required timeframe',
      jsonb_build_object('dispute_id', v_dispute.id),
      true
    );

    -- Add strike if Phase 2 mechanic_strikes exists
    BEGIN
      INSERT INTO public.mechanic_strikes (
        mechanic_id,
        job_id,
        reason,
        notes,
        severity,
        created_by
      ) VALUES (
        v_dispute.filed_against,
        v_dispute.job_id,
        'policy_violation',
        'SLA breach: Failed to respond to dispute within deadline',
        1,
        v_dispute.filed_against  -- Self-reference as system action
      );
    EXCEPTION WHEN undefined_table THEN
      -- mechanic_strikes doesn't exist, skip
      NULL;
    END;

    v_count := v_count + 1;
  END LOOP;

  RETURN v_count;
END;
$$;

GRANT EXECUTE ON FUNCTION public.escalate_overdue_disputes() TO service_role;

-- =====================================================
-- M) RLS POLICIES
-- =====================================================

-- Disputes RLS
ALTER TABLE public.disputes ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "disputes_select_own" ON public.disputes;
CREATE POLICY "disputes_select_own" ON public.disputes
  FOR SELECT TO authenticated
  USING (
    filed_by = auth.uid() OR 
    filed_against = auth.uid() OR 
    public.is_admin()
  );

DROP POLICY IF EXISTS "disputes_insert_customer" ON public.disputes;
CREATE POLICY "disputes_insert_customer" ON public.disputes
  FOR INSERT TO authenticated
  WITH CHECK (filed_by = auth.uid());

DROP POLICY IF EXISTS "disputes_update_involved" ON public.disputes;
CREATE POLICY "disputes_update_involved" ON public.disputes
  FOR UPDATE TO authenticated
  USING (
    (filed_against = auth.uid() AND mechanic_response IS NULL) OR
    public.is_admin()
  );

-- message_audit_logs RLS
ALTER TABLE public.message_audit_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "message_audit_admin_only" ON public.message_audit_logs;
CREATE POLICY "message_audit_admin_only" ON public.message_audit_logs
  FOR ALL TO authenticated
  USING (public.is_admin());

-- user_violations RLS
ALTER TABLE public.user_violations ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "violations_own_or_admin" ON public.user_violations;
CREATE POLICY "violations_own_or_admin" ON public.user_violations
  FOR SELECT TO authenticated
  USING (user_id = auth.uid() OR public.is_admin());

DROP POLICY IF EXISTS "violations_admin_insert" ON public.user_violations;
CREATE POLICY "violations_admin_insert" ON public.user_violations
  FOR INSERT TO authenticated
  WITH CHECK (public.is_admin() OR user_id = auth.uid());

-- chat_lifecycle_config RLS
ALTER TABLE public.chat_lifecycle_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "chat_lifecycle_involved" ON public.chat_lifecycle_config;
CREATE POLICY "chat_lifecycle_involved" ON public.chat_lifecycle_config
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.jobs j
      WHERE j.id = chat_lifecycle_config.job_id
        AND (j.customer_id = auth.uid() OR j.accepted_mechanic_id = auth.uid())
    )
    OR public.is_admin()
  );

-- =====================================================
-- N) GRANTS
-- =====================================================

GRANT SELECT ON public.disputes TO authenticated;
GRANT INSERT ON public.disputes TO authenticated;
GRANT UPDATE ON public.disputes TO authenticated;
GRANT SELECT ON public.message_audit_logs TO authenticated;
GRANT INSERT ON public.message_audit_logs TO authenticated;
GRANT SELECT ON public.user_violations TO authenticated;
GRANT INSERT ON public.user_violations TO authenticated;
GRANT SELECT ON public.chat_lifecycle_config TO authenticated;

-- =====================================================
-- O) INDEXES
-- =====================================================

CREATE INDEX IF NOT EXISTS idx_disputes_status ON public.disputes(status);
CREATE INDEX IF NOT EXISTS idx_disputes_filed_by ON public.disputes(filed_by);
CREATE INDEX IF NOT EXISTS idx_disputes_filed_against ON public.disputes(filed_against);
CREATE INDEX IF NOT EXISTS idx_disputes_response_deadline ON public.disputes(response_deadline) WHERE mechanic_response IS NULL;
CREATE INDEX IF NOT EXISTS idx_disputes_priority ON public.disputes(priority, created_at DESC);

COMMIT;
\n-- ===================================================================
-- END: 20260113000001_phase3_disputes_chat_enforcement.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260117000001_fix_mechanic_leads_quoted_filter.sql
-- ===================================================================\n
-- Fix get_mechanic_leads to show quoted jobs properly
BEGIN;

DROP FUNCTION IF EXISTS public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text);

CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text,
  p_mechanic_lat double precision,
  p_mechanic_lng double precision,
  p_radius_miles double precision,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  preferred_time text,
  vehicle_year int,
  vehicle_make text,
  vehicle_model text,
  vehicle_vin text,
  location_lat double precision,
  location_lng double precision,
  location_address text,
  customer_id uuid,
  customer_name text,
  customer_avatar text,
  created_at timestamptz,
  distance_miles numeric,
  quote_count bigint,
  has_quoted boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_verification_status text;
BEGIN
  SELECT mp.verification_status INTO v_verification_status
  FROM public.mechanic_profiles mp
  WHERE mp.id = p_mechanic_id;
  
  IF v_verification_status IS NULL OR v_verification_status != 'active' THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT
    j.id as job_id,
    j.title,
    j.description,
    j.status::text,
    j.preferred_time,
    v.year as vehicle_year,
    v.make as vehicle_make,
    v.model as vehicle_model,
    v.vin as vehicle_vin,
    j.location_lat,
    j.location_lng,
    j.location_address,
    j.customer_id,
    p.full_name as customer_name,
    p.avatar_url as customer_avatar,
    j.created_at,
    CASE
      WHEN p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL
           AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      THEN ROUND((
        3959 * acos(
          cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
        )
      )::numeric, 1)
      ELSE NULL
    END as distance_miles,
    (SELECT COUNT(*) FROM public.quotes q WHERE q.job_id = j.id) as quote_count,
    EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id) as has_quoted
  FROM public.jobs j
  JOIN public.profiles p ON p.id = j.customer_id
  LEFT JOIN public.vehicles v ON v.id = j.vehicle_id
  WHERE 
    -- All filters show jobs in searching or quoted status
    j.status IN ('searching', 'quoted')
    -- For 'quoted' filter, additionally require mechanic has quoted
    AND (
      p_filter != 'quoted' 
      OR EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id)
    )
    AND (p_radius_miles IS NULL OR p_mechanic_lat IS NULL OR p_mechanic_lng IS NULL OR
         j.location_lat IS NULL OR j.location_lng IS NULL OR
         (3959 * acos(
           cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
           cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
           sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
         )) <= p_radius_miles)
  ORDER BY
    CASE WHEN p_sort_by = 'newest' THEN j.created_at END DESC,
    CASE WHEN p_sort_by = 'closest' AND p_mechanic_lat IS NOT NULL THEN
      3959 * acos(
        cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
        sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
      )
    END ASC NULLS LAST,
    j.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260117000001_fix_mechanic_leads_quoted_filter.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260117000002_fix_mechanic_leads_statuses.sql
-- ===================================================================\n
-- Fix get_mechanic_leads to show quoted jobs properly - include both statuses
BEGIN;

DROP FUNCTION IF EXISTS public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text);

CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text,
  p_mechanic_lat double precision,
  p_mechanic_lng double precision,
  p_radius_miles double precision,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  preferred_time text,
  vehicle_year int,
  vehicle_make text,
  vehicle_model text,
  vehicle_vin text,
  location_lat double precision,
  location_lng double precision,
  location_address text,
  customer_id uuid,
  customer_name text,
  customer_avatar text,
  created_at timestamptz,
  distance_miles numeric,
  quote_count bigint,
  has_quoted boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_verification_status text;
BEGIN
  SELECT mp.verification_status INTO v_verification_status
  FROM public.mechanic_profiles mp
  WHERE mp.id = p_mechanic_id;
  
  IF v_verification_status IS NULL OR v_verification_status != 'active' THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT
    j.id as job_id,
    j.title,
    j.description,
    j.status::text,
    j.preferred_time,
    v.year as vehicle_year,
    v.make as vehicle_make,
    v.model as vehicle_model,
    v.vin as vehicle_vin,
    j.location_lat,
    j.location_lng,
    j.location_address,
    j.customer_id,
    p.full_name as customer_name,
    p.avatar_url as customer_avatar,
    j.created_at,
    CASE
      WHEN p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL
           AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      THEN ROUND((
        3959 * acos(
          cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
        )
      )::numeric, 1)
      ELSE NULL
    END as distance_miles,
    (SELECT COUNT(*) FROM public.quotes q WHERE q.job_id = j.id) as quote_count,
    EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id) as has_quoted
  FROM public.jobs j
  JOIN public.profiles p ON p.id = j.customer_id
  LEFT JOIN public.vehicles v ON v.id = j.vehicle_id
  WHERE 
    -- All filters show jobs in searching or quoted status
    j.status IN ('searching', 'quoted')
    -- For 'quoted' filter, additionally require mechanic has quoted
    AND (
      p_filter != 'quoted' 
      OR EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id)
    )
    AND (p_radius_miles IS NULL OR p_mechanic_lat IS NULL OR p_mechanic_lng IS NULL OR
         j.location_lat IS NULL OR j.location_lng IS NULL OR
         (3959 * acos(
           cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
           cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
           sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
         )) <= p_radius_miles)
  ORDER BY
    CASE WHEN p_sort_by = 'newest' THEN j.created_at END DESC,
    CASE WHEN p_sort_by = 'closest' AND p_mechanic_lat IS NOT NULL THEN
      3959 * acos(
        cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
        sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
      )
    END ASC NULLS LAST,
    j.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260117000002_fix_mechanic_leads_statuses.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260117000003_fix_mechanic_leads_cast.sql
-- ===================================================================\n
-- Fix get_mechanic_leads to show quoted jobs properly - cast enum explicitly
BEGIN;

DROP FUNCTION IF EXISTS public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text);

CREATE OR REPLACE FUNCTION public.get_mechanic_leads(
  p_mechanic_id uuid,
  p_filter text,
  p_mechanic_lat double precision,
  p_mechanic_lng double precision,
  p_radius_miles double precision,
  p_limit integer DEFAULT 20,
  p_offset integer DEFAULT 0,
  p_sort_by text DEFAULT 'newest'
)
RETURNS TABLE (
  job_id uuid,
  title text,
  description text,
  status text,
  preferred_time text,
  vehicle_year int,
  vehicle_make text,
  vehicle_model text,
  vehicle_vin text,
  location_lat double precision,
  location_lng double precision,
  location_address text,
  customer_id uuid,
  customer_name text,
  customer_avatar text,
  created_at timestamptz,
  distance_miles numeric,
  quote_count bigint,
  has_quoted boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_verification_status text;
BEGIN
  SELECT mp.verification_status INTO v_verification_status
  FROM public.mechanic_profiles mp
  WHERE mp.id = p_mechanic_id;
  
  IF v_verification_status IS NULL OR v_verification_status != 'active' THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT
    j.id as job_id,
    j.title,
    j.description,
    j.status::text,
    j.preferred_time,
    v.year as vehicle_year,
    v.make as vehicle_make,
    v.model as vehicle_model,
    v.vin as vehicle_vin,
    j.location_lat,
    j.location_lng,
    j.location_address,
    j.customer_id,
    p.full_name as customer_name,
    p.avatar_url as customer_avatar,
    j.created_at,
    CASE
      WHEN p_mechanic_lat IS NOT NULL AND p_mechanic_lng IS NOT NULL
           AND j.location_lat IS NOT NULL AND j.location_lng IS NOT NULL
      THEN ROUND((
        3959 * acos(
          cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
          cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
          sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
        )
      )::numeric, 1)
      ELSE NULL
    END as distance_miles,
    (SELECT COUNT(*) FROM public.quotes q WHERE q.job_id = j.id) as quote_count,
    EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id) as has_quoted
  FROM public.jobs j
  JOIN public.profiles p ON p.id = j.customer_id
  LEFT JOIN public.vehicles v ON v.id = j.vehicle_id
  WHERE 
    -- All filters show jobs in searching or quoted status (cast to text for comparison)
    j.status::text IN ('searching', 'quoted')
    -- For 'quoted' filter, additionally require mechanic has quoted
    AND (
      p_filter IS NULL
      OR p_filter = 'all'
      OR p_filter = 'nearby'
      OR (p_filter = 'quoted' AND EXISTS(SELECT 1 FROM public.quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id))
    )
    AND (p_radius_miles IS NULL OR p_mechanic_lat IS NULL OR p_mechanic_lng IS NULL OR
         j.location_lat IS NULL OR j.location_lng IS NULL OR
         (3959 * acos(
           cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
           cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
           sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
         )) <= p_radius_miles)
  ORDER BY
    CASE WHEN p_sort_by = 'newest' THEN j.created_at END DESC,
    CASE WHEN p_sort_by = 'closest' AND p_mechanic_lat IS NOT NULL THEN
      3959 * acos(
        cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
        cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
        sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
      )
    END ASC NULLS LAST,
    j.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads(uuid, text, double precision, double precision, double precision, integer, integer, text) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260117000003_fix_mechanic_leads_cast.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260117000004_fix_leads_summary.sql
-- ===================================================================\n
-- Fix get_mechanic_leads_summary to match leads function - only count quotable jobs
BEGIN;

DROP FUNCTION IF EXISTS public.get_mechanic_leads_summary(uuid, numeric, numeric, numeric);
DROP FUNCTION IF EXISTS public.get_mechanic_leads_summary(uuid, double precision, double precision, double precision);

CREATE OR REPLACE FUNCTION public.get_mechanic_leads_summary(
  p_mechanic_id uuid,
  p_mechanic_lat double precision DEFAULT NULL,
  p_mechanic_lng double precision DEFAULT NULL,
  p_radius_miles double precision DEFAULT 25
)
RETURNS TABLE (
  all_count bigint,
  nearby_count bigint,
  quoted_count bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    -- all_count: jobs within mechanic's service radius (searching or quoted status only)
    (SELECT COUNT(*) FROM jobs j
     INNER JOIN profiles p ON p.id = j.customer_id
     WHERE j.deleted_at IS NULL AND p.deleted_at IS NULL
     AND j.status::text IN ('searching', 'quoted')
     AND (
       p_mechanic_lat IS NULL OR p_mechanic_lng IS NULL
       OR j.location_lat IS NULL OR j.location_lng IS NULL
       OR (3959 * acos(
         cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
         cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
         sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
       )) <= p_radius_miles
     )
    ) AS all_count,
    -- nearby_count: jobs within 5 miles (searching or quoted status only)
    (SELECT COUNT(*) FROM jobs j
     INNER JOIN profiles p ON p.id = j.customer_id
     WHERE j.deleted_at IS NULL AND p.deleted_at IS NULL
     AND j.status::text IN ('searching', 'quoted')
     AND (
       p_mechanic_lat IS NULL OR p_mechanic_lng IS NULL
       OR j.location_lat IS NULL OR j.location_lng IS NULL
       OR (3959 * acos(
         cos(radians(p_mechanic_lat)) * cos(radians(j.location_lat)) *
         cos(radians(j.location_lng) - radians(p_mechanic_lng)) +
         sin(radians(p_mechanic_lat)) * sin(radians(j.location_lat))
       )) <= 5
     )
    ) AS nearby_count,
    -- quoted_count: jobs mechanic has quoted on (that are still in searching/quoted status)
    (SELECT COUNT(*) FROM jobs j
     INNER JOIN profiles p ON p.id = j.customer_id
     WHERE j.deleted_at IS NULL AND p.deleted_at IS NULL
     AND j.status::text IN ('searching', 'quoted')
     AND EXISTS(SELECT 1 FROM quotes q WHERE q.job_id = j.id AND q.mechanic_id = p_mechanic_id)
    ) AS quoted_count;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_mechanic_leads_summary(uuid, double precision, double precision, double precision) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260117000004_fix_leads_summary.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260118000001_dispute_notify_mechanic.sql
-- ===================================================================\n
-- Add notification to mechanic when customer files a dispute
-- Updates customer_file_comeback to notify the mechanic

CREATE OR REPLACE FUNCTION public.customer_file_comeback(
  p_job_id uuid,
  p_description text,
  p_desired_resolution text DEFAULT NULL,
  p_evidence_urls text[] DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_customer_id uuid := auth.uid();
  v_can_file jsonb;
  v_job record;
  v_policy jsonb;
  v_response_sla_hours int;
  v_evidence_deadline_hours int;
  v_dispute_id uuid;
  v_customer_name text;
BEGIN
  -- Check if can file
  v_can_file := can_file_comeback(p_job_id);

  IF NOT (v_can_file->>'can_file')::boolean THEN
    RETURN jsonb_build_object('success', false, 'error', v_can_file->>'reason');
  END IF;

  -- Get job details
  SELECT j.*, jc.id as contract_id
  INTO v_job
  FROM public.jobs j
  LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
  WHERE j.id = p_job_id;

  -- Get customer name for notification
  SELECT COALESCE(full_name, 'Customer') INTO v_customer_name
  FROM public.profiles WHERE id = v_customer_id;

  -- Get policy for SLA
  v_policy := get_effective_mechanic_policy(NULL);
  v_response_sla_hours := COALESCE((v_policy->>'disputes.mechanic_response_sla_hours')::int, 12);
  v_evidence_deadline_hours := COALESCE((v_policy->>'disputes.evidence_deadline_hours')::int, 48);

  -- Create dispute
  INSERT INTO public.disputes (
    job_id,
    contract_id,
    filed_by,
    filed_by_role,
    filed_against,
    status,
    category,
    description,
    desired_resolution,
    evidence_urls,
    priority,
    response_deadline,
    evidence_deadline
  ) VALUES (
    p_job_id,
    v_job.contract_id,
    v_customer_id,
    'customer',
    v_job.accepted_mechanic_id,
    'open',
    'comeback',
    p_description,
    p_desired_resolution,
    p_evidence_urls,
    'normal',
    now() + (v_response_sla_hours || ' hours')::interval,
    now() + (v_evidence_deadline_hours || ' hours')::interval
  )
  RETURNING id INTO v_dispute_id;

  -- Log job event
  INSERT INTO public.job_events (
    job_id,
    contract_id,
    event_type,
    actor_id,
    actor_role,
    title,
    description,
    metadata
  ) VALUES (
    p_job_id,
    v_job.contract_id,
    'comeback_reported',
    v_customer_id,
    'customer',
    'Issue reported',
    'Customer reported: ' || LEFT(p_description, 100),
    jsonb_build_object('dispute_id', v_dispute_id, 'category', 'comeback')
  );

  -- Update chat lifecycle to mark dispute
  UPDATE public.chat_lifecycle_config
  SET has_dispute = true, updated_at = now()
  WHERE job_id = p_job_id;

  -- Notify the mechanic about the dispute
  PERFORM notify_user(
    v_job.accepted_mechanic_id,
    'Customer Reported an Issue',
    v_customer_name || ' has reported an issue with a completed job. Please respond within ' || v_response_sla_hours || ' hours.',
    'dispute',
    'dispute',
    v_dispute_id
  );

  RETURN jsonb_build_object(
    'success', true,
    'dispute_id', v_dispute_id,
    'response_deadline', now() + (v_response_sla_hours || ' hours')::interval
  );
END;
$$;
\n-- ===================================================================
-- END: 20260118000001_dispute_notify_mechanic.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260118000002_dispute_notify_customer_on_response.sql
-- ===================================================================\n
-- Add notification to customer when mechanic responds to dispute

CREATE OR REPLACE FUNCTION public.mechanic_respond_to_dispute(
  p_dispute_id uuid,
  p_response text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic_id uuid := auth.uid();
  v_dispute record;
  v_mechanic_name text;
BEGIN
  -- Get dispute
  SELECT * INTO v_dispute
  FROM public.disputes
  WHERE id = p_dispute_id;

  IF v_dispute IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Dispute not found');
  END IF;

  IF v_dispute.filed_against != v_mechanic_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;

  IF v_dispute.mechanic_response IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Already responded');
  END IF;

  IF v_dispute.status NOT IN ('open', 'under_review', 'evidence_requested') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Dispute is closed');
  END IF;

  -- Get mechanic name for notification
  SELECT COALESCE(full_name, 'The mechanic') INTO v_mechanic_name
  FROM public.profiles WHERE id = v_mechanic_id;

  -- Check if past SLA
  UPDATE public.disputes
  SET 
    mechanic_response = p_response,
    mechanic_responded_at = now(),
    sla_breached = CASE WHEN now() > response_deadline THEN true ELSE false END,
    status = 'under_review',
    updated_at = now()
  WHERE id = p_dispute_id;

  -- Log job event
  INSERT INTO public.job_events (
    job_id,
    contract_id,
    event_type,
    actor_id,
    actor_role,
    title,
    description,
    metadata
  ) VALUES (
    v_dispute.job_id,
    v_dispute.contract_id,
    'mechanic_responded',
    v_mechanic_id,
    'mechanic',
    'Mechanic responded to dispute',
    LEFT(p_response, 100),
    jsonb_build_object('dispute_id', p_dispute_id, 'sla_breached', now() > v_dispute.response_deadline)
  );

  -- Notify the customer about the mechanic's response
  PERFORM notify_user(
    v_dispute.filed_by,
    'Mechanic Responded to Your Issue',
    v_mechanic_name || ' has responded to your reported issue. Our team will review and follow up.',
    'dispute',
    'dispute',
    p_dispute_id
  );

  RETURN jsonb_build_object(
    'success', true,
    'sla_breached', now() > v_dispute.response_deadline
  );
END;
$$;
\n-- ===================================================================
-- END: 20260118000002_dispute_notify_customer_on_response.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260118000003_add_admin_role_enum.sql
-- ===================================================================\n
-- Add 'admin' to user_role enum
ALTER TYPE public.user_role ADD VALUE IF NOT EXISTS 'admin';
\n-- ===================================================================
-- END: 20260118000003_add_admin_role_enum.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260119000001_fix_profile_card_job_count.sql
-- ===================================================================\n
-- Fix profile card job count - was hardcoded to 0

CREATE OR REPLACE FUNCTION public.get_public_profile_card(p_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  result jsonb;
  profile_ratings jsonb;
  profile_badges jsonb;
  profile_skills jsonb;
  profile_trust_score jsonb;
  v_role text;
  v_profile_id uuid;
  v_total_jobs bigint := 0;
  v_completed_jobs bigint := 0;
BEGIN
  -- Get user role and profile id
  SELECT p.role, p.id INTO v_role, v_profile_id
  FROM profiles p
  WHERE p.id = p_user_id
    AND p.deleted_at IS NULL;

  IF v_profile_id IS NULL THEN
    RETURN NULL;
  END IF;

  -- Count jobs based on role
  IF v_role = 'customer' THEN
    SELECT 
      COALESCE(COUNT(*), 0),
      COALESCE(COUNT(*) FILTER (WHERE j.status = 'completed'), 0)
    INTO v_total_jobs, v_completed_jobs
    FROM jobs j
    WHERE j.customer_id = v_profile_id;
  ELSE
    SELECT 
      COALESCE(COUNT(*), 0),
      COALESCE(COUNT(*) FILTER (WHERE j.status = 'completed'), 0)
    INTO v_total_jobs, v_completed_jobs
    FROM jobs j
    WHERE j.accepted_mechanic_id = v_profile_id;
  END IF;

  -- Get ratings data
  SELECT jsonb_build_object(
    'overall_avg', COALESCE(AVG(r.overall_rating), 0),
    'performance_avg', COALESCE(AVG(r.performance_rating), 0),
    'timing_avg', COALESCE(AVG(r.timing_rating), 0),
    'cost_avg', COALESCE(AVG(r.cost_rating), 0),
    'professionalism_avg', COALESCE(AVG(r.professionalism_rating), 0),
    'communication_avg', COALESCE(AVG(r.communication_rating), 0),
    'punctuality_avg', COALESCE(AVG(r.punctuality_rating), 0),
    'payment_avg', COALESCE(AVG(r.payment_rating), 0),
    'review_count', COALESCE(COUNT(r.id), 0)::integer,
    'would_recommend_count', COALESCE(COUNT(r.id) FILTER (WHERE r.would_recommend = true), 0)::integer,
    'would_recommend_total', COALESCE(COUNT(r.id) FILTER (WHERE r.would_recommend IS NOT NULL), 0)::integer
  )
  INTO profile_ratings
  FROM reviews r
  WHERE r.reviewee_id = p_user_id;

  -- Get badges data
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ub.id,
      'badge_id', ub.badge_id,
      'awarded_at', ub.created_at,
      'badge', jsonb_build_object(
        'code', b.code,
        'title', b.title,
        'description', COALESCE(b.description, ''),
        'icon', COALESCE(b.icon, ''),
        'category', COALESCE(b.badge_type, 'earned'),
        'tier', 1
      )
    )
  ), '[]'::jsonb)
  INTO profile_badges
  FROM user_badges ub
  INNER JOIN badges b ON b.id = ub.badge_id
  WHERE ub.user_id = p_user_id;

  -- Get skills data (for mechanics only)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ms.id,
      'is_verified', COALESCE(ms.is_verified, false),
      'verified_job_count', 0,
      'avg_job_rating', null,
      'skill', jsonb_build_object(
        'key', s.key,
        'label', s.label,
        'name', s.label,
        'category', COALESCE(s.category, 'general')
      )
    )
  ), '[]'::jsonb)
  INTO profile_skills
  FROM mechanic_skills ms
  INNER JOIN skills s ON s.key = ms.skill_key
  WHERE ms.mechanic_id = p_user_id;

  -- Build trust score with actual job counts
  profile_trust_score := jsonb_build_object(
    'overall_score', 50,
    'rating_score', CASE WHEN COALESCE((profile_ratings->>'review_count')::int, 0) > 0 
      THEN LEAST(100, COALESCE((profile_ratings->>'overall_avg')::numeric, 0) * 20) 
      ELSE 50 END,
    'completion_score', CASE WHEN v_total_jobs > 0 
      THEN LEAST(100, (v_completed_jobs::numeric / v_total_jobs::numeric) * 100)
      ELSE 50 END,
    'reliability_score', 50,
    'badge_score', LEAST(100, COALESCE(jsonb_array_length(profile_badges), 0) * 20),
    'tenure_score', 50,
    'completed_jobs', COALESCE(v_completed_jobs, 0),
    'total_jobs', COALESCE(v_total_jobs, 0)
  );

  -- Build final result
  SELECT jsonb_build_object(
    'id', p.id,
    'role', p.role,
    'display_name', COALESCE(p.full_name, 'Unknown User'),
    'avatar_url', p.avatar_url,
    'created_at', p.created_at,
    'ratings', COALESCE(profile_ratings, '{}'::jsonb),
    'badges', COALESCE(profile_badges, '[]'::jsonb),
    'skills', COALESCE(profile_skills, '[]'::jsonb),
    'trust_score', profile_trust_score
  )
  INTO result
  FROM profiles p
  WHERE p.id = p_user_id
    AND p.deleted_at IS NULL;

  RETURN result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO anon;
\n-- ===================================================================
-- END: 20260119000001_fix_profile_card_job_count.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260120000001_phase4_admin_audit_metrics.sql
-- ===================================================================\n
-- =====================================================
-- PHASE 4: Admin Console, Audit Logging, Metrics, Hub Health
-- =====================================================

-- =====================================================
-- A) AUDIT LOG TABLE (Immutable)
-- =====================================================

CREATE TABLE IF NOT EXISTS public.audit_log (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  actor_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
  actor_type text NOT NULL DEFAULT 'admin' CHECK (actor_type IN ('admin', 'system', 'user')),
  action text NOT NULL,
  entity_type text,
  entity_id uuid,
  metadata jsonb DEFAULT '{}',
  created_at timestamptz DEFAULT now() NOT NULL,
  is_immutable boolean DEFAULT true NOT NULL,
  supersedes uuid REFERENCES public.audit_log(id) ON DELETE SET NULL
);

CREATE INDEX idx_audit_log_actor ON public.audit_log(actor_id);
CREATE INDEX idx_audit_log_action ON public.audit_log(action);
CREATE INDEX idx_audit_log_entity ON public.audit_log(entity_type, entity_id);
CREATE INDEX idx_audit_log_created ON public.audit_log(created_at DESC);

COMMENT ON TABLE public.audit_log IS 'Immutable audit trail for admin and system actions';

-- RLS: Admins can select only; no direct inserts/updates/deletes
ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;

CREATE POLICY audit_log_admin_select ON public.audit_log
  FOR SELECT TO authenticated
  USING (public.is_admin());

-- No INSERT/UPDATE/DELETE policies - only via SECURITY DEFINER RPC

-- =====================================================
-- B) AUDIT LOG INSERT RPC (SECURITY DEFINER)
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_audit_log(
  p_action text,
  p_entity_type text DEFAULT NULL,
  p_entity_id uuid DEFAULT NULL,
  p_metadata jsonb DEFAULT '{}'
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_id uuid;
  v_actor_type text;
BEGIN
  -- Determine actor type
  IF public.is_admin() THEN
    v_actor_type := 'admin';
  ELSE
    v_actor_type := 'system';
  END IF;

  INSERT INTO public.audit_log (actor_id, actor_type, action, entity_type, entity_id, metadata)
  VALUES (auth.uid(), v_actor_type, p_action, p_entity_type, p_entity_id, p_metadata)
  RETURNING id INTO v_id;

  RETURN v_id;
END;
$$;

-- System audit log (for triggers/background jobs)
CREATE OR REPLACE FUNCTION public.system_audit_log(
  p_action text,
  p_entity_type text DEFAULT NULL,
  p_entity_id uuid DEFAULT NULL,
  p_metadata jsonb DEFAULT '{}'
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_id uuid;
BEGIN
  INSERT INTO public.audit_log (actor_id, actor_type, action, entity_type, entity_id, metadata)
  VALUES (NULL, 'system', p_action, p_entity_type, p_entity_id, p_metadata)
  RETURNING id INTO v_id;

  RETURN v_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_audit_log(text, text, uuid, jsonb) TO authenticated;
GRANT EXECUTE ON FUNCTION public.system_audit_log(text, text, uuid, jsonb) TO service_role;

-- =====================================================
-- C) UPDATE EXISTING ADMIN RPCs TO WRITE AUDIT LOG
-- =====================================================

-- C.1) Update admin_resolve_dispute to write audit_log
CREATE OR REPLACE FUNCTION public.admin_resolve_dispute(
  p_dispute_id uuid,
  p_status text,
  p_resolution_type text DEFAULT NULL,
  p_resolution_notes text DEFAULT NULL,
  p_customer_refund_cents int DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_dispute disputes;
  v_job_id uuid;
  v_contract_id uuid;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT * INTO v_dispute FROM public.disputes WHERE id = p_dispute_id;
  IF v_dispute IS NULL THEN
    RETURN jsonb_build_object('error', 'Dispute not found');
  END IF;

  v_job_id := v_dispute.job_id;
  v_contract_id := v_dispute.contract_id;

  UPDATE public.disputes
  SET 
    status = p_status::dispute_status,
    resolution_type = COALESCE(p_resolution_type, resolution_type),
    resolution_notes = COALESCE(p_resolution_notes, resolution_notes),
    customer_refund_cents = COALESCE(p_customer_refund_cents, customer_refund_cents),
    resolved_at = CASE WHEN p_status IN ('resolved_customer', 'resolved_mechanic', 'resolved_split', 'dismissed') THEN now() ELSE resolved_at END,
    resolved_by = auth.uid(),
    updated_at = now()
  WHERE id = p_dispute_id;

  -- Log job event
  INSERT INTO public.job_events (job_id, contract_id, event_type, actor_id, actor_role, metadata)
  VALUES (
    v_job_id,
    v_contract_id,
    'dispute_resolved'::job_event_type,
    auth.uid(),
    'admin'::user_role,
    jsonb_build_object(
      'dispute_id', p_dispute_id,
      'resolution_status', p_status,
      'resolution_type', p_resolution_type,
      'refund_cents', p_customer_refund_cents
    )
  );

  -- Write to audit_log
  PERFORM public.admin_audit_log(
    'ADMIN_RESOLVE_DISPUTE',
    'disputes',
    p_dispute_id,
    jsonb_build_object(
      'old_status', v_dispute.status,
      'new_status', p_status,
      'resolution_type', p_resolution_type,
      'resolution_notes', p_resolution_notes,
      'refund_cents', p_customer_refund_cents,
      'job_id', v_job_id
    )
  );

  RETURN jsonb_build_object('success', true, 'dispute_id', p_dispute_id);
END;
$$;

-- C.2) Update set_mechanic_verification_status to write audit_log
CREATE OR REPLACE FUNCTION public.set_mechanic_verification_status(
  p_mechanic_id uuid,
  p_status text,
  p_rejection_reason text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_old_status text;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT verification_status INTO v_old_status
  FROM public.mechanic_profiles
  WHERE id = p_mechanic_id;

  IF v_old_status IS NULL THEN
    RETURN jsonb_build_object('error', 'Mechanic not found');
  END IF;

  UPDATE public.mechanic_profiles
  SET 
    verification_status = p_status,
    rejection_reason = CASE WHEN p_status = 'rejected' THEN p_rejection_reason ELSE NULL END,
    verified_at = CASE WHEN p_status = 'approved' THEN now() ELSE verified_at END,
    updated_at = now()
  WHERE id = p_mechanic_id;

  -- Write to audit_log
  PERFORM public.admin_audit_log(
    'ADMIN_SET_VERIFICATION_STATUS',
    'mechanic_profiles',
    p_mechanic_id,
    jsonb_build_object(
      'old_status', v_old_status,
      'new_status', p_status,
      'rejection_reason', p_rejection_reason
    )
  );

  -- Notify mechanic
  PERFORM public.notify_user(
    p_mechanic_id,
    CASE 
      WHEN p_status = 'approved' THEN 'verification_approved'
      WHEN p_status = 'rejected' THEN 'verification_rejected'
      ELSE 'verification_update'
    END,
    jsonb_build_object('status', p_status, 'reason', p_rejection_reason)
  );

  RETURN jsonb_build_object('success', true, 'mechanic_id', p_mechanic_id);
END;
$$;

-- C.3) Update set_mechanic_tier to write audit_log
CREATE OR REPLACE FUNCTION public.set_mechanic_tier(
  p_mechanic_id uuid,
  p_tier text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_old_tier text;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT tier INTO v_old_tier
  FROM public.mechanic_profiles
  WHERE id = p_mechanic_id;

  IF v_old_tier IS NULL THEN
    RETURN jsonb_build_object('error', 'Mechanic not found');
  END IF;

  UPDATE public.mechanic_profiles
  SET tier = p_tier, updated_at = now()
  WHERE id = p_mechanic_id;

  -- Write to audit_log
  PERFORM public.admin_audit_log(
    'ADMIN_SET_MECHANIC_TIER',
    'mechanic_profiles',
    p_mechanic_id,
    jsonb_build_object('old_tier', v_old_tier, 'new_tier', p_tier)
  );

  RETURN jsonb_build_object('success', true, 'mechanic_id', p_mechanic_id);
END;
$$;

-- C.4) Update add_mechanic_strike to write audit_log
CREATE OR REPLACE FUNCTION public.add_mechanic_strike(
  p_mechanic_id uuid,
  p_reason text,
  p_details jsonb DEFAULT '{}'
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_old_strikes int;
  v_new_strikes int;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT COALESCE(strikes, 0) INTO v_old_strikes
  FROM public.mechanic_profiles
  WHERE id = p_mechanic_id;

  IF v_old_strikes IS NULL THEN
    RETURN jsonb_build_object('error', 'Mechanic not found');
  END IF;

  v_new_strikes := v_old_strikes + 1;

  UPDATE public.mechanic_profiles
  SET 
    strikes = v_new_strikes,
    updated_at = now()
  WHERE id = p_mechanic_id;

  -- Write to audit_log
  PERFORM public.admin_audit_log(
    'ADMIN_ADD_STRIKE',
    'mechanic_profiles',
    p_mechanic_id,
    jsonb_build_object(
      'old_strikes', v_old_strikes,
      'new_strikes', v_new_strikes,
      'reason', p_reason,
      'details', p_details
    )
  );

  -- Notify mechanic
  PERFORM public.notify_user(
    p_mechanic_id,
    'strike_added',
    jsonb_build_object('total_strikes', v_new_strikes, 'reason', p_reason)
  );

  RETURN jsonb_build_object('success', true, 'new_strikes', v_new_strikes);
END;
$$;

GRANT EXECUTE ON FUNCTION public.set_mechanic_verification_status(uuid, text, text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.set_mechanic_tier(uuid, text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.add_mechanic_strike(uuid, text, jsonb) TO authenticated;

-- =====================================================
-- D) ADMIN METRICS RPC
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_metrics(
  p_hub_id uuid DEFAULT NULL,
  p_days int DEFAULT 14
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_start_date date;
  v_result jsonb;
  v_daily_jobs jsonb;
  v_daily_completed jsonb;
  v_quotes_per_job numeric;
  v_acceptance_rate numeric;
  v_completion_rate numeric;
  v_dispute_rate numeric;
  v_refund_rate numeric;
  v_tickets_per_job numeric;
  v_total_jobs bigint;
  v_total_completed bigint;
  v_total_quotes bigint;
  v_total_accepted bigint;
  v_total_disputes bigint;
  v_total_refunds bigint;
  v_total_tickets bigint;
  v_decline_reasons jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  v_start_date := CURRENT_DATE - p_days;

  -- Daily jobs created
  SELECT jsonb_agg(jsonb_build_object('date', d.day, 'count', COALESCE(j.cnt, 0)) ORDER BY d.day)
  INTO v_daily_jobs
  FROM generate_series(v_start_date, CURRENT_DATE, '1 day'::interval) d(day)
  LEFT JOIN (
    SELECT DATE(created_at) as day, COUNT(*) as cnt
    FROM public.jobs
    WHERE created_at >= v_start_date
      AND (p_hub_id IS NULL OR hub_id = p_hub_id)
    GROUP BY DATE(created_at)
  ) j ON d.day = j.day;

  -- Daily jobs completed
  SELECT jsonb_agg(jsonb_build_object('date', d.day, 'count', COALESCE(j.cnt, 0)) ORDER BY d.day)
  INTO v_daily_completed
  FROM generate_series(v_start_date, CURRENT_DATE, '1 day'::interval) d(day)
  LEFT JOIN (
    SELECT DATE(completed_at) as day, COUNT(*) as cnt
    FROM public.jobs
    WHERE completed_at >= v_start_date
      AND status = 'completed'
      AND (p_hub_id IS NULL OR hub_id = p_hub_id)
    GROUP BY DATE(completed_at)
  ) j ON d.day = j.day;

  -- Totals for ratios
  SELECT COUNT(*) INTO v_total_jobs
  FROM public.jobs
  WHERE created_at >= v_start_date
    AND (p_hub_id IS NULL OR hub_id = p_hub_id);

  SELECT COUNT(*) INTO v_total_completed
  FROM public.jobs
  WHERE completed_at >= v_start_date
    AND status = 'completed'
    AND (p_hub_id IS NULL OR hub_id = p_hub_id);

  SELECT COUNT(*) INTO v_total_quotes
  FROM public.quotes q
  JOIN public.jobs j ON j.id = q.job_id
  WHERE q.created_at >= v_start_date
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id);

  SELECT COUNT(*) INTO v_total_accepted
  FROM public.job_contracts jc
  JOIN public.jobs j ON j.id = jc.job_id
  WHERE jc.created_at >= v_start_date
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id);

  SELECT COUNT(*) INTO v_total_disputes
  FROM public.disputes d
  JOIN public.jobs j ON j.id = d.job_id
  WHERE d.created_at >= v_start_date
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id);

  -- Refunds (disputes resolved with refund or payments with refunded_at)
  SELECT COUNT(*) INTO v_total_refunds
  FROM public.disputes d
  JOIN public.jobs j ON j.id = d.job_id
  WHERE d.created_at >= v_start_date
    AND d.customer_refund_cents > 0
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id);

  SELECT COUNT(*) INTO v_total_tickets
  FROM public.support_requests sr
  JOIN public.jobs j ON j.id = sr.job_id
  WHERE sr.created_at >= v_start_date
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id);

  -- Calculate rates
  v_quotes_per_job := CASE WHEN v_total_jobs > 0 THEN ROUND(v_total_quotes::numeric / v_total_jobs, 2) ELSE 0 END;
  v_acceptance_rate := CASE WHEN v_total_quotes > 0 THEN ROUND(v_total_accepted::numeric / v_total_quotes * 100, 1) ELSE 0 END;
  v_completion_rate := CASE WHEN v_total_jobs > 0 THEN ROUND(v_total_completed::numeric / v_total_jobs * 100, 1) ELSE 0 END;
  v_dispute_rate := CASE WHEN v_total_completed > 0 THEN ROUND(v_total_disputes::numeric / v_total_completed * 100, 1) ELSE 0 END;
  v_refund_rate := CASE WHEN v_total_completed > 0 THEN ROUND(v_total_refunds::numeric / v_total_completed * 100, 1) ELSE 0 END;
  v_tickets_per_job := CASE WHEN v_total_jobs > 0 THEN ROUND(v_total_tickets::numeric / v_total_jobs, 2) ELSE 0 END;

  -- Top decline reasons (from lead_decisions if exists)
  BEGIN
    SELECT jsonb_agg(jsonb_build_object('reason', reason, 'count', cnt) ORDER BY cnt DESC)
    INTO v_decline_reasons
    FROM (
      SELECT decision_reason as reason, COUNT(*) as cnt
      FROM public.lead_decisions ld
      JOIN public.jobs j ON j.id = ld.job_id
      WHERE ld.decision = 'decline'
        AND ld.created_at >= v_start_date
        AND (p_hub_id IS NULL OR j.hub_id = p_hub_id)
      GROUP BY decision_reason
      ORDER BY cnt DESC
      LIMIT 10
    ) sub;
  EXCEPTION WHEN undefined_table THEN
    v_decline_reasons := '[]'::jsonb;
  END;

  v_result := jsonb_build_object(
    'period_days', p_days,
    'hub_id', p_hub_id,
    'daily_jobs_created', COALESCE(v_daily_jobs, '[]'::jsonb),
    'daily_jobs_completed', COALESCE(v_daily_completed, '[]'::jsonb),
    'totals', jsonb_build_object(
      'jobs_created', v_total_jobs,
      'jobs_completed', v_total_completed,
      'quotes', v_total_quotes,
      'accepted', v_total_accepted,
      'disputes', v_total_disputes,
      'refunds', v_total_refunds,
      'support_tickets', v_total_tickets
    ),
    'rates', jsonb_build_object(
      'quotes_per_job', v_quotes_per_job,
      'acceptance_rate', v_acceptance_rate,
      'completion_rate', v_completion_rate,
      'dispute_rate', v_dispute_rate,
      'refund_rate', v_refund_rate,
      'tickets_per_job', v_tickets_per_job
    ),
    'decline_reasons', COALESCE(v_decline_reasons, '[]'::jsonb)
  );

  RETURN v_result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_metrics(uuid, int) TO authenticated;

-- =====================================================
-- E) HUB HEALTH RPC
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_hub_health(
  p_hub_id uuid,
  p_days int DEFAULT 14
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_start_date date;
  v_hub service_hubs;
  v_jobs_requested bigint;
  v_jobs_completed bigint;
  v_completion_rate numeric;
  v_active_mechanics bigint;
  v_disputes bigint;
  v_support_tickets bigint;
  v_avg_response_minutes numeric;
  v_health_score int;
  v_can_expand boolean;
  v_avg_jobs_per_day numeric;
  v_disputes_per_40 numeric;
  v_tickets_per_job numeric;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT * INTO v_hub FROM public.service_hubs WHERE id = p_hub_id;
  IF v_hub IS NULL THEN
    RETURN jsonb_build_object('error', 'Hub not found');
  END IF;

  v_start_date := CURRENT_DATE - p_days;

  -- Jobs requested
  SELECT COUNT(*) INTO v_jobs_requested
  FROM public.jobs
  WHERE hub_id = p_hub_id AND created_at >= v_start_date;

  -- Jobs completed
  SELECT COUNT(*) INTO v_jobs_completed
  FROM public.jobs
  WHERE hub_id = p_hub_id AND status = 'completed' AND completed_at >= v_start_date;

  -- Completion rate
  v_completion_rate := CASE WHEN v_jobs_requested > 0 
    THEN ROUND(v_jobs_completed::numeric / v_jobs_requested * 100, 1) 
    ELSE 0 END;

  -- Active mechanics (at least 1 completed job in period)
  SELECT COUNT(DISTINCT jc.mechanic_id) INTO v_active_mechanics
  FROM public.job_contracts jc
  JOIN public.jobs j ON j.id = jc.job_id
  WHERE j.hub_id = p_hub_id 
    AND j.status = 'completed' 
    AND j.completed_at >= v_start_date;

  -- Disputes
  SELECT COUNT(*) INTO v_disputes
  FROM public.disputes d
  JOIN public.jobs j ON j.id = d.job_id
  WHERE j.hub_id = p_hub_id AND d.created_at >= v_start_date;

  -- Support tickets
  SELECT COUNT(*) INTO v_support_tickets
  FROM public.support_requests sr
  JOIN public.jobs j ON j.id = sr.job_id
  WHERE j.hub_id = p_hub_id AND sr.created_at >= v_start_date;

  -- Average response time (first quote after job created)
  SELECT ROUND(AVG(EXTRACT(EPOCH FROM (q.created_at - j.created_at)) / 60), 1)
  INTO v_avg_response_minutes
  FROM public.jobs j
  JOIN LATERAL (
    SELECT created_at FROM public.quotes WHERE job_id = j.id ORDER BY created_at LIMIT 1
  ) q ON true
  WHERE j.hub_id = p_hub_id AND j.created_at >= v_start_date;

  -- Calculate health score (0-100)
  v_avg_jobs_per_day := v_jobs_completed::numeric / GREATEST(p_days, 1);
  v_disputes_per_40 := CASE WHEN v_jobs_completed >= 40 
    THEN v_disputes::numeric / (v_jobs_completed / 40.0) 
    ELSE v_disputes END;
  v_tickets_per_job := CASE WHEN v_jobs_requested > 0 
    THEN v_support_tickets::numeric / v_jobs_requested 
    ELSE 0 END;

  -- Health score formula:
  -- Base 50 + completion_rate_bonus (up to 25) + response_time_bonus (up to 15) + low_disputes_bonus (up to 10)
  v_health_score := 50;
  
  -- Completion rate bonus
  IF v_completion_rate >= 95 THEN v_health_score := v_health_score + 25;
  ELSIF v_completion_rate >= 90 THEN v_health_score := v_health_score + 20;
  ELSIF v_completion_rate >= 80 THEN v_health_score := v_health_score + 15;
  ELSIF v_completion_rate >= 70 THEN v_health_score := v_health_score + 10;
  END IF;

  -- Response time bonus (if under 10 min avg)
  IF v_avg_response_minutes IS NOT NULL THEN
    IF v_avg_response_minutes <= 5 THEN v_health_score := v_health_score + 15;
    ELSIF v_avg_response_minutes <= 10 THEN v_health_score := v_health_score + 10;
    ELSIF v_avg_response_minutes <= 20 THEN v_health_score := v_health_score + 5;
    END IF;
  END IF;

  -- Low disputes bonus
  IF v_disputes_per_40 <= 1 THEN v_health_score := v_health_score + 10;
  ELSIF v_disputes_per_40 <= 2 THEN v_health_score := v_health_score + 5;
  END IF;

  v_health_score := LEAST(v_health_score, 100);

  -- Can expand criteria:
  -- - avg 8+ completed jobs/day
  -- - completion_rate >= 95%
  -- - avg response <= 10 min (if measured)
  -- - disputes <= 1 per 40 completed
  -- - tickets_per_job <= 0.15
  v_can_expand := (
    v_avg_jobs_per_day >= 8 AND
    v_completion_rate >= 95 AND
    (v_avg_response_minutes IS NULL OR v_avg_response_minutes <= 10) AND
    v_disputes_per_40 <= 1 AND
    v_tickets_per_job <= 0.15
  );

  RETURN jsonb_build_object(
    'hub_id', p_hub_id,
    'hub_name', v_hub.name,
    'period_days', p_days,
    'jobs_requested', v_jobs_requested,
    'jobs_completed', v_jobs_completed,
    'completion_rate', v_completion_rate,
    'active_mechanics', v_active_mechanics,
    'disputes', v_disputes,
    'support_tickets', v_support_tickets,
    'avg_response_minutes', v_avg_response_minutes,
    'avg_jobs_per_day', ROUND(v_avg_jobs_per_day, 1),
    'disputes_per_40_completed', ROUND(v_disputes_per_40, 2),
    'tickets_per_job', ROUND(v_tickets_per_job, 2),
    'health_score', v_health_score,
    'can_expand', v_can_expand,
    'hub_config', jsonb_build_object(
      'active_radius_miles', v_hub.active_radius_miles,
      'invite_only', v_hub.invite_only,
      'auto_expand_enabled', v_hub.auto_expand_enabled
    )
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_hub_health(uuid, int) TO authenticated;

-- =====================================================
-- F) ADMIN GET ALL HUBS
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_hubs()
RETURNS TABLE (
  id uuid,
  name text,
  city text,
  state text,
  latitude numeric,
  longitude numeric,
  active_radius_miles int,
  max_radius_miles int,
  invite_only boolean,
  auto_expand_enabled boolean,
  created_at timestamptz,
  active_mechanics bigint,
  jobs_last_14d bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    h.id,
    h.name,
    h.city,
    h.state,
    h.latitude,
    h.longitude,
    h.active_radius_miles,
    h.max_radius_miles,
    h.invite_only,
    h.auto_expand_enabled,
    h.created_at,
    (SELECT COUNT(DISTINCT mp.id) 
     FROM public.mechanic_profiles mp 
     WHERE mp.hub_id = h.id AND mp.verification_status = 'approved') as active_mechanics,
    (SELECT COUNT(*) 
     FROM public.jobs j 
     WHERE j.hub_id = h.id AND j.created_at >= CURRENT_DATE - 14) as jobs_last_14d
  FROM public.service_hubs h
  ORDER BY h.name;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_hubs() TO authenticated;

-- =====================================================
-- G) WAITLIST HEATMAP RPC
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_waitlist_heatmap(
  p_hub_id uuid DEFAULT NULL,
  p_days int DEFAULT 30
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_start_date timestamptz;
  v_by_zip jsonb;
  v_by_hub jsonb;
  v_by_user_type jsonb;
  v_total bigint;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  v_start_date := now() - (p_days || ' days')::interval;

  -- Total count
  SELECT COUNT(*) INTO v_total
  FROM public.waitlist w
  WHERE w.created_at >= v_start_date
    AND (p_hub_id IS NULL OR w.nearest_hub_id = p_hub_id);

  -- By zip (top 20)
  SELECT jsonb_agg(sub ORDER BY sub.count DESC)
  INTO v_by_zip
  FROM (
    SELECT 
      w.zip_code as zip,
      COUNT(*) as count,
      w.nearest_hub_id as hub_id
    FROM public.waitlist w
    WHERE w.created_at >= v_start_date
      AND (p_hub_id IS NULL OR w.nearest_hub_id = p_hub_id)
    GROUP BY w.zip_code, w.nearest_hub_id
    ORDER BY COUNT(*) DESC
    LIMIT 20
  ) sub;

  -- By hub
  SELECT jsonb_agg(sub ORDER BY sub.count DESC)
  INTO v_by_hub
  FROM (
    SELECT 
      w.nearest_hub_id as hub_id,
      h.name as hub_name,
      COUNT(*) as count
    FROM public.waitlist w
    LEFT JOIN public.service_hubs h ON h.id = w.nearest_hub_id
    WHERE w.created_at >= v_start_date
      AND (p_hub_id IS NULL OR w.nearest_hub_id = p_hub_id)
    GROUP BY w.nearest_hub_id, h.name
    ORDER BY COUNT(*) DESC
  ) sub;

  -- By user type
  SELECT jsonb_agg(sub)
  INTO v_by_user_type
  FROM (
    SELECT 
      w.user_type,
      COUNT(*) as count
    FROM public.waitlist w
    WHERE w.created_at >= v_start_date
      AND (p_hub_id IS NULL OR w.nearest_hub_id = p_hub_id)
    GROUP BY w.user_type
  ) sub;

  RETURN jsonb_build_object(
    'period_days', p_days,
    'hub_id', p_hub_id,
    'total', v_total,
    'by_zip', COALESCE(v_by_zip, '[]'::jsonb),
    'by_hub', COALESCE(v_by_hub, '[]'::jsonb),
    'by_user_type', COALESCE(v_by_user_type, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_waitlist_heatmap(uuid, int) TO authenticated;

-- =====================================================
-- H) ADMIN GET JOBS LIST
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_jobs(
  p_status text DEFAULT NULL,
  p_hub_id uuid DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  title text,
  status text,
  customer_id uuid,
  customer_name text,
  mechanic_id uuid,
  mechanic_name text,
  hub_id uuid,
  hub_name text,
  created_at timestamptz,
  completed_at timestamptz,
  quote_count bigint,
  has_dispute boolean,
  has_support_ticket boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    j.id,
    j.title,
    j.status::text,
    j.customer_id,
    pc.full_name as customer_name,
    jc.mechanic_id,
    pm.full_name as mechanic_name,
    j.hub_id,
    h.name as hub_name,
    j.created_at,
    j.completed_at,
    (SELECT COUNT(*) FROM public.quotes q WHERE q.job_id = j.id) as quote_count,
    EXISTS(SELECT 1 FROM public.disputes d WHERE d.job_id = j.id) as has_dispute,
    EXISTS(SELECT 1 FROM public.support_requests sr WHERE sr.job_id = j.id) as has_support_ticket
  FROM public.jobs j
  JOIN public.profiles pc ON pc.id = j.customer_id
  LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
  LEFT JOIN public.profiles pm ON pm.id = jc.mechanic_id
  LEFT JOIN public.service_hubs h ON h.id = j.hub_id
  WHERE (p_status IS NULL OR j.status::text = p_status)
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id)
  ORDER BY j.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_jobs(text, uuid, int, int) TO authenticated;

-- =====================================================
-- I) ADMIN GET JOB DETAIL
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_job_detail(p_job_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_job jsonb;
  v_quotes jsonb;
  v_contract jsonb;
  v_events jsonb;
  v_disputes jsonb;
  v_support jsonb;
  v_payments jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  -- Job with customer info
  SELECT jsonb_build_object(
    'id', j.id,
    'title', j.title,
    'description', j.description,
    'status', j.status,
    'service_type', j.service_type,
    'urgency', j.urgency,
    'customer_id', j.customer_id,
    'customer_name', pc.full_name,
    'customer_email', pc.email,
    'hub_id', j.hub_id,
    'location_lat', j.location_lat,
    'location_lng', j.location_lng,
    'location_address', j.location_address,
    'vehicle_year', j.vehicle_year,
    'vehicle_make', j.vehicle_make,
    'vehicle_model', j.vehicle_model,
    'created_at', j.created_at,
    'scheduled_at', j.scheduled_at,
    'started_at', j.started_at,
    'completed_at', j.completed_at
  ) INTO v_job
  FROM public.jobs j
  JOIN public.profiles pc ON pc.id = j.customer_id
  WHERE j.id = p_job_id;

  IF v_job IS NULL THEN
    RETURN jsonb_build_object('error', 'Job not found');
  END IF;

  -- Quotes
  SELECT jsonb_agg(jsonb_build_object(
    'id', q.id,
    'mechanic_id', q.mechanic_id,
    'mechanic_name', pm.full_name,
    'status', q.status,
    'labor_cents', q.labor_cents,
    'parts_cents', q.parts_cents,
    'total_cents', q.total_cents,
    'eta_minutes', q.eta_minutes,
    'created_at', q.created_at
  ) ORDER BY q.created_at)
  INTO v_quotes
  FROM public.quotes q
  JOIN public.profiles pm ON pm.id = q.mechanic_id
  WHERE q.job_id = p_job_id;

  -- Contract
  SELECT jsonb_build_object(
    'id', jc.id,
    'mechanic_id', jc.mechanic_id,
    'mechanic_name', pm.full_name,
    'status', jc.status,
    'accepted_at', jc.accepted_at,
    'started_at', jc.started_at,
    'completed_at', jc.completed_at,
    'final_labor_cents', jc.final_labor_cents,
    'final_parts_cents', jc.final_parts_cents,
    'final_total_cents', jc.final_total_cents
  ) INTO v_contract
  FROM public.job_contracts jc
  JOIN public.profiles pm ON pm.id = jc.mechanic_id
  WHERE jc.job_id = p_job_id;

  -- Events (last 50)
  SELECT jsonb_agg(jsonb_build_object(
    'id', je.id,
    'event_type', je.event_type,
    'actor_id', je.actor_id,
    'actor_role', je.actor_role,
    'metadata', je.metadata,
    'created_at', je.created_at
  ) ORDER BY je.created_at DESC)
  INTO v_events
  FROM (
    SELECT * FROM public.job_events WHERE job_id = p_job_id ORDER BY created_at DESC LIMIT 50
  ) je;

  -- Disputes
  SELECT jsonb_agg(jsonb_build_object(
    'id', d.id,
    'status', d.status,
    'category', d.category,
    'priority', d.priority,
    'created_at', d.created_at,
    'resolved_at', d.resolved_at
  ) ORDER BY d.created_at DESC)
  INTO v_disputes
  FROM public.disputes d WHERE d.job_id = p_job_id;

  -- Support requests
  SELECT jsonb_agg(jsonb_build_object(
    'id', sr.id,
    'status', sr.status,
    'category', sr.category,
    'subject', sr.subject,
    'created_at', sr.created_at,
    'resolved_at', sr.resolved_at
  ) ORDER BY sr.created_at DESC)
  INTO v_support
  FROM public.support_requests sr WHERE sr.job_id = p_job_id;

  -- Payments
  SELECT jsonb_agg(jsonb_build_object(
    'id', p.id,
    'status', p.status,
    'amount_cents', p.amount_cents,
    'created_at', p.created_at,
    'paid_at', p.paid_at,
    'refunded_at', p.refunded_at
  ) ORDER BY p.created_at DESC)
  INTO v_payments
  FROM public.payments p WHERE p.job_id = p_job_id;

  RETURN jsonb_build_object(
    'job', v_job,
    'quotes', COALESCE(v_quotes, '[]'::jsonb),
    'contract', v_contract,
    'events', COALESCE(v_events, '[]'::jsonb),
    'disputes', COALESCE(v_disputes, '[]'::jsonb),
    'support_requests', COALESCE(v_support, '[]'::jsonb),
    'payments', COALESCE(v_payments, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_job_detail(uuid) TO authenticated;

-- =====================================================
-- J) ADMIN GET MECHANICS LIST
-- =====================================================

-- Drop existing function to allow return type change
DROP FUNCTION IF EXISTS public.admin_get_mechanics(text, uuid, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_mechanics(
  p_status text DEFAULT NULL,
  p_hub_id uuid DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  full_name text,
  email text,
  phone text,
  verification_status text,
  tier text,
  strikes int,
  hub_id uuid,
  hub_name text,
  rating_avg numeric,
  completed_jobs bigint,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    mp.id,
    p.full_name,
    p.email,
    p.phone,
    mp.verification_status,
    mp.tier,
    COALESCE(mp.strikes, 0) as strikes,
    mp.hub_id,
    h.name as hub_name,
    mp.rating_avg,
    (SELECT COUNT(*) FROM public.job_contracts jc 
     JOIN public.jobs j ON j.id = jc.job_id 
     WHERE jc.mechanic_id = mp.id AND j.status = 'completed') as completed_jobs,
    mp.created_at
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON p.id = mp.id
  LEFT JOIN public.service_hubs h ON h.id = mp.hub_id
  WHERE (p_status IS NULL OR mp.verification_status = p_status)
    AND (p_hub_id IS NULL OR mp.hub_id = p_hub_id)
  ORDER BY mp.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_mechanics(text, uuid, int, int) TO authenticated;

-- =====================================================
-- K) ADMIN GET MECHANIC DETAIL
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_mechanic_detail(p_mechanic_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic jsonb;
  v_documents jsonb;
  v_recent_jobs jsonb;
  v_trust_score jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  -- Mechanic profile
  SELECT jsonb_build_object(
    'id', mp.id,
    'full_name', p.full_name,
    'email', p.email,
    'phone', p.phone,
    'verification_status', mp.verification_status,
    'rejection_reason', mp.rejection_reason,
    'tier', mp.tier,
    'strikes', COALESCE(mp.strikes, 0),
    'hub_id', mp.hub_id,
    'hub_name', h.name,
    'rating_avg', mp.rating_avg,
    'rating_count', mp.rating_count,
    'bio', mp.bio,
    'years_experience', mp.years_experience,
    'specialties', mp.specialties,
    'certifications', mp.certifications,
    'service_radius_miles', mp.service_radius_miles,
    'created_at', mp.created_at,
    'verified_at', mp.verified_at
  ) INTO v_mechanic
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON p.id = mp.id
  LEFT JOIN public.service_hubs h ON h.id = mp.hub_id
  WHERE mp.id = p_mechanic_id;

  IF v_mechanic IS NULL THEN
    RETURN jsonb_build_object('error', 'Mechanic not found');
  END IF;

  -- Verification documents
  SELECT jsonb_agg(jsonb_build_object(
    'id', vd.id,
    'document_type', vd.document_type,
    'status', vd.status,
    'uploaded_at', vd.uploaded_at,
    'reviewed_at', vd.reviewed_at
  ) ORDER BY vd.uploaded_at DESC)
  INTO v_documents
  FROM public.verification_documents vd
  WHERE vd.mechanic_id = p_mechanic_id;

  -- Recent jobs (last 10)
  SELECT jsonb_agg(jsonb_build_object(
    'job_id', j.id,
    'title', j.title,
    'status', j.status,
    'completed_at', j.completed_at,
    'customer_name', pc.full_name
  ) ORDER BY j.created_at DESC)
  INTO v_recent_jobs
  FROM public.job_contracts jc
  JOIN public.jobs j ON j.id = jc.job_id
  JOIN public.profiles pc ON pc.id = j.customer_id
  WHERE jc.mechanic_id = p_mechanic_id
  LIMIT 10;

  -- Trust score
  SELECT jsonb_build_object(
    'score', ts.score,
    'components', ts.score_components,
    'updated_at', ts.updated_at
  ) INTO v_trust_score
  FROM public.trust_scores ts
  WHERE ts.user_id = p_mechanic_id;

  RETURN jsonb_build_object(
    'mechanic', v_mechanic,
    'documents', COALESCE(v_documents, '[]'::jsonb),
    'recent_jobs', COALESCE(v_recent_jobs, '[]'::jsonb),
    'trust_score', v_trust_score
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_mechanic_detail(uuid) TO authenticated;

-- =====================================================
-- L) ADMIN GET SUPPORT REQUESTS
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_support_requests(
  p_status text DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  job_id uuid,
  job_title text,
  user_id uuid,
  user_name text,
  user_role text,
  category text,
  subject text,
  status text,
  priority text,
  created_at timestamptz,
  resolved_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    sr.id,
    sr.job_id,
    j.title as job_title,
    sr.user_id,
    p.full_name as user_name,
    p.role::text as user_role,
    sr.category,
    sr.subject,
    sr.status,
    sr.priority,
    sr.created_at,
    sr.resolved_at
  FROM public.support_requests sr
  LEFT JOIN public.jobs j ON j.id = sr.job_id
  JOIN public.profiles p ON p.id = sr.user_id
  WHERE (p_status IS NULL OR sr.status = p_status)
  ORDER BY 
    CASE sr.priority WHEN 'urgent' THEN 1 WHEN 'high' THEN 2 WHEN 'normal' THEN 3 WHEN 'low' THEN 4 ELSE 5 END,
    sr.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_support_requests(text, int, int) TO authenticated;

-- =====================================================
-- M) ADMIN RESOLVE SUPPORT REQUEST
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_resolve_support_request(
  p_request_id uuid,
  p_status text,
  p_resolution_notes text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_old_status text;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT status INTO v_old_status
  FROM public.support_requests
  WHERE id = p_request_id;

  IF v_old_status IS NULL THEN
    RETURN jsonb_build_object('error', 'Support request not found');
  END IF;

  UPDATE public.support_requests
  SET 
    status = p_status,
    resolution_notes = COALESCE(p_resolution_notes, resolution_notes),
    resolved_at = CASE WHEN p_status = 'resolved' THEN now() ELSE resolved_at END,
    resolved_by = auth.uid(),
    updated_at = now()
  WHERE id = p_request_id;

  -- Write to audit_log
  PERFORM public.admin_audit_log(
    'ADMIN_RESOLVE_SUPPORT_REQUEST',
    'support_requests',
    p_request_id,
    jsonb_build_object(
      'old_status', v_old_status,
      'new_status', p_status,
      'resolution_notes', p_resolution_notes
    )
  );

  RETURN jsonb_build_object('success', true, 'request_id', p_request_id);
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_resolve_support_request(uuid, text, text) TO authenticated;

-- =====================================================
-- N) ADMIN GET PAYMENTS
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_payments(
  p_status text DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  job_id uuid,
  job_title text,
  contract_id uuid,
  customer_id uuid,
  customer_name text,
  mechanic_id uuid,
  mechanic_name text,
  amount_cents int,
  status text,
  created_at timestamptz,
  paid_at timestamptz,
  refunded_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    pay.id,
    pay.job_id,
    j.title as job_title,
    pay.contract_id,
    j.customer_id,
    pc.full_name as customer_name,
    jc.mechanic_id,
    pm.full_name as mechanic_name,
    pay.amount_cents,
    pay.status,
    pay.created_at,
    pay.paid_at,
    pay.refunded_at
  FROM public.payments pay
  JOIN public.jobs j ON j.id = pay.job_id
  JOIN public.profiles pc ON pc.id = j.customer_id
  LEFT JOIN public.job_contracts jc ON jc.id = pay.contract_id
  LEFT JOIN public.profiles pm ON pm.id = jc.mechanic_id
  WHERE (p_status IS NULL OR pay.status = p_status)
  ORDER BY pay.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_payments(text, int, int) TO authenticated;

-- =====================================================
-- O) ADMIN GET PAYOUTS
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_payouts(
  p_status text DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  mechanic_id uuid,
  mechanic_name text,
  amount_cents int,
  status text,
  payout_method text,
  created_at timestamptz,
  processed_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    po.id,
    po.mechanic_id,
    p.full_name as mechanic_name,
    po.amount_cents,
    po.status,
    po.payout_method,
    po.created_at,
    po.processed_at
  FROM public.payouts po
  JOIN public.profiles p ON p.id = po.mechanic_id
  WHERE (p_status IS NULL OR po.status = p_status)
  ORDER BY po.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_payouts(text, int, int) TO authenticated;

-- =====================================================
-- P) ADMIN GET AUDIT LOG
-- =====================================================

CREATE OR REPLACE FUNCTION public.admin_get_audit_log(
  p_entity_type text DEFAULT NULL,
  p_entity_id uuid DEFAULT NULL,
  p_action text DEFAULT NULL,
  p_limit int DEFAULT 100,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  actor_id uuid,
  actor_name text,
  actor_type text,
  action text,
  entity_type text,
  entity_id uuid,
  metadata jsonb,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    al.id,
    al.actor_id,
    p.full_name as actor_name,
    al.actor_type,
    al.action,
    al.entity_type,
    al.entity_id,
    al.metadata,
    al.created_at
  FROM public.audit_log al
  LEFT JOIN public.profiles p ON p.id = al.actor_id
  WHERE (p_entity_type IS NULL OR al.entity_type = p_entity_type)
    AND (p_entity_id IS NULL OR al.entity_id = p_entity_id)
    AND (p_action IS NULL OR al.action = p_action)
  ORDER BY al.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_audit_log(text, uuid, text, int, int) TO authenticated;
\n-- ===================================================================
-- END: 20260120000001_phase4_admin_audit_metrics.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260120000002_fix_is_admin.sql
-- ===================================================================\n
-- Fix is_admin to check both admin_users table AND profiles.role = 'admin'

CREATE OR REPLACE FUNCTION public.is_admin(uid uuid DEFAULT auth.uid())
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.admin_users WHERE user_id = uid
  ) OR EXISTS (
    SELECT 1 FROM public.profiles WHERE id = uid AND role = 'admin'
  );
END;
$$;\n-- ===================================================================
-- END: 20260120000002_fix_is_admin.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260120000003_fix_support_requests_rpc.sql
-- ===================================================================\n
-- Drop and recreate admin_get_support_requests to match actual table schema
DROP FUNCTION IF EXISTS public.admin_get_support_requests(text, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_support_requests(
  p_status text DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  job_id uuid,
  job_title text,
  user_id uuid,
  user_name text,
  user_role text,
  category text,
  message text,
  status text,
  created_at timestamptz,
  updated_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    sr.id,
    sr.job_id,
    j.title as job_title,
    sr.user_id,
    p.full_name as user_name,
    p.role::text as user_role,
    sr.category,
    sr.message,
    sr.status,
    sr.created_at,
    sr.updated_at
  FROM public.support_requests sr
  LEFT JOIN public.jobs j ON j.id = sr.job_id
  LEFT JOIN public.profiles p ON p.id = sr.user_id
  WHERE (p_status IS NULL OR sr.status = p_status)
  ORDER BY sr.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_support_requests(text, int, int) TO authenticated;\n-- ===================================================================
-- END: 20260120000003_fix_support_requests_rpc.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260120000004_fix_admin_schema_mismatches.sql
-- ===================================================================\n
-- Fix admin RPC schema mismatches

-- 1. Fix admin_get_payments (remove contract_id reference)
DROP FUNCTION IF EXISTS public.admin_get_payments(text, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_payments(
  p_status text DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  job_id uuid,
  job_title text,
  customer_id uuid,
  customer_name text,
  mechanic_id uuid,
  mechanic_name text,
  amount_cents int,
  status text,
  created_at timestamptz,
  paid_at timestamptz,
  refunded_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    pay.id,
    pay.job_id,
    j.title as job_title,
    pay.customer_id,
    pc.full_name as customer_name,
    pay.mechanic_id,
    pm.full_name as mechanic_name,
    pay.amount_cents,
    pay.status::text,
    pay.created_at,
    pay.paid_at,
    pay.refunded_at
  FROM public.payments pay
  JOIN public.jobs j ON j.id = pay.job_id
  JOIN public.profiles pc ON pc.id = pay.customer_id
  LEFT JOIN public.profiles pm ON pm.id = pay.mechanic_id
  WHERE (p_status IS NULL OR pay.status::text = p_status)
  ORDER BY pay.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_payments(text, int, int) TO authenticated;

-- 2. Fix admin_get_payouts (use net_amount_cents, remove payout_method)
DROP FUNCTION IF EXISTS public.admin_get_payouts(text, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_payouts(
  p_status text DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  mechanic_id uuid,
  mechanic_name text,
  gross_amount_cents int,
  net_amount_cents int,
  commission_cents int,
  status text,
  created_at timestamptz,
  processed_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    po.id,
    po.mechanic_id,
    p.full_name as mechanic_name,
    po.gross_amount_cents,
    po.net_amount_cents,
    po.commission_cents,
    po.status::text,
    po.created_at,
    po.processed_at
  FROM public.payouts po
  JOIN public.profiles p ON p.id = po.mechanic_id
  WHERE (p_status IS NULL OR po.status::text = p_status)
  ORDER BY po.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_payouts(text, int, int) TO authenticated;

-- 3. Fix admin_get_job_detail (fix support_requests fields: message instead of subject, updated_at instead of resolved_at)
CREATE OR REPLACE FUNCTION public.admin_get_job_detail(p_job_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_job jsonb;
  v_quotes jsonb;
  v_contract jsonb;
  v_events jsonb;
  v_disputes jsonb;
  v_support jsonb;
  v_payments jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN NULL;
  END IF;

  SELECT jsonb_build_object(
    'id', j.id,
    'title', j.title,
    'description', j.description,
    'status', j.status,
    'customer_id', j.customer_id,
    'customer_name', pc.full_name,
    'customer_email', pc.email,
    'location_lat', j.location_lat,
    'location_lng', j.location_lng,
    'location_address', j.location_address,
    'vehicle_year', v.year,
    'vehicle_make', v.make,
    'vehicle_model', v.model,
    'created_at', j.created_at,
    'scheduled_at', j.scheduled_at,
    'completed_at', j.completed_at
  )
  INTO v_job
  FROM public.jobs j
  JOIN public.profiles pc ON pc.id = j.customer_id
  LEFT JOIN public.vehicles v ON v.id = j.vehicle_id
  WHERE j.id = p_job_id;

  IF v_job IS NULL THEN
    RETURN NULL;
  END IF;

  SELECT jsonb_agg(jsonb_build_object(
    'id', q.id,
    'mechanic_id', q.mechanic_id,
    'mechanic_name', pm.full_name,
    'status', q.status,
    'labor_cents', COALESCE((q.line_items_json->0->>'labor_cents')::int, 0),
    'parts_cents', COALESCE((q.line_items_json->0->>'parts_cents')::int, 0),
    'total_cents', q.total_cents,
    'eta_minutes', q.eta_minutes,
    'created_at', q.created_at
  ) ORDER BY q.created_at DESC)
  INTO v_quotes
  FROM public.quotes q
  JOIN public.profiles pm ON pm.id = q.mechanic_id
  WHERE q.job_id = p_job_id;

  SELECT jsonb_build_object(
    'id', jc.id,
    'mechanic_id', jc.mechanic_id,
    'mechanic_name', pm.full_name,
    'status', jc.status,
    'accepted_at', jc.accepted_at,
    'started_at', jc.started_at,
    'completed_at', jc.completed_at,
    'final_labor_cents', jc.final_labor_cents,
    'final_parts_cents', jc.final_parts_cents,
    'final_total_cents', jc.final_total_cents
  )
  INTO v_contract
  FROM public.job_contracts jc
  JOIN public.profiles pm ON pm.id = jc.mechanic_id
  WHERE jc.job_id = p_job_id
  LIMIT 1;

  SELECT jsonb_agg(jsonb_build_object(
    'id', je.id,
    'event_type', je.event_type,
    'actor_id', je.actor_id,
    'actor_role', je.actor_role,
    'metadata', je.metadata,
    'created_at', je.created_at
  ) ORDER BY je.created_at DESC)
  INTO v_events
  FROM (
    SELECT * FROM public.job_events WHERE job_id = p_job_id ORDER BY created_at DESC LIMIT 50
  ) je;

  SELECT jsonb_agg(jsonb_build_object(
    'id', d.id,
    'status', d.status,
    'category', d.category,
    'priority', d.priority,
    'created_at', d.created_at,
    'resolved_at', d.resolved_at
  ) ORDER BY d.created_at DESC)
  INTO v_disputes
  FROM public.disputes d WHERE d.job_id = p_job_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', sr.id,
    'status', sr.status,
    'category', sr.category,
    'message', sr.message,
    'created_at', sr.created_at,
    'updated_at', sr.updated_at
  ) ORDER BY sr.created_at DESC)
  INTO v_support
  FROM public.support_requests sr WHERE sr.job_id = p_job_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', p.id,
    'status', p.status,
    'amount_cents', p.amount_cents,
    'created_at', p.created_at,
    'paid_at', p.paid_at,
    'refunded_at', p.refunded_at
  ) ORDER BY p.created_at DESC)
  INTO v_payments
  FROM public.payments p WHERE p.job_id = p_job_id;

  RETURN jsonb_build_object(
    'job', v_job,
    'quotes', COALESCE(v_quotes, '[]'::jsonb),
    'contract', v_contract,
    'events', COALESCE(v_events, '[]'::jsonb),
    'disputes', COALESCE(v_disputes, '[]'::jsonb),
    'support_requests', COALESCE(v_support, '[]'::jsonb),
    'payments', COALESCE(v_payments, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_job_detail(uuid) TO authenticated;\n-- ===================================================================
-- END: 20260120000004_fix_admin_schema_mismatches.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260120000006_fix_admin_rpcs.sql
-- ===================================================================\n
-- Fix admin RPC type mismatches and column references

-- 1. Fix admin_get_jobs (varchar to text casting)
DROP FUNCTION IF EXISTS public.admin_get_jobs(text, uuid, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_jobs(
  p_status text DEFAULT NULL,
  p_hub_id uuid DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  title text,
  status text,
  customer_id uuid,
  customer_name text,
  mechanic_id uuid,
  mechanic_name text,
  hub_id uuid,
  hub_name text,
  created_at timestamptz,
  completed_at timestamptz,
  quote_count bigint,
  has_dispute boolean,
  has_support_ticket boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    j.id,
    j.title::text,
    j.status::text,
    j.customer_id,
    pc.full_name::text as customer_name,
    jc.mechanic_id,
    pm.full_name::text as mechanic_name,
    j.hub_id,
    h.name::text as hub_name,
    j.created_at,
    j.completed_at,
    (SELECT COUNT(*) FROM public.quotes q WHERE q.job_id = j.id) as quote_count,
    EXISTS(SELECT 1 FROM public.disputes d WHERE d.job_id = j.id) as has_dispute,
    EXISTS(SELECT 1 FROM public.support_requests sr WHERE sr.job_id = j.id) as has_support_ticket
  FROM public.jobs j
  JOIN public.profiles pc ON pc.id = j.customer_id
  LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
  LEFT JOIN public.profiles pm ON pm.id = jc.mechanic_id
  LEFT JOIN public.service_hubs h ON h.id = j.hub_id
  WHERE (p_status IS NULL OR j.status::text = p_status)
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id)
  ORDER BY j.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_jobs(text, uuid, int, int) TO authenticated;

-- 2. Fix admin_get_job_detail (remove non-existent columns)
DROP FUNCTION IF EXISTS public.admin_get_job_detail(uuid);

CREATE OR REPLACE FUNCTION public.admin_get_job_detail(p_job_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_job jsonb;
  v_quotes jsonb;
  v_contract jsonb;
  v_events jsonb;
  v_disputes jsonb;
  v_support jsonb;
  v_payments jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  -- Job with customer info (removed service_type, urgency - may not exist)
  SELECT jsonb_build_object(
    'id', j.id,
    'title', j.title::text,
    'description', j.description::text,
    'status', j.status::text,
    'customer_id', j.customer_id,
    'customer_name', pc.full_name::text,
    'customer_email', pc.email::text,
    'hub_id', j.hub_id,
    'location_lat', j.location_lat,
    'location_lng', j.location_lng,
    'location_address', j.location_address::text,
    'vehicle_year', COALESCE(v.year, j.vehicle_year),
    'vehicle_make', COALESCE(v.make, j.vehicle_make)::text,
    'vehicle_model', COALESCE(v.model, j.vehicle_model)::text,
    'created_at', j.created_at,
    'scheduled_at', j.scheduled_at,
    'started_at', j.started_at,
    'completed_at', j.completed_at
  ) INTO v_job
  FROM public.jobs j
  JOIN public.profiles pc ON pc.id = j.customer_id
  LEFT JOIN public.vehicles v ON v.id = j.vehicle_id
  WHERE j.id = p_job_id;

  IF v_job IS NULL THEN
    RETURN jsonb_build_object('error', 'Job not found');
  END IF;

  -- Quotes
  SELECT jsonb_agg(jsonb_build_object(
    'id', q.id,
    'mechanic_id', q.mechanic_id,
    'mechanic_name', pm.full_name::text,
    'status', q.status::text,
    'total_cents', COALESCE(q.total_cents, 0),
    'eta_minutes', COALESCE(q.eta_minutes, 0),
    'created_at', q.created_at
  ) ORDER BY q.created_at DESC)
  INTO v_quotes
  FROM public.quotes q
  JOIN public.profiles pm ON pm.id = q.mechanic_id
  WHERE q.job_id = p_job_id;

  -- Contract
  SELECT jsonb_build_object(
    'id', jc.id,
    'mechanic_id', jc.mechanic_id,
    'mechanic_name', pm.full_name::text,
    'status', jc.status::text,
    'accepted_at', jc.accepted_at,
    'started_at', jc.started_at,
    'completed_at', jc.completed_at,
    'final_total_cents', COALESCE(jc.final_total_cents, 0)
  ) INTO v_contract
  FROM public.job_contracts jc
  JOIN public.profiles pm ON pm.id = jc.mechanic_id
  WHERE jc.job_id = p_job_id
  LIMIT 1;

  -- Events (last 50)
  SELECT jsonb_agg(jsonb_build_object(
    'id', je.id,
    'event_type', je.event_type::text,
    'actor_id', je.actor_id,
    'actor_role', je.actor_role::text,
    'metadata', je.metadata,
    'created_at', je.created_at
  ) ORDER BY je.created_at DESC)
  INTO v_events
  FROM (
    SELECT * FROM public.job_events WHERE job_id = p_job_id ORDER BY created_at DESC LIMIT 50
  ) je;

  -- Disputes
  SELECT jsonb_agg(jsonb_build_object(
    'id', d.id,
    'status', d.status::text,
    'category', d.category::text,
    'priority', d.priority::text,
    'created_at', d.created_at,
    'resolved_at', d.resolved_at
  ) ORDER BY d.created_at DESC)
  INTO v_disputes
  FROM public.disputes d WHERE d.job_id = p_job_id;

  -- Support requests
  SELECT jsonb_agg(jsonb_build_object(
    'id', sr.id,
    'status', sr.status::text,
    'category', sr.category::text,
    'message', sr.message::text,
    'created_at', sr.created_at,
    'updated_at', sr.updated_at
  ) ORDER BY sr.created_at DESC)
  INTO v_support
  FROM public.support_requests sr WHERE sr.job_id = p_job_id;

  -- Payments
  SELECT jsonb_agg(jsonb_build_object(
    'id', p.id,
    'status', p.status::text,
    'amount_cents', COALESCE(p.amount_cents, 0),
    'created_at', p.created_at,
    'paid_at', p.paid_at,
    'refunded_at', p.refunded_at
  ) ORDER BY p.created_at DESC)
  INTO v_payments
  FROM public.payments p WHERE p.job_id = p_job_id;

  RETURN jsonb_build_object(
    'job', v_job,
    'quotes', COALESCE(v_quotes, '[]'::jsonb),
    'contract', v_contract,
    'events', COALESCE(v_events, '[]'::jsonb),
    'disputes', COALESCE(v_disputes, '[]'::jsonb),
    'support_requests', COALESCE(v_support, '[]'::jsonb),
    'payments', COALESCE(v_payments, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_job_detail(uuid) TO authenticated;

-- 3. Fix admin_get_mechanics (remove non-existent strikes and hub_id columns)
DROP FUNCTION IF EXISTS public.admin_get_mechanics(text, uuid, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_mechanics(
  p_status text DEFAULT NULL,
  p_hub_id uuid DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  full_name text,
  email text,
  phone text,
  verification_status text,
  tier text,
  strikes int,
  hub_id uuid,
  hub_name text,
  rating_avg numeric,
  completed_jobs bigint,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT
    mp.id,
    p.full_name::text,
    p.email::text,
    p.phone::text,
    mp.verification_status::text,
    mp.tier::text,
    0 as strikes,
    p.hub_id,
    h.name::text as hub_name,
    mp.rating_avg,
    (SELECT COUNT(*) FROM public.job_contracts jc
     JOIN public.jobs j ON j.id = jc.job_id
     WHERE jc.mechanic_id = mp.id AND j.status = 'completed') as completed_jobs,
    mp.created_at
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON p.id = mp.id
  LEFT JOIN public.service_hubs h ON h.id = p.hub_id
  WHERE (p_status IS NULL OR mp.verification_status::text = p_status)
    AND (p_hub_id IS NULL OR p.hub_id = p_hub_id)
  ORDER BY mp.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_mechanics(text, uuid, int, int) TO authenticated;

-- 4. Fix admin_get_mechanic_detail (remove non-existent columns)
DROP FUNCTION IF EXISTS public.admin_get_mechanic_detail(uuid);

CREATE OR REPLACE FUNCTION public.admin_get_mechanic_detail(p_mechanic_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic jsonb;
  v_jobs jsonb;
  v_reviews jsonb;
  v_payouts jsonb;
  v_disputes jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  -- Mechanic profile with user info
  SELECT jsonb_build_object(
    'id', mp.id,
    'full_name', p.full_name::text,
    'email', p.email::text,
    'phone', p.phone::text,
    'verification_status', mp.verification_status::text,
    'tier', mp.tier::text,
    'strikes', 0,
    'hub_id', p.hub_id,
    'hub_name', h.name::text,
    'rating_avg', mp.rating_avg,
    'rating_count', COALESCE(mp.rating_count, 0),
    'bio', mp.bio::text,
    'specialties', mp.specialties,
    'created_at', mp.created_at,
    'verified_at', mp.verified_at
  ) INTO v_mechanic
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON p.id = mp.id
  LEFT JOIN public.service_hubs h ON h.id = p.hub_id
  WHERE mp.id = p_mechanic_id;

  IF v_mechanic IS NULL THEN
    RETURN jsonb_build_object('error', 'Mechanic not found');
  END IF;

  -- Recent jobs (last 20)
  SELECT jsonb_agg(jsonb_build_object(
    'id', j.id,
    'title', j.title::text,
    'status', j.status::text,
    'customer_name', pc.full_name::text,
    'created_at', j.created_at,
    'completed_at', j.completed_at
  ) ORDER BY j.created_at DESC)
  INTO v_jobs
  FROM (
    SELECT j.* FROM public.jobs j
    JOIN public.job_contracts jc ON jc.job_id = j.id
    WHERE jc.mechanic_id = p_mechanic_id
    ORDER BY j.created_at DESC
    LIMIT 20
  ) j
  JOIN public.profiles pc ON pc.id = j.customer_id;

  -- Reviews
  SELECT jsonb_agg(jsonb_build_object(
    'id', r.id,
    'rating', r.rating,
    'comment', r.comment::text,
    'reviewer_name', pr.full_name::text,
    'created_at', r.created_at
  ) ORDER BY r.created_at DESC)
  INTO v_reviews
  FROM public.reviews r
  JOIN public.profiles pr ON pr.id = r.reviewer_id
  WHERE r.reviewee_id = p_mechanic_id
  LIMIT 20;

  -- Payouts
  SELECT jsonb_agg(jsonb_build_object(
    'id', po.id,
    'status', po.status::text,
    'net_amount_cents', COALESCE(po.net_amount_cents, 0),
    'created_at', po.created_at
  ) ORDER BY po.created_at DESC)
  INTO v_payouts
  FROM public.payouts po
  WHERE po.mechanic_id = p_mechanic_id
  LIMIT 20;

  -- Disputes
  SELECT jsonb_agg(jsonb_build_object(
    'id', d.id,
    'status', d.status::text,
    'category', d.category::text,
    'created_at', d.created_at,
    'resolved_at', d.resolved_at
  ) ORDER BY d.created_at DESC)
  INTO v_disputes
  FROM public.disputes d
  JOIN public.job_contracts jc ON jc.job_id = d.job_id
  WHERE jc.mechanic_id = p_mechanic_id
  LIMIT 20;

  RETURN jsonb_build_object(
    'mechanic', v_mechanic,
    'jobs', COALESCE(v_jobs, '[]'::jsonb),
    'reviews', COALESCE(v_reviews, '[]'::jsonb),
    'payouts', COALESCE(v_payouts, '[]'::jsonb),
    'disputes', COALESCE(v_disputes, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_mechanic_detail(uuid) TO authenticated;\n-- ===================================================================
-- END: 20260120000006_fix_admin_rpcs.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260120000007_phase41_support_customers_rpcs.sql
-- ===================================================================\n
-- =====================================================
-- PHASE 4.1: Schema-aligned Admin Support & Customer RPCs
-- =====================================================

-- =====================================================
-- A) SUPPORT REQUESTS  DROP OLD, CREATE NEW
-- =====================================================

DROP FUNCTION IF EXISTS public.admin_get_support_requests(text, int, int);

-- A.1) admin_list_support_requests - enriched list with user info
CREATE OR REPLACE FUNCTION public.admin_list_support_requests(
  p_status text DEFAULT NULL,
  p_category text DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  support_request_id uuid,
  status text,
  category text,
  message text,
  created_at timestamptz,
  user_id uuid,
  user_name text,
  user_role text,
  user_phone text,
  user_email text,
  job_id uuid,
  hub_id uuid,
  has_screenshot boolean,
  last_updated_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    sr.id as support_request_id,
    sr.status::text,
    sr.category::text,
    sr.message::text,
    sr.created_at,
    sr.user_id,
    COALESCE(p.full_name, p.display_name, 'Unknown')::text as user_name,
    COALESCE(p.role::text, 'customer') as user_role,
    COALESCE(p.phone, '')::text as user_phone,
    COALESCE(p.email, '')::text as user_email,
    sr.job_id,
    p.hub_id,
    (sr.screenshot_url IS NOT NULL) as has_screenshot,
    sr.updated_at as last_updated_at
  FROM public.support_requests sr
  LEFT JOIN public.profiles p ON p.id = sr.user_id
  WHERE (p_status IS NULL OR sr.status = p_status)
    AND (p_category IS NULL OR sr.category = p_category)
  ORDER BY sr.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_list_support_requests(text, text, int, int) TO authenticated;

-- A.2) admin_get_support_request_details - full detail with job context
CREATE OR REPLACE FUNCTION public.admin_get_support_request_details(
  p_support_request_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_sr record;
  v_user jsonb;
  v_job jsonb;
  v_contract jsonb;
  v_payments jsonb;
  v_payouts jsonb;
  v_disputes jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  -- Get support request
  SELECT * INTO v_sr FROM public.support_requests WHERE id = p_support_request_id;
  IF v_sr IS NULL THEN
    RETURN jsonb_build_object('error', 'Support request not found');
  END IF;

  -- Get user profile
  SELECT jsonb_build_object(
    'id', p.id,
    'full_name', COALESCE(p.full_name, p.display_name, 'Unknown'),
    'phone', COALESCE(p.phone, ''),
    'email', COALESCE(p.email, ''),
    'role', COALESCE(p.role::text, 'customer'),
    'city', COALESCE(p.city, ''),
    'state', COALESCE(p.state, ''),
    'hub_id', p.hub_id,
    'created_at', p.created_at
  ) INTO v_user
  FROM public.profiles p
  WHERE p.id = v_sr.user_id;

  -- Get job if exists
  IF v_sr.job_id IS NOT NULL THEN
    SELECT jsonb_build_object(
      'id', j.id,
      'title', COALESCE(j.title, 'Untitled Job'),
      'status', j.status::text,
      'created_at', j.created_at,
      'location_address', COALESCE(j.location_address, ''),
      'symptom_key', j.symptom_key,
      'accepted_mechanic_id', j.accepted_mechanic_id,
      'customer_id', j.customer_id
    ) INTO v_job
    FROM public.jobs j
    WHERE j.id = v_sr.job_id;

    -- Get contract if exists
    SELECT jsonb_build_object(
      'id', jc.id,
      'status', jc.status::text,
      'quoted_price_cents', COALESCE(jc.final_total_cents, 0),
      'stripe_payment_intent_id', jc.stripe_payment_intent_id,
      'accepted_at', jc.accepted_at,
      'completed_at', jc.completed_at
    ) INTO v_contract
    FROM public.job_contracts jc
    WHERE jc.job_id = v_sr.job_id
    LIMIT 1;

    -- Get payments
    SELECT COALESCE(jsonb_agg(jsonb_build_object(
      'id', pay.id,
      'status', pay.status::text,
      'amount_cents', COALESCE(pay.amount_cents, 0),
      'paid_at', pay.paid_at,
      'refunded_at', pay.refunded_at
    )), '[]'::jsonb) INTO v_payments
    FROM public.payments pay
    WHERE pay.job_id = v_sr.job_id;

    -- Get payouts
    SELECT COALESCE(jsonb_agg(jsonb_build_object(
      'id', po.id,
      'status', po.status::text,
      'net_amount_cents', COALESCE(po.net_amount_cents, 0),
      'held_at', po.held_at,
      'hold_reason', po.hold_reason
    )), '[]'::jsonb) INTO v_payouts
    FROM public.payouts po
    WHERE po.job_id = v_sr.job_id;

    -- Get disputes
    SELECT COALESCE(jsonb_agg(jsonb_build_object(
      'id', d.id,
      'status', d.status::text,
      'category', d.category,
      'created_at', d.created_at,
      'resolved_at', d.resolved_at
    )), '[]'::jsonb) INTO v_disputes
    FROM public.disputes d
    WHERE d.job_id = v_sr.job_id;
  ELSE
    v_job := NULL;
    v_contract := NULL;
    v_payments := '[]'::jsonb;
    v_payouts := '[]'::jsonb;
    v_disputes := '[]'::jsonb;
  END IF;

  RETURN jsonb_build_object(
    'support_request', jsonb_build_object(
      'id', v_sr.id,
      'user_id', v_sr.user_id,
      'job_id', v_sr.job_id,
      'category', v_sr.category,
      'message', v_sr.message,
      'screenshot_url', v_sr.screenshot_url,
      'status', v_sr.status,
      'metadata', COALESCE(v_sr.metadata, '{}'::jsonb),
      'created_at', v_sr.created_at,
      'updated_at', v_sr.updated_at
    ),
    'user', COALESCE(v_user, '{}'::jsonb),
    'job', v_job,
    'contract', v_contract,
    'payments', v_payments,
    'payouts', v_payouts,
    'disputes', v_disputes
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_support_request_details(uuid) TO authenticated;

-- A.3) admin_update_support_request_status - update with audit logging
CREATE OR REPLACE FUNCTION public.admin_update_support_request_status(
  p_support_request_id uuid,
  p_status text,
  p_internal_note text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_old_status text;
  v_metadata jsonb;
  v_notes jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT status, COALESCE(metadata, '{}'::jsonb)
  INTO v_old_status, v_metadata
  FROM public.support_requests
  WHERE id = p_support_request_id;

  IF v_old_status IS NULL THEN
    RETURN jsonb_build_object('error', 'Support request not found');
  END IF;

  -- Append note to metadata->admin_notes array if provided
  IF p_internal_note IS NOT NULL THEN
    v_notes := COALESCE(v_metadata->'admin_notes', '[]'::jsonb);
    v_notes := v_notes || jsonb_build_array(jsonb_build_object(
      'note', p_internal_note,
      'by', auth.uid(),
      'at', now()
    ));
    v_metadata := v_metadata || jsonb_build_object('admin_notes', v_notes);
  END IF;

  UPDATE public.support_requests
  SET 
    status = p_status,
    metadata = v_metadata,
    updated_at = now()
  WHERE id = p_support_request_id;

  -- Write to audit_log
  PERFORM public.admin_audit_log(
    'ADMIN_UPDATE_SUPPORT_STATUS',
    'support_requests',
    p_support_request_id,
    jsonb_build_object(
      'old_status', v_old_status,
      'new_status', p_status,
      'note', p_internal_note
    )
  );

  RETURN jsonb_build_object('success', true, 'id', p_support_request_id);
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_update_support_request_status(uuid, text, text) TO authenticated;

-- =====================================================
-- B) CUSTOMERS  NEW RPCs
-- =====================================================

-- B.1) admin_list_customers - list with stats
CREATE OR REPLACE FUNCTION public.admin_list_customers(
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0,
  p_query text DEFAULT NULL
)
RETURNS TABLE (
  customer_id uuid,
  full_name text,
  email text,
  phone text,
  city text,
  state text,
  hub_id uuid,
  created_at timestamptz,
  total_jobs bigint,
  completed_jobs bigint,
  total_spent_cents bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    p.id as customer_id,
    COALESCE(p.full_name, p.display_name, 'Unknown')::text as full_name,
    COALESCE(p.email, '')::text as email,
    COALESCE(p.phone, '')::text as phone,
    COALESCE(p.city, '')::text as city,
    COALESCE(p.state, '')::text as state,
    p.hub_id,
    p.created_at,
    COALESCE((SELECT COUNT(*) FROM public.jobs j WHERE j.customer_id = p.id), 0) as total_jobs,
    COALESCE((SELECT COUNT(*) FROM public.jobs j WHERE j.customer_id = p.id AND j.status = 'completed'), 0) as completed_jobs,
    COALESCE((SELECT SUM(pay.amount_cents) FROM public.payments pay 
              JOIN public.jobs j ON j.id = pay.job_id 
              WHERE j.customer_id = p.id AND pay.paid_at IS NOT NULL), 0) as total_spent_cents
  FROM public.profiles p
  WHERE p.role = 'customer'
    AND (p_query IS NULL 
         OR p.full_name ILIKE '%' || p_query || '%'
         OR p.display_name ILIKE '%' || p_query || '%'
         OR p.email ILIKE '%' || p_query || '%'
         OR p.phone ILIKE '%' || p_query || '%')
  ORDER BY p.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_list_customers(int, int, text) TO authenticated;

-- B.2) admin_get_customer_details - full customer details with history
CREATE OR REPLACE FUNCTION public.admin_get_customer_details(
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_profile jsonb;
  v_jobs jsonb;
  v_payments jsonb;
  v_support jsonb;
  v_disputes jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  -- Get profile
  SELECT jsonb_build_object(
    'id', p.id,
    'full_name', COALESCE(p.full_name, p.display_name, 'Unknown'),
    'email', COALESCE(p.email, ''),
    'phone', COALESCE(p.phone, ''),
    'role', COALESCE(p.role::text, 'customer'),
    'city', COALESCE(p.city, ''),
    'state', COALESCE(p.state, ''),
    'hub_id', p.hub_id,
    'avatar_url', p.avatar_url,
    'created_at', p.created_at,
    'updated_at', p.updated_at
  ) INTO v_profile
  FROM public.profiles p
  WHERE p.id = p_customer_id;

  IF v_profile IS NULL THEN
    RETURN jsonb_build_object('error', 'Customer not found');
  END IF;

  -- Get last 20 jobs
  SELECT COALESCE(jsonb_agg(jsonb_build_object(
    'id', j.id,
    'title', COALESCE(j.title, 'Untitled Job'),
    'status', j.status::text,
    'created_at', j.created_at,
    'accepted_mechanic_id', j.accepted_mechanic_id,
    'completed_at', j.completed_at
  ) ORDER BY j.created_at DESC), '[]'::jsonb) INTO v_jobs
  FROM (
    SELECT * FROM public.jobs
    WHERE customer_id = p_customer_id
    ORDER BY created_at DESC
    LIMIT 20
  ) j;

  -- Get last 20 payments
  SELECT COALESCE(jsonb_agg(jsonb_build_object(
    'id', pay.id,
    'job_id', pay.job_id,
    'amount_cents', pay.amount_cents,
    'status', pay.status::text,
    'paid_at', pay.paid_at,
    'refunded_at', pay.refunded_at
  ) ORDER BY pay.created_at DESC), '[]'::jsonb) INTO v_payments
  FROM (
    SELECT pay.* FROM public.payments pay
    JOIN public.jobs j ON j.id = pay.job_id
    WHERE j.customer_id = p_customer_id
    ORDER BY pay.created_at DESC
    LIMIT 20
  ) pay;

  -- Get last 10 support requests
  SELECT COALESCE(jsonb_agg(jsonb_build_object(
    'id', sr.id,
    'category', sr.category,
    'message', sr.message,
    'status', sr.status,
    'created_at', sr.created_at
  ) ORDER BY sr.created_at DESC), '[]'::jsonb) INTO v_support
  FROM (
    SELECT * FROM public.support_requests
    WHERE user_id = p_customer_id
    ORDER BY created_at DESC
    LIMIT 10
  ) sr;

  -- Get last 10 disputes involving this customer
  SELECT COALESCE(jsonb_agg(jsonb_build_object(
    'id', d.id,
    'job_id', d.job_id,
    'category', d.category,
    'status', d.status::text,
    'created_at', d.created_at,
    'resolved_at', d.resolved_at
  ) ORDER BY d.created_at DESC), '[]'::jsonb) INTO v_disputes
  FROM (
    SELECT d.* FROM public.disputes d
    JOIN public.jobs j ON j.id = d.job_id
    WHERE j.customer_id = p_customer_id
    ORDER BY d.created_at DESC
    LIMIT 10
  ) d;

  RETURN jsonb_build_object(
    'profile', v_profile,
    'jobs', v_jobs,
    'payments', v_payments,
    'support_requests', v_support,
    'disputes', v_disputes
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_customer_details(uuid) TO authenticated;

-- =====================================================
-- C) RLS for support_requests - ensure users can see own, admin can see all
-- =====================================================

-- Drop existing policies if they exist
DROP POLICY IF EXISTS support_requests_select_own ON public.support_requests;
DROP POLICY IF EXISTS support_requests_insert_own ON public.support_requests;
DROP POLICY IF EXISTS support_requests_update_admin ON public.support_requests;

-- Users can see their own support requests
CREATE POLICY support_requests_select_own ON public.support_requests
  FOR SELECT TO authenticated
  USING (user_id = auth.uid() OR public.is_admin());

-- Users can insert their own support requests
CREATE POLICY support_requests_insert_own ON public.support_requests
  FOR INSERT TO authenticated
  WITH CHECK (user_id = auth.uid());

-- Only admin can update support requests
CREATE POLICY support_requests_update_admin ON public.support_requests
  FOR UPDATE TO authenticated
  USING (public.is_admin());
\n-- ===================================================================
-- END: 20260120000007_phase41_support_customers_rpcs.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260120000008_phase41_fix_pack.sql
-- ===================================================================\n
-- =====================================================
-- PHASE 4.1 FIX PACK
-- =====================================================
-- Fixes all admin RPCs that reference non-existent columns:
-- - h.city, h.state -> join zip_codes
-- - w.zip_code -> w.zip
-- - mp.specialties, mp.verified_at -> removed
-- - j.vehicle_year/make/model -> vehicles table
-- - r.rating -> r.overall_rating
-- =====================================================

-- =====================================================
-- 1) FIX admin_get_hubs (h.city/state don't exist, use lat/lng not latitude/longitude)
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_get_hubs();

CREATE OR REPLACE FUNCTION public.admin_get_hubs()
RETURNS TABLE (
  id uuid,
  name text,
  slug text,
  zip text,
  city text,
  state text,
  lat numeric,
  lng numeric,
  active_radius_miles int,
  max_radius_miles int,
  invite_only boolean,
  auto_expand_enabled boolean,
  is_active boolean,
  launch_date date,
  created_at timestamptz,
  active_mechanics bigint,
  jobs_last_14d bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    h.id,
    h.name::text,
    h.slug::text,
    h.zip::text,
    zc.city::text,
    zc.state::text,
    h.lat::numeric,
    h.lng::numeric,
    h.active_radius_miles::int,
    h.max_radius_miles::int,
    h.invite_only,
    h.auto_expand_enabled,
    h.is_active,
    h.launch_date,
    h.created_at,
    (SELECT COUNT(DISTINCT p.id) 
     FROM public.profiles p
     JOIN public.mechanic_profiles mp ON mp.id = p.id
     WHERE p.hub_id = h.id AND mp.verification_status = 'active') as active_mechanics,
    (SELECT COUNT(*) 
     FROM public.jobs j 
     WHERE j.hub_id = h.id AND j.created_at >= CURRENT_DATE - 14) as jobs_last_14d
  FROM public.service_hubs h
  LEFT JOIN public.zip_codes zc ON zc.zip = h.zip
  ORDER BY h.name;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_hubs() TO authenticated;

-- =====================================================
-- 2) FIX admin_get_waitlist_heatmap (w.zip_code -> w.zip)
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_get_waitlist_heatmap(uuid, int);

CREATE OR REPLACE FUNCTION public.admin_get_waitlist_heatmap(
  p_hub_id uuid DEFAULT NULL,
  p_days int DEFAULT 30
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_start_date timestamptz;
  v_by_zip jsonb;
  v_by_hub jsonb;
  v_by_user_type jsonb;
  v_total bigint;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  v_start_date := now() - (p_days || ' days')::interval;

  SELECT COUNT(*) INTO v_total
  FROM public.waitlist w
  WHERE w.created_at >= v_start_date
    AND (p_hub_id IS NULL OR w.nearest_hub_id = p_hub_id);

  SELECT jsonb_agg(sub ORDER BY sub.count DESC)
  INTO v_by_zip
  FROM (
    SELECT 
      w.zip::text as zip,
      zc.city::text as city,
      zc.state::text as state,
      COUNT(*) as count,
      w.nearest_hub_id as hub_id
    FROM public.waitlist w
    LEFT JOIN public.zip_codes zc ON zc.zip = w.zip
    WHERE w.created_at >= v_start_date
      AND (p_hub_id IS NULL OR w.nearest_hub_id = p_hub_id)
    GROUP BY w.zip, zc.city, zc.state, w.nearest_hub_id
    ORDER BY COUNT(*) DESC
    LIMIT 20
  ) sub;

  SELECT jsonb_agg(sub ORDER BY sub.count DESC)
  INTO v_by_hub
  FROM (
    SELECT 
      w.nearest_hub_id as hub_id,
      h.name::text as hub_name,
      COUNT(*) as count
    FROM public.waitlist w
    LEFT JOIN public.service_hubs h ON h.id = w.nearest_hub_id
    WHERE w.created_at >= v_start_date
      AND (p_hub_id IS NULL OR w.nearest_hub_id = p_hub_id)
    GROUP BY w.nearest_hub_id, h.name
    ORDER BY COUNT(*) DESC
  ) sub;

  SELECT jsonb_agg(sub)
  INTO v_by_user_type
  FROM (
    SELECT 
      w.user_type::text,
      COUNT(*) as count
    FROM public.waitlist w
    WHERE w.created_at >= v_start_date
      AND (p_hub_id IS NULL OR w.nearest_hub_id = p_hub_id)
    GROUP BY w.user_type
  ) sub;

  RETURN jsonb_build_object(
    'period_days', p_days,
    'hub_id', p_hub_id,
    'total', v_total,
    'by_zip', COALESCE(v_by_zip, '[]'::jsonb),
    'by_hub', COALESCE(v_by_hub, '[]'::jsonb),
    'by_user_type', COALESCE(v_by_user_type, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_waitlist_heatmap(uuid, int) TO authenticated;

-- =====================================================
-- 3) FIX admin_get_mechanics (already has p.hub_id, add tier column if exists)
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_get_mechanics(text, uuid, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_mechanics(
  p_status text DEFAULT NULL,
  p_hub_id uuid DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  full_name text,
  email text,
  phone text,
  verification_status text,
  tier text,
  hub_id uuid,
  hub_name text,
  rating_avg numeric,
  rating_count int,
  jobs_completed int,
  is_available boolean,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT
    mp.id,
    p.full_name::text,
    p.email::text,
    p.phone::text,
    mp.verification_status::text,
    COALESCE(mp.tier, 'bronze')::text as tier,
    p.hub_id,
    h.name::text as hub_name,
    mp.rating_avg,
    COALESCE(mp.rating_count, 0)::int,
    COALESCE(mp.jobs_completed, 0)::int,
    mp.is_available,
    mp.created_at
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON p.id = mp.id
  LEFT JOIN public.service_hubs h ON h.id = p.hub_id
  WHERE (p_status IS NULL OR mp.verification_status::text = p_status)
    AND (p_hub_id IS NULL OR p.hub_id = p_hub_id)
  ORDER BY mp.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_mechanics(text, uuid, int, int) TO authenticated;

-- =====================================================
-- 4) FIX admin_get_mechanic_detail (remove mp.specialties, mp.verified_at)
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_get_mechanic_detail(uuid);

CREATE OR REPLACE FUNCTION public.admin_get_mechanic_detail(p_mechanic_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic jsonb;
  v_docs jsonb;
  v_vetting jsonb;
  v_jobs jsonb;
  v_reviews jsonb;
  v_disputes jsonb;
  v_support jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT jsonb_build_object(
    'id', mp.id,
    'full_name', p.full_name::text,
    'email', p.email::text,
    'phone', p.phone::text,
    'role', p.role::text,
    'city', p.city::text,
    'state', p.state::text,
    'hub_id', p.hub_id,
    'hub_name', h.name::text,
    'verification_status', mp.verification_status::text,
    'verification_reason', mp.verification_reason::text,
    'tier', COALESCE(mp.tier, 'bronze')::text,
    'bio', mp.bio::text,
    'years_experience', mp.years_experience,
    'hourly_rate_cents', mp.hourly_rate_cents,
    'service_radius_km', mp.service_radius_km,
    'mobile_service', mp.mobile_service,
    'is_available', mp.is_available,
    'rating_avg', mp.rating_avg,
    'rating_count', COALESCE(mp.rating_count, 0),
    'jobs_completed', COALESCE(mp.jobs_completed, 0),
    'stripe_account_id', mp.stripe_account_id::text,
    'stripe_onboarding_complete', mp.stripe_onboarding_complete,
    'created_at', mp.created_at,
    'updated_at', mp.updated_at
  ) INTO v_mechanic
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON p.id = mp.id
  LEFT JOIN public.service_hubs h ON h.id = p.hub_id
  WHERE mp.id = p_mechanic_id;

  IF v_mechanic IS NULL THEN
    RETURN jsonb_build_object('error', 'Mechanic not found');
  END IF;

  SELECT jsonb_agg(jsonb_build_object(
    'id', d.id,
    'doc_type', d.doc_type::text,
    'status', d.status::text,
    'uploaded_at', d.uploaded_at,
    'reviewed_at', d.reviewed_at,
    'review_notes', d.review_notes::text
  ) ORDER BY d.uploaded_at DESC)
  INTO v_docs
  FROM public.mechanic_verification_documents d
  WHERE d.mechanic_id = p_mechanic_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', v.id,
    'question_key', v.question_key::text,
    'answer', v.answer,
    'created_at', v.created_at
  ) ORDER BY v.created_at)
  INTO v_vetting
  FROM public.mechanic_vetting_responses v
  WHERE v.mechanic_id = p_mechanic_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', j.id,
    'title', j.title::text,
    'status', j.status::text,
    'customer_name', pc.full_name::text,
    'created_at', j.created_at,
    'completed_at', j.completed_at
  ) ORDER BY j.created_at DESC)
  INTO v_jobs
  FROM (
    SELECT j.* FROM public.jobs j
    JOIN public.job_contracts jc ON jc.job_id = j.id
    WHERE jc.mechanic_id = p_mechanic_id
    ORDER BY j.created_at DESC
    LIMIT 20
  ) j
  JOIN public.profiles pc ON pc.id = j.customer_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', r.id,
    'overall_rating', r.overall_rating,
    'comment', r.comment::text,
    'reviewer_name', pr.full_name::text,
    'created_at', r.created_at
  ) ORDER BY r.created_at DESC)
  INTO v_reviews
  FROM public.reviews r
  JOIN public.profiles pr ON pr.id = r.reviewer_id
  WHERE r.reviewee_id = p_mechanic_id
  LIMIT 20;

  SELECT jsonb_agg(jsonb_build_object(
    'id', d.id,
    'job_id', d.job_id,
    'status', d.status::text,
    'category', d.category::text,
    'created_at', d.created_at,
    'resolved_at', d.resolved_at
  ) ORDER BY d.created_at DESC)
  INTO v_disputes
  FROM public.disputes d
  JOIN public.job_contracts jc ON jc.job_id = d.job_id
  WHERE jc.mechanic_id = p_mechanic_id
  LIMIT 20;

  SELECT jsonb_agg(jsonb_build_object(
    'id', sr.id,
    'job_id', sr.job_id,
    'category', sr.category::text,
    'status', sr.status::text,
    'message', sr.message::text,
    'created_at', sr.created_at
  ) ORDER BY sr.created_at DESC)
  INTO v_support
  FROM public.support_requests sr
  WHERE sr.user_id = p_mechanic_id
  LIMIT 20;

  RETURN jsonb_build_object(
    'mechanic', v_mechanic,
    'documents', COALESCE(v_docs, '[]'::jsonb),
    'vetting', COALESCE(v_vetting, '[]'::jsonb),
    'jobs', COALESCE(v_jobs, '[]'::jsonb),
    'reviews', COALESCE(v_reviews, '[]'::jsonb),
    'disputes', COALESCE(v_disputes, '[]'::jsonb),
    'support_requests', COALESCE(v_support, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_mechanic_detail(uuid) TO authenticated;

-- =====================================================
-- 5) FIX admin_get_job_detail (vehicle info from vehicles table)
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_get_job_detail(uuid);

CREATE OR REPLACE FUNCTION public.admin_get_job_detail(p_job_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_job jsonb;
  v_quotes jsonb;
  v_contract jsonb;
  v_events jsonb;
  v_disputes jsonb;
  v_support jsonb;
  v_payments jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT jsonb_build_object(
    'id', j.id,
    'title', j.title::text,
    'description', j.description::text,
    'status', j.status::text,
    'symptom_key', j.symptom_key::text,
    'customer_id', j.customer_id,
    'customer_name', pc.full_name::text,
    'customer_email', pc.email::text,
    'customer_phone', pc.phone::text,
    'hub_id', j.hub_id,
    'hub_name', h.name::text,
    'location_lat', j.location_lat,
    'location_lng', j.location_lng,
    'location_address', j.location_address::text,
    'vehicle_id', j.vehicle_id,
    'vehicle_year', v.year,
    'vehicle_make', v.make::text,
    'vehicle_model', v.model::text,
    'vehicle_nickname', v.nickname::text,
    'preferred_time', j.preferred_time::text,
    'created_at', j.created_at,
    'scheduled_at', j.scheduled_at,
    'completed_at', j.completed_at,
    'cancelled_at', j.cancelled_at
  ) INTO v_job
  FROM public.jobs j
  JOIN public.profiles pc ON pc.id = j.customer_id
  LEFT JOIN public.vehicles v ON v.id = j.vehicle_id
  LEFT JOIN public.service_hubs h ON h.id = j.hub_id
  WHERE j.id = p_job_id;

  IF v_job IS NULL THEN
    RETURN jsonb_build_object('error', 'Job not found');
  END IF;

  SELECT jsonb_agg(jsonb_build_object(
    'id', q.id,
    'mechanic_id', q.mechanic_id,
    'mechanic_name', pm.full_name::text,
    'status', q.status::text,
    'price_cents', COALESCE(q.price_cents, 0),
    'notes', q.notes::text,
    'created_at', q.created_at
  ) ORDER BY q.created_at DESC)
  INTO v_quotes
  FROM public.quotes q
  JOIN public.profiles pm ON pm.id = q.mechanic_id
  WHERE q.job_id = p_job_id;

  SELECT jsonb_build_object(
    'id', jc.id,
    'mechanic_id', jc.mechanic_id,
    'mechanic_name', pm.full_name::text,
    'status', jc.status::text,
    'quoted_price_cents', COALESCE(jc.quoted_price_cents, 0),
    'final_price_cents', COALESCE(jc.final_price_cents, 0),
    'accepted_at', jc.accepted_at,
    'started_at', jc.started_at,
    'completed_at', jc.completed_at
  ) INTO v_contract
  FROM public.job_contracts jc
  JOIN public.profiles pm ON pm.id = jc.mechanic_id
  WHERE jc.job_id = p_job_id
  LIMIT 1;

  SELECT jsonb_agg(jsonb_build_object(
    'id', je.id,
    'event_type', je.event_type::text,
    'actor_id', je.actor_id,
    'actor_role', je.actor_role::text,
    'metadata', je.metadata,
    'created_at', je.created_at
  ) ORDER BY je.created_at DESC)
  INTO v_events
  FROM (
    SELECT * FROM public.job_events WHERE job_id = p_job_id ORDER BY created_at DESC LIMIT 50
  ) je;

  SELECT jsonb_agg(jsonb_build_object(
    'id', d.id,
    'status', d.status::text,
    'category', d.category::text,
    'priority', d.priority::text,
    'created_at', d.created_at,
    'resolved_at', d.resolved_at
  ) ORDER BY d.created_at DESC)
  INTO v_disputes
  FROM public.disputes d WHERE d.job_id = p_job_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', sr.id,
    'status', sr.status::text,
    'category', sr.category::text,
    'message', sr.message::text,
    'created_at', sr.created_at
  ) ORDER BY sr.created_at DESC)
  INTO v_support
  FROM public.support_requests sr WHERE sr.job_id = p_job_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', pay.id,
    'status', pay.status::text,
    'amount_cents', COALESCE(pay.amount_cents, 0),
    'created_at', pay.created_at,
    'paid_at', pay.paid_at,
    'refunded_at', pay.refunded_at
  ) ORDER BY pay.created_at DESC)
  INTO v_payments
  FROM public.payments pay WHERE pay.job_id = p_job_id;

  RETURN jsonb_build_object(
    'job', v_job,
    'quotes', COALESCE(v_quotes, '[]'::jsonb),
    'contract', v_contract,
    'events', COALESCE(v_events, '[]'::jsonb),
    'disputes', COALESCE(v_disputes, '[]'::jsonb),
    'support_requests', COALESCE(v_support, '[]'::jsonb),
    'payments', COALESCE(v_payments, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_job_detail(uuid) TO authenticated;

-- =====================================================
-- 6) SUPPORT REQUESTS - admin_list_support_requests
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_list_support_requests(text, text, int, int);

CREATE OR REPLACE FUNCTION public.admin_list_support_requests(
  p_status text DEFAULT NULL,
  p_category text DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  support_request_id uuid,
  status text,
  category text,
  message text,
  created_at timestamptz,
  last_updated_at timestamptz,
  user_id uuid,
  user_name text,
  user_role text,
  user_email text,
  user_phone text,
  job_id uuid,
  hub_id uuid,
  has_screenshot boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    sr.id as support_request_id,
    sr.status::text,
    sr.category::text,
    sr.message::text,
    sr.created_at,
    sr.updated_at as last_updated_at,
    sr.user_id,
    p.full_name::text as user_name,
    p.role::text as user_role,
    p.email::text as user_email,
    p.phone::text as user_phone,
    sr.job_id,
    j.hub_id,
    (sr.screenshot_url IS NOT NULL) as has_screenshot
  FROM public.support_requests sr
  JOIN public.profiles p ON p.id = sr.user_id
  LEFT JOIN public.jobs j ON j.id = sr.job_id
  WHERE (p_status IS NULL OR sr.status::text = p_status)
    AND (p_category IS NULL OR sr.category::text = p_category)
  ORDER BY sr.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_list_support_requests(text, text, int, int) TO authenticated;

-- =====================================================
-- 7) SUPPORT REQUESTS - admin_get_support_request_details
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_get_support_request_details(uuid);

CREATE OR REPLACE FUNCTION public.admin_get_support_request_details(p_support_request_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_request jsonb;
  v_user jsonb;
  v_job jsonb;
  v_contract jsonb;
  v_payments jsonb;
  v_payouts jsonb;
  v_disputes jsonb;
  v_events jsonb;
  v_job_id uuid;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT jsonb_build_object(
    'id', sr.id,
    'user_id', sr.user_id,
    'job_id', sr.job_id,
    'category', sr.category::text,
    'message', sr.message::text,
    'screenshot_url', sr.screenshot_url::text,
    'status', sr.status::text,
    'metadata', COALESCE(sr.metadata, '{}'::jsonb),
    'created_at', sr.created_at,
    'updated_at', sr.updated_at
  ), sr.job_id
  INTO v_request, v_job_id
  FROM public.support_requests sr
  WHERE sr.id = p_support_request_id;

  IF v_request IS NULL THEN
    RETURN jsonb_build_object('error', 'Support request not found');
  END IF;

  SELECT jsonb_build_object(
    'id', p.id,
    'full_name', p.full_name::text,
    'phone', p.phone::text,
    'email', p.email::text,
    'role', p.role::text,
    'city', p.city::text,
    'state', p.state::text,
    'hub_id', p.hub_id,
    'created_at', p.created_at
  ) INTO v_user
  FROM public.profiles p
  WHERE p.id = (v_request->>'user_id')::uuid;

  IF v_job_id IS NOT NULL THEN
    SELECT jsonb_build_object(
      'id', j.id,
      'title', j.title::text,
      'status', j.status::text,
      'created_at', j.created_at,
      'location_address', j.location_address::text,
      'symptom_key', j.symptom_key::text,
      'accepted_mechanic_id', j.accepted_mechanic_id,
      'customer_id', j.customer_id
    ) INTO v_job
    FROM public.jobs j WHERE j.id = v_job_id;

    SELECT jsonb_build_object(
      'id', jc.id,
      'mechanic_id', jc.mechanic_id,
      'mechanic_name', pm.full_name::text,
      'status', jc.status::text,
      'quoted_price_cents', COALESCE(jc.quoted_price_cents, 0),
      'accepted_at', jc.accepted_at,
      'completed_at', jc.completed_at
    ) INTO v_contract
    FROM public.job_contracts jc
    JOIN public.profiles pm ON pm.id = jc.mechanic_id
    WHERE jc.job_id = v_job_id
    LIMIT 1;

    SELECT jsonb_agg(jsonb_build_object(
      'id', pay.id,
      'status', pay.status::text,
      'amount_cents', COALESCE(pay.amount_cents, 0),
      'paid_at', pay.paid_at,
      'refunded_at', pay.refunded_at
    )) INTO v_payments
    FROM public.payments pay WHERE pay.job_id = v_job_id;

    SELECT jsonb_agg(jsonb_build_object(
      'id', po.id,
      'status', po.status::text,
      'net_amount_cents', COALESCE(po.net_amount_cents, 0),
      'held_at', po.held_at,
      'hold_reason', po.hold_reason::text
    )) INTO v_payouts
    FROM public.payouts po WHERE po.job_id = v_job_id;

    SELECT jsonb_agg(jsonb_build_object(
      'id', d.id,
      'status', d.status::text,
      'category', d.category::text,
      'created_at', d.created_at,
      'resolved_at', d.resolved_at
    )) INTO v_disputes
    FROM public.disputes d WHERE d.job_id = v_job_id;

    SELECT jsonb_agg(jsonb_build_object(
      'id', je.id,
      'event_type', je.event_type::text,
      'actor_role', je.actor_role::text,
      'created_at', je.created_at
    ) ORDER BY je.created_at DESC)
    INTO v_events
    FROM (SELECT * FROM public.job_events WHERE job_id = v_job_id ORDER BY created_at DESC LIMIT 20) je;
  END IF;

  RETURN jsonb_build_object(
    'support_request', v_request,
    'user', v_user,
    'job', v_job,
    'contract', v_contract,
    'payments', COALESCE(v_payments, '[]'::jsonb),
    'payouts', COALESCE(v_payouts, '[]'::jsonb),
    'disputes', COALESCE(v_disputes, '[]'::jsonb),
    'events', COALESCE(v_events, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_support_request_details(uuid) TO authenticated;

-- =====================================================
-- 8) SUPPORT REQUESTS - admin_update_support_request_status
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_update_support_request_status(uuid, text, text);

CREATE OR REPLACE FUNCTION public.admin_update_support_request_status(
  p_support_request_id uuid,
  p_status text,
  p_internal_note text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_old_status text;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('success', false, 'error', 'Admin access required');
  END IF;

  SELECT status INTO v_old_status FROM public.support_requests WHERE id = p_support_request_id;
  
  IF v_old_status IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Support request not found');
  END IF;

  UPDATE public.support_requests
  SET status = p_status, updated_at = now()
  WHERE id = p_support_request_id;

  INSERT INTO public.audit_log (actor_id, actor_type, action, entity_type, entity_id, metadata)
  VALUES (
    auth.uid(),
    'admin',
    'UPDATE_SUPPORT_REQUEST_STATUS',
    'support_request',
    p_support_request_id,
    jsonb_build_object('old_status', v_old_status, 'new_status', p_status, 'note', p_internal_note)
  );

  RETURN jsonb_build_object('success', true);
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_update_support_request_status(uuid, text, text) TO authenticated;

-- =====================================================
-- 9) CUSTOMERS - admin_list_customers
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_list_customers(int, int, text);

CREATE OR REPLACE FUNCTION public.admin_list_customers(
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0,
  p_query text DEFAULT NULL
)
RETURNS TABLE (
  customer_id uuid,
  full_name text,
  email text,
  phone text,
  city text,
  state text,
  hub_id uuid,
  created_at timestamptz,
  total_jobs bigint,
  completed_jobs bigint,
  total_spent_cents bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    p.id as customer_id,
    p.full_name::text,
    p.email::text,
    p.phone::text,
    p.city::text,
    p.state::text,
    p.hub_id,
    p.created_at,
    (SELECT COUNT(*) FROM public.jobs j WHERE j.customer_id = p.id) as total_jobs,
    (SELECT COUNT(*) FROM public.jobs j WHERE j.customer_id = p.id AND j.status = 'completed') as completed_jobs,
    COALESCE((SELECT SUM(pay.amount_cents) FROM public.payments pay 
              JOIN public.jobs j ON j.id = pay.job_id 
              WHERE j.customer_id = p.id AND pay.paid_at IS NOT NULL), 0) as total_spent_cents
  FROM public.profiles p
  WHERE p.role = 'customer'
    AND (p_query IS NULL OR 
         p.full_name ILIKE '%' || p_query || '%' OR 
         p.email ILIKE '%' || p_query || '%' OR
         p.phone ILIKE '%' || p_query || '%')
  ORDER BY p.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_list_customers(int, int, text) TO authenticated;

-- =====================================================
-- 10) CUSTOMERS - admin_get_customer_details
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_get_customer_details(uuid);

CREATE OR REPLACE FUNCTION public.admin_get_customer_details(p_customer_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_profile jsonb;
  v_jobs jsonb;
  v_payments jsonb;
  v_support jsonb;
  v_disputes jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT jsonb_build_object(
    'id', p.id,
    'full_name', p.full_name::text,
    'email', p.email::text,
    'phone', p.phone::text,
    'role', p.role::text,
    'city', p.city::text,
    'state', p.state::text,
    'hub_id', p.hub_id,
    'avatar_url', p.avatar_url::text,
    'created_at', p.created_at,
    'updated_at', p.updated_at
  ) INTO v_profile
  FROM public.profiles p
  WHERE p.id = p_customer_id;

  IF v_profile IS NULL THEN
    RETURN jsonb_build_object('error', 'Customer not found');
  END IF;

  SELECT jsonb_agg(jsonb_build_object(
    'id', j.id,
    'title', j.title::text,
    'status', j.status::text,
    'created_at', j.created_at,
    'accepted_mechanic_id', j.accepted_mechanic_id,
    'completed_at', j.completed_at
  ) ORDER BY j.created_at DESC)
  INTO v_jobs
  FROM (SELECT * FROM public.jobs WHERE customer_id = p_customer_id ORDER BY created_at DESC LIMIT 20) j;

  SELECT jsonb_agg(jsonb_build_object(
    'id', pay.id,
    'job_id', pay.job_id,
    'amount_cents', COALESCE(pay.amount_cents, 0),
    'status', pay.status::text,
    'paid_at', pay.paid_at,
    'refunded_at', pay.refunded_at
  ) ORDER BY pay.created_at DESC)
  INTO v_payments
  FROM (SELECT * FROM public.payments WHERE job_id IN (SELECT id FROM public.jobs WHERE customer_id = p_customer_id) ORDER BY created_at DESC LIMIT 10) pay;

  SELECT jsonb_agg(jsonb_build_object(
    'id', sr.id,
    'category', sr.category::text,
    'message', sr.message::text,
    'status', sr.status::text,
    'created_at', sr.created_at
  ) ORDER BY sr.created_at DESC)
  INTO v_support
  FROM (SELECT * FROM public.support_requests WHERE user_id = p_customer_id ORDER BY created_at DESC LIMIT 10) sr;

  SELECT jsonb_agg(jsonb_build_object(
    'id', d.id,
    'job_id', d.job_id,
    'category', d.category::text,
    'status', d.status::text,
    'created_at', d.created_at,
    'resolved_at', d.resolved_at
  ) ORDER BY d.created_at DESC)
  INTO v_disputes
  FROM (SELECT d.* FROM public.disputes d JOIN public.jobs j ON j.id = d.job_id WHERE j.customer_id = p_customer_id ORDER BY d.created_at DESC LIMIT 10) d;

  RETURN jsonb_build_object(
    'profile', v_profile,
    'jobs', COALESCE(v_jobs, '[]'::jsonb),
    'payments', COALESCE(v_payments, '[]'::jsonb),
    'support_requests', COALESCE(v_support, '[]'::jsonb),
    'disputes', COALESCE(v_disputes, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_customer_details(uuid) TO authenticated;

-- =====================================================
-- 11) FIX admin_get_metrics (already has try/catch for lead_decisions)
-- No changes needed since it already handles missing table
-- =====================================================

-- =====================================================
-- 12) Ensure RLS policies allow admin access to support_requests
-- =====================================================
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE tablename = 'support_requests' AND policyname = 'support_requests_admin_all'
  ) THEN
    CREATE POLICY support_requests_admin_all ON public.support_requests
      FOR ALL TO authenticated
      USING (public.is_admin(auth.uid()))
      WITH CHECK (public.is_admin(auth.uid()));
  END IF;
END $$;
\n-- ===================================================================
-- END: 20260120000008_phase41_fix_pack.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260120000009_phase42_fix_pack.sql
-- ===================================================================\n
-- =====================================================
-- PHASE 4.2 FIX PACK - Remaining Schema Errors
-- =====================================================
-- Fixes:
-- A) v.question_key -> v.prompt_key in mechanic vetting query
-- B) Removes decision_reason dependency from metrics
-- C) jc.final_price_cents -> uses j.final_price_cents or jc.subtotal_cents
-- =====================================================

-- =====================================================
-- A) FIX admin_get_mechanic_detail - vetting uses prompt_key not question_key
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_get_mechanic_detail(uuid);

CREATE OR REPLACE FUNCTION public.admin_get_mechanic_detail(p_mechanic_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic jsonb;
  v_docs jsonb;
  v_vetting jsonb;
  v_jobs jsonb;
  v_reviews jsonb;
  v_disputes jsonb;
  v_support jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT jsonb_build_object(
    'id', mp.id,
    'full_name', p.full_name::text,
    'email', p.email::text,
    'phone', p.phone::text,
    'role', p.role::text,
    'city', p.city::text,
    'state', p.state::text,
    'hub_id', p.hub_id,
    'hub_name', h.name::text,
    'verification_status', mp.verification_status::text,
    'verification_reason', mp.verification_reason::text,
    'tier', COALESCE(mp.tier, 'bronze')::text,
    'bio', mp.bio::text,
    'years_experience', mp.years_experience,
    'hourly_rate_cents', mp.hourly_rate_cents,
    'service_radius_km', mp.service_radius_km,
    'mobile_service', mp.mobile_service,
    'is_available', mp.is_available,
    'rating_avg', mp.rating_avg,
    'rating_count', COALESCE(mp.rating_count, 0),
    'jobs_completed', COALESCE(mp.jobs_completed, 0),
    'stripe_account_id', mp.stripe_account_id::text,
    'stripe_onboarding_complete', mp.stripe_onboarding_complete,
    'created_at', mp.created_at,
    'updated_at', mp.updated_at
  ) INTO v_mechanic
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON p.id = mp.id
  LEFT JOIN public.service_hubs h ON h.id = p.hub_id
  WHERE mp.id = p_mechanic_id;

  IF v_mechanic IS NULL THEN
    RETURN jsonb_build_object('error', 'Mechanic not found');
  END IF;

  SELECT jsonb_agg(jsonb_build_object(
    'id', d.id,
    'doc_type', d.doc_type::text,
    'status', d.status::text,
    'uploaded_at', d.uploaded_at,
    'reviewed_at', d.reviewed_at,
    'review_notes', d.review_notes::text
  ) ORDER BY d.uploaded_at DESC)
  INTO v_docs
  FROM public.mechanic_verification_documents d
  WHERE d.mechanic_id = p_mechanic_id;

  -- FIXED: Use prompt_key, prompt_text, response_text (NOT question_key)
  SELECT jsonb_agg(jsonb_build_object(
    'id', v.id,
    'prompt_key', v.prompt_key::text,
    'prompt_text', v.prompt_text::text,
    'response_text', v.response_text::text,
    'created_at', v.created_at
  ) ORDER BY v.created_at)
  INTO v_vetting
  FROM public.mechanic_vetting_responses v
  WHERE v.mechanic_id = p_mechanic_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', j.id,
    'title', j.title::text,
    'status', j.status::text,
    'customer_name', pc.full_name::text,
    'created_at', j.created_at,
    'completed_at', j.completed_at
  ) ORDER BY j.created_at DESC)
  INTO v_jobs
  FROM (
    SELECT j.* FROM public.jobs j
    JOIN public.job_contracts jc ON jc.job_id = j.id
    WHERE jc.mechanic_id = p_mechanic_id
    ORDER BY j.created_at DESC
    LIMIT 20
  ) j
  JOIN public.profiles pc ON pc.id = j.customer_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', r.id,
    'overall_rating', r.overall_rating,
    'comment', r.comment::text,
    'reviewer_name', pr.full_name::text,
    'created_at', r.created_at
  ) ORDER BY r.created_at DESC)
  INTO v_reviews
  FROM public.reviews r
  JOIN public.profiles pr ON pr.id = r.reviewer_id
  WHERE r.reviewee_id = p_mechanic_id
  LIMIT 20;

  SELECT jsonb_agg(jsonb_build_object(
    'id', d.id,
    'job_id', d.job_id,
    'status', d.status::text,
    'category', d.category::text,
    'created_at', d.created_at,
    'resolved_at', d.resolved_at
  ) ORDER BY d.created_at DESC)
  INTO v_disputes
  FROM public.disputes d
  JOIN public.job_contracts jc ON jc.job_id = d.job_id
  WHERE jc.mechanic_id = p_mechanic_id
  LIMIT 20;

  SELECT jsonb_agg(jsonb_build_object(
    'id', sr.id,
    'job_id', sr.job_id,
    'category', sr.category::text,
    'status', sr.status::text,
    'message', sr.message::text,
    'created_at', sr.created_at
  ) ORDER BY sr.created_at DESC)
  INTO v_support
  FROM public.support_requests sr
  WHERE sr.user_id = p_mechanic_id
  LIMIT 20;

  RETURN jsonb_build_object(
    'mechanic', v_mechanic,
    'documents', COALESCE(v_docs, '[]'::jsonb),
    'vetting', COALESCE(v_vetting, '[]'::jsonb),
    'jobs', COALESCE(v_jobs, '[]'::jsonb),
    'reviews', COALESCE(v_reviews, '[]'::jsonb),
    'disputes', COALESCE(v_disputes, '[]'::jsonb),
    'support_requests', COALESCE(v_support, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_mechanic_detail(uuid) TO authenticated;

-- =====================================================
-- B) FIX admin_get_metrics - Remove decision_reason dependency entirely
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_get_metrics(uuid, int);

CREATE OR REPLACE FUNCTION public.admin_get_metrics(
  p_hub_id uuid DEFAULT NULL,
  p_days int DEFAULT 14
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_start_date timestamptz;
  v_daily_jobs jsonb;
  v_daily_completed jsonb;
  v_total_jobs bigint;
  v_total_completed bigint;
  v_total_quotes bigint;
  v_total_accepted bigint;
  v_total_disputes bigint;
  v_total_refunds bigint;
  v_total_tickets bigint;
  v_quotes_per_job numeric;
  v_acceptance_rate numeric;
  v_completion_rate numeric;
  v_dispute_rate numeric;
  v_refund_rate numeric;
  v_tickets_per_job numeric;
  v_result jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  v_start_date := now() - (p_days || ' days')::interval;

  -- Daily jobs created
  SELECT jsonb_agg(jsonb_build_object('date', day::date, 'count', cnt) ORDER BY day)
  INTO v_daily_jobs
  FROM (
    SELECT date_trunc('day', j.created_at) as day, COUNT(*) as cnt
    FROM public.jobs j
    WHERE j.created_at >= v_start_date
      AND (p_hub_id IS NULL OR j.hub_id = p_hub_id)
    GROUP BY date_trunc('day', j.created_at)
  ) sub;

  -- Daily jobs completed
  SELECT jsonb_agg(jsonb_build_object('date', day::date, 'count', cnt) ORDER BY day)
  INTO v_daily_completed
  FROM (
    SELECT date_trunc('day', j.completed_at) as day, COUNT(*) as cnt
    FROM public.jobs j
    WHERE j.completed_at >= v_start_date
      AND j.status = 'completed'
      AND (p_hub_id IS NULL OR j.hub_id = p_hub_id)
    GROUP BY date_trunc('day', j.completed_at)
  ) sub;

  -- Totals
  SELECT COUNT(*) INTO v_total_jobs
  FROM public.jobs j
  WHERE j.created_at >= v_start_date
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id);

  SELECT COUNT(*) INTO v_total_completed
  FROM public.jobs j
  WHERE j.completed_at >= v_start_date
    AND j.status = 'completed'
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id);

  SELECT COUNT(*) INTO v_total_quotes
  FROM public.quotes q
  JOIN public.jobs j ON j.id = q.job_id
  WHERE q.created_at >= v_start_date
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id);

  SELECT COUNT(*) INTO v_total_accepted
  FROM public.job_contracts jc
  JOIN public.jobs j ON j.id = jc.job_id
  WHERE jc.created_at >= v_start_date
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id);

  SELECT COUNT(*) INTO v_total_disputes
  FROM public.disputes d
  JOIN public.jobs j ON j.id = d.job_id
  WHERE d.created_at >= v_start_date
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id);

  -- Refunds: disputes with customer_refund_cents > 0 OR payments with refunded_at
  SELECT COUNT(*) INTO v_total_refunds
  FROM (
    SELECT d.id FROM public.disputes d
    JOIN public.jobs j ON j.id = d.job_id
    WHERE d.created_at >= v_start_date
      AND d.customer_refund_cents > 0
      AND (p_hub_id IS NULL OR j.hub_id = p_hub_id)
    UNION
    SELECT p.id FROM public.payments p
    JOIN public.jobs j ON j.id = p.job_id
    WHERE p.refunded_at >= v_start_date
      AND (p_hub_id IS NULL OR j.hub_id = p_hub_id)
  ) refunds;

  SELECT COUNT(*) INTO v_total_tickets
  FROM public.support_requests sr
  LEFT JOIN public.jobs j ON j.id = sr.job_id
  WHERE sr.created_at >= v_start_date
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id OR sr.job_id IS NULL);

  -- Calculate rates
  v_quotes_per_job := CASE WHEN v_total_jobs > 0 THEN ROUND(v_total_quotes::numeric / v_total_jobs, 2) ELSE 0 END;
  v_acceptance_rate := CASE WHEN v_total_quotes > 0 THEN ROUND(v_total_accepted::numeric / v_total_quotes * 100, 1) ELSE 0 END;
  v_completion_rate := CASE WHEN v_total_jobs > 0 THEN ROUND(v_total_completed::numeric / v_total_jobs * 100, 1) ELSE 0 END;
  v_dispute_rate := CASE WHEN v_total_completed > 0 THEN ROUND(v_total_disputes::numeric / v_total_completed * 100, 1) ELSE 0 END;
  v_refund_rate := CASE WHEN v_total_completed > 0 THEN ROUND(v_total_refunds::numeric / v_total_completed * 100, 1) ELSE 0 END;
  v_tickets_per_job := CASE WHEN v_total_jobs > 0 THEN ROUND(v_total_tickets::numeric / v_total_jobs, 2) ELSE 0 END;

  -- NOTE: decision_reason removed - that table/column does not exist
  -- decline_reasons is empty since we don't have lead_decisions table
  
  v_result := jsonb_build_object(
    'period_days', p_days,
    'hub_id', p_hub_id,
    'daily_jobs_created', COALESCE(v_daily_jobs, '[]'::jsonb),
    'daily_jobs_completed', COALESCE(v_daily_completed, '[]'::jsonb),
    'totals', jsonb_build_object(
      'jobs_created', v_total_jobs,
      'jobs_completed', v_total_completed,
      'quotes', v_total_quotes,
      'accepted', v_total_accepted,
      'disputes', v_total_disputes,
      'refunds', v_total_refunds,
      'support_tickets', v_total_tickets
    ),
    'rates', jsonb_build_object(
      'quotes_per_job', v_quotes_per_job,
      'acceptance_rate', v_acceptance_rate,
      'completion_rate', v_completion_rate,
      'dispute_rate', v_dispute_rate,
      'refund_rate', v_refund_rate,
      'tickets_per_job', v_tickets_per_job
    ),
    'decline_reasons', '[]'::jsonb
  );

  RETURN v_result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_metrics(uuid, int) TO authenticated;

-- =====================================================
-- C) FIX admin_get_job_detail - Use j.final_price_cents and jc.subtotal_cents
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_get_job_detail(uuid);

CREATE OR REPLACE FUNCTION public.admin_get_job_detail(p_job_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_job jsonb;
  v_quotes jsonb;
  v_contract jsonb;
  v_events jsonb;
  v_disputes jsonb;
  v_support jsonb;
  v_payments jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT jsonb_build_object(
    'id', j.id,
    'title', j.title::text,
    'description', j.description::text,
    'status', j.status::text,
    'symptom_key', j.symptom_key::text,
    'customer_id', j.customer_id,
    'customer_name', pc.full_name::text,
    'customer_email', pc.email::text,
    'customer_phone', pc.phone::text,
    'hub_id', j.hub_id,
    'hub_name', h.name::text,
    'location_lat', j.location_lat,
    'location_lng', j.location_lng,
    'location_address', j.location_address::text,
    'vehicle_id', j.vehicle_id,
    'vehicle_year', v.year,
    'vehicle_make', v.make::text,
    'vehicle_model', v.model::text,
    'vehicle_nickname', v.nickname::text,
    'preferred_time', j.preferred_time::text,
    'final_price_cents', j.final_price_cents,
    'created_at', j.created_at,
    'scheduled_at', j.scheduled_at,
    'completed_at', j.completed_at,
    'cancelled_at', j.cancelled_at
  ) INTO v_job
  FROM public.jobs j
  JOIN public.profiles pc ON pc.id = j.customer_id
  LEFT JOIN public.vehicles v ON v.id = j.vehicle_id
  LEFT JOIN public.service_hubs h ON h.id = j.hub_id
  WHERE j.id = p_job_id;

  IF v_job IS NULL THEN
    RETURN jsonb_build_object('error', 'Job not found');
  END IF;

  SELECT jsonb_agg(jsonb_build_object(
    'id', q.id,
    'mechanic_id', q.mechanic_id,
    'mechanic_name', pm.full_name::text,
    'status', q.status::text,
    'price_cents', COALESCE(q.price_cents, 0),
    'notes', q.notes::text,
    'created_at', q.created_at
  ) ORDER BY q.created_at DESC)
  INTO v_quotes
  FROM public.quotes q
  JOIN public.profiles pm ON pm.id = q.mechanic_id
  WHERE q.job_id = p_job_id;

  -- FIXED: Use jc.quoted_price_cents and jc.subtotal_cents (NOT jc.final_price_cents)
  SELECT jsonb_build_object(
    'id', jc.id,
    'mechanic_id', jc.mechanic_id,
    'mechanic_name', pm.full_name::text,
    'status', jc.status::text,
    'quoted_price_cents', COALESCE(jc.quoted_price_cents, 0),
    'subtotal_cents', COALESCE(jc.subtotal_cents, 0),
    'total_customer_cents', COALESCE(jc.total_customer_cents, 0),
    'mechanic_payout_cents', COALESCE(jc.mechanic_payout_cents, 0),
    'accepted_at', jc.terms_accepted_at,
    'started_at', jc.payment_authorized_at,
    'completed_at', jc.payment_captured_at
  ) INTO v_contract
  FROM public.job_contracts jc
  JOIN public.profiles pm ON pm.id = jc.mechanic_id
  WHERE jc.job_id = p_job_id
  LIMIT 1;

  SELECT jsonb_agg(jsonb_build_object(
    'id', je.id,
    'event_type', je.event_type::text,
    'actor_id', je.actor_id,
    'actor_role', je.actor_role::text,
    'metadata', je.metadata,
    'created_at', je.created_at
  ) ORDER BY je.created_at DESC)
  INTO v_events
  FROM (
    SELECT * FROM public.job_events WHERE job_id = p_job_id ORDER BY created_at DESC LIMIT 50
  ) je;

  SELECT jsonb_agg(jsonb_build_object(
    'id', d.id,
    'status', d.status::text,
    'category', d.category::text,
    'priority', d.priority::text,
    'created_at', d.created_at,
    'resolved_at', d.resolved_at
  ) ORDER BY d.created_at DESC)
  INTO v_disputes
  FROM public.disputes d WHERE d.job_id = p_job_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', sr.id,
    'status', sr.status::text,
    'category', sr.category::text,
    'message', sr.message::text,
    'created_at', sr.created_at
  ) ORDER BY sr.created_at DESC)
  INTO v_support
  FROM public.support_requests sr WHERE sr.job_id = p_job_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', pay.id,
    'status', pay.status::text,
    'amount_cents', COALESCE(pay.amount_cents, 0),
    'created_at', pay.created_at,
    'paid_at', pay.paid_at,
    'refunded_at', pay.refunded_at
  ) ORDER BY pay.created_at DESC)
  INTO v_payments
  FROM public.payments pay WHERE pay.job_id = p_job_id;

  RETURN jsonb_build_object(
    'job', v_job,
    'quotes', COALESCE(v_quotes, '[]'::jsonb),
    'contract', v_contract,
    'events', COALESCE(v_events, '[]'::jsonb),
    'disputes', COALESCE(v_disputes, '[]'::jsonb),
    'support_requests', COALESCE(v_support, '[]'::jsonb),
    'payments', COALESCE(v_payments, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_job_detail(uuid) TO authenticated;\n-- ===================================================================
-- END: 20260120000009_phase42_fix_pack.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260120000010_platform_terms_phase45.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: Platform Terms + Job Acknowledgement (Phase 4.5)
-- =====================================================
-- Purpose: Reduce liability and improve enforceability
-- - Platform terms acceptance (account-level)
-- - Job acknowledgement (job-level)
-- =====================================================

BEGIN;

-- =====================================================
-- TABLE: platform_terms_versions
-- =====================================================
CREATE TABLE IF NOT EXISTS public.platform_terms_versions (
  version text PRIMARY KEY,
  role text NOT NULL DEFAULT 'all' CHECK (role IN ('customer', 'mechanic', 'all')),
  title text NOT NULL,
  summary text NOT NULL,
  full_text text NOT NULL,
  is_active boolean NOT NULL DEFAULT true,
  published_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.platform_terms_versions IS 'Versioned platform terms of service';

-- =====================================================
-- TABLE: platform_terms_acceptances
-- =====================================================
CREATE TABLE IF NOT EXISTS public.platform_terms_acceptances (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  role text NOT NULL CHECK (role IN ('customer', 'mechanic')),
  terms_version text NOT NULL REFERENCES public.platform_terms_versions(version),
  accepted_at timestamptz NOT NULL DEFAULT now(),
  ip_address inet,
  user_agent text,
  UNIQUE(user_id, terms_version)
);

COMMENT ON TABLE public.platform_terms_acceptances IS 'Immutable record of user terms acceptances';

CREATE INDEX IF NOT EXISTS idx_platform_terms_acceptances_user 
  ON public.platform_terms_acceptances(user_id);

-- =====================================================
-- TABLE: job_acknowledgements
-- =====================================================
CREATE TABLE IF NOT EXISTS public.job_acknowledgements (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  contract_id uuid REFERENCES public.job_contracts(id) ON DELETE SET NULL,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  role text NOT NULL CHECK (role IN ('customer', 'mechanic')),
  acknowledgement_version text NOT NULL,
  acknowledgement_text text NOT NULL,
  accepted_at timestamptz NOT NULL DEFAULT now(),
  ip_address inet,
  user_agent text,
  UNIQUE(job_id, user_id, role, acknowledgement_version)
);

COMMENT ON TABLE public.job_acknowledgements IS 'Immutable record of job-specific acknowledgements';

CREATE INDEX IF NOT EXISTS idx_job_acknowledgements_job 
  ON public.job_acknowledgements(job_id);
CREATE INDEX IF NOT EXISTS idx_job_acknowledgements_user 
  ON public.job_acknowledgements(user_id);

-- =====================================================
-- ADD COLUMNS TO job_contracts
-- =====================================================
ALTER TABLE public.job_contracts 
  ADD COLUMN IF NOT EXISTS customer_acknowledged_at timestamptz,
  ADD COLUMN IF NOT EXISTS mechanic_acknowledged_at timestamptz;

-- =====================================================
-- RLS: platform_terms_versions
-- =====================================================
ALTER TABLE public.platform_terms_versions ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "terms_versions_select_authenticated" ON public.platform_terms_versions;
CREATE POLICY "terms_versions_select_authenticated" ON public.platform_terms_versions
  FOR SELECT TO authenticated USING (true);

DROP POLICY IF EXISTS "terms_versions_admin_insert" ON public.platform_terms_versions;
CREATE POLICY "terms_versions_admin_insert" ON public.platform_terms_versions
  FOR INSERT TO authenticated WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "terms_versions_admin_update" ON public.platform_terms_versions;
CREATE POLICY "terms_versions_admin_update" ON public.platform_terms_versions
  FOR UPDATE TO authenticated USING (public.is_admin());

-- =====================================================
-- RLS: platform_terms_acceptances
-- =====================================================
ALTER TABLE public.platform_terms_acceptances ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "terms_acceptances_select_own" ON public.platform_terms_acceptances;
CREATE POLICY "terms_acceptances_select_own" ON public.platform_terms_acceptances
  FOR SELECT TO authenticated 
  USING (user_id = auth.uid() OR public.is_admin());

DROP POLICY IF EXISTS "terms_acceptances_insert_own" ON public.platform_terms_acceptances;
CREATE POLICY "terms_acceptances_insert_own" ON public.platform_terms_acceptances
  FOR INSERT TO authenticated 
  WITH CHECK (user_id = auth.uid());

-- No UPDATE/DELETE policies - acceptances are immutable

-- =====================================================
-- RLS: job_acknowledgements
-- =====================================================
ALTER TABLE public.job_acknowledgements ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "job_ack_select_own_or_admin" ON public.job_acknowledgements;
CREATE POLICY "job_ack_select_own_or_admin" ON public.job_acknowledgements
  FOR SELECT TO authenticated 
  USING (
    user_id = auth.uid() 
    OR public.is_admin()
    OR EXISTS (
      SELECT 1 FROM public.jobs j 
      WHERE j.id = job_id 
      AND (j.customer_id = auth.uid() OR j.accepted_mechanic_id = auth.uid())
    )
  );

DROP POLICY IF EXISTS "job_ack_insert_own" ON public.job_acknowledgements;
CREATE POLICY "job_ack_insert_own" ON public.job_acknowledgements
  FOR INSERT TO authenticated 
  WITH CHECK (
    user_id = auth.uid()
    AND EXISTS (
      SELECT 1 FROM public.jobs j 
      WHERE j.id = job_id 
      AND (
        (role = 'customer' AND j.customer_id = auth.uid())
        OR (role = 'mechanic' AND j.accepted_mechanic_id = auth.uid())
      )
    )
  );

-- No UPDATE/DELETE policies - acknowledgements are immutable

-- =====================================================
-- SEED: Initial platform terms version
-- =====================================================
INSERT INTO public.platform_terms_versions (version, role, title, summary, full_text, is_active)
VALUES (
  '2026.01',
  'all',
  'WrenchGo Platform Terms of Service',
  'By using WrenchGo, you agree to our terms governing the marketplace relationship between customers and independent mechanics.',
  E'WRENCHGO PLATFORM TERMS OF SERVICE\n\nVersion 2026.01\nEffective Date: January 2026\n\n1. ACCEPTANCE OF TERMS\nBy accessing or using the WrenchGo platform, you agree to be bound by these Terms of Service.\n\n2. PLATFORM NATURE\nWrenchGo is a marketplace connecting customers with independent mobile mechanics. WrenchGo does not employ mechanics and is not responsible for the quality of work performed.\n\n3. INDEPENDENT CONTRACTORS\nMechanics on the platform are independent contractors, not employees of WrenchGo. They are solely responsible for their work, tools, insurance, and compliance with applicable laws.\n\n4. CUSTOMER RESPONSIBILITIES\n- Provide accurate vehicle and location information\n- Ensure safe, accessible workspace for mechanic\n- Authorize work and approve any additional charges\n- Make timely payment through the platform\n\n5. MECHANIC RESPONSIBILITIES\n- Maintain required licenses and insurance\n- Perform work professionally and safely\n- Communicate clearly about scope and pricing\n- Process all payments through the platform\n\n6. PAYMENTS AND FEES\nAll payments must be processed through WrenchGo. Off-platform payments are prohibited and may result in account termination.\n\n7. DISPUTES\nDisputes should be reported through the app. WrenchGo will mediate but final resolution may require external arbitration.\n\n8. LIMITATION OF LIABILITY\nWrenchGo''s liability is limited to platform fees paid. We are not liable for work quality, property damage, or personal injury.\n\n9. CHANGES TO TERMS\nWe may update these terms. Continued use constitutes acceptance of updated terms.\n\n10. CONTACT\nFor questions, contact support@wrenchgo.com',
  true
) ON CONFLICT (version) DO NOTHING;

-- =====================================================
-- RPC: get_active_terms
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_active_terms(p_role text)
RETURNS TABLE (
  version text,
  title text,
  summary text,
  full_text text,
  published_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ptv.version,
    ptv.title,
    ptv.summary,
    ptv.full_text,
    ptv.published_at
  FROM public.platform_terms_versions ptv
  WHERE ptv.is_active = true
    AND (ptv.role = 'all' OR ptv.role = p_role)
  ORDER BY ptv.published_at DESC
  LIMIT 1;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_active_terms(text) TO authenticated;

-- =====================================================
-- RPC: accept_platform_terms
-- =====================================================
CREATE OR REPLACE FUNCTION public.accept_platform_terms(
  p_terms_version text,
  p_role text,
  p_user_agent text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_acceptance_id uuid;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  -- Validate terms version exists and is active
  IF NOT EXISTS (
    SELECT 1 FROM public.platform_terms_versions 
    WHERE version = p_terms_version 
    AND is_active = true
    AND (role = 'all' OR role = p_role)
  ) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid terms version');
  END IF;

  -- Insert acceptance (idempotent via ON CONFLICT)
  INSERT INTO public.platform_terms_acceptances (user_id, role, terms_version, user_agent)
  VALUES (v_user_id, p_role, p_terms_version, p_user_agent)
  ON CONFLICT (user_id, terms_version) DO NOTHING
  RETURNING id INTO v_acceptance_id;

  RETURN jsonb_build_object(
    'success', true,
    'acceptance_id', COALESCE(v_acceptance_id, (
      SELECT id FROM public.platform_terms_acceptances 
      WHERE user_id = v_user_id AND terms_version = p_terms_version
    ))
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.accept_platform_terms(text, text, text) TO authenticated;

-- =====================================================
-- RPC: check_terms_accepted
-- =====================================================
CREATE OR REPLACE FUNCTION public.check_terms_accepted(p_role text)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_active_version text;
  v_accepted boolean;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('accepted', false, 'error', 'Not authenticated');
  END IF;

  -- Get active version for this role
  SELECT version INTO v_active_version
  FROM public.platform_terms_versions
  WHERE is_active = true AND (role = 'all' OR role = p_role)
  ORDER BY published_at DESC
  LIMIT 1;

  IF v_active_version IS NULL THEN
    RETURN jsonb_build_object('accepted', true, 'version', NULL);
  END IF;

  -- Check if accepted
  SELECT EXISTS (
    SELECT 1 FROM public.platform_terms_acceptances
    WHERE user_id = v_user_id AND terms_version = v_active_version
  ) INTO v_accepted;

  RETURN jsonb_build_object(
    'accepted', v_accepted,
    'version', v_active_version,
    'requires_acceptance', NOT v_accepted
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.check_terms_accepted(text) TO authenticated;

-- =====================================================
-- RPC: require_terms_or_throw
-- =====================================================
CREATE OR REPLACE FUNCTION public.require_terms_or_throw(p_role text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_active_version text;
  v_accepted boolean;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Get active version for this role
  SELECT version INTO v_active_version
  FROM public.platform_terms_versions
  WHERE is_active = true AND (role = 'all' OR role = p_role)
  ORDER BY published_at DESC
  LIMIT 1;

  -- If no active terms, allow
  IF v_active_version IS NULL THEN
    RETURN true;
  END IF;

  -- Check if accepted
  SELECT EXISTS (
    SELECT 1 FROM public.platform_terms_acceptances
    WHERE user_id = v_user_id AND terms_version = v_active_version
  ) INTO v_accepted;

  IF NOT v_accepted THEN
    RAISE EXCEPTION 'Platform terms not accepted. Version: %', v_active_version;
  END IF;

  RETURN true;
END;
$$;

GRANT EXECUTE ON FUNCTION public.require_terms_or_throw(text) TO authenticated;

-- =====================================================
-- RPC: accept_job_acknowledgement
-- =====================================================
CREATE OR REPLACE FUNCTION public.accept_job_acknowledgement(
  p_job_id uuid,
  p_role text,
  p_ack_version text,
  p_ack_text text,
  p_user_agent text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_job RECORD;
  v_contract_id uuid;
  v_ack_id uuid;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  -- Get job and validate user is part of it
  SELECT j.*, jc.id as contract_id
  INTO v_job
  FROM public.jobs j
  LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
  WHERE j.id = p_job_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job not found');
  END IF;

  -- Validate user is correct party
  IF p_role = 'customer' AND v_job.customer_id != v_user_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized as customer');
  END IF;

  IF p_role = 'mechanic' AND v_job.accepted_mechanic_id != v_user_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized as mechanic');
  END IF;

  v_contract_id := v_job.contract_id;

  -- Insert acknowledgement
  INSERT INTO public.job_acknowledgements (
    job_id, contract_id, user_id, role, acknowledgement_version, acknowledgement_text, user_agent
  ) VALUES (
    p_job_id, v_contract_id, v_user_id, p_role, p_ack_version, p_ack_text, p_user_agent
  )
  ON CONFLICT (job_id, user_id, role, acknowledgement_version) DO NOTHING
  RETURNING id INTO v_ack_id;

  -- Update contract timestamps if contract exists
  IF v_contract_id IS NOT NULL THEN
    IF p_role = 'customer' THEN
      UPDATE public.job_contracts 
      SET customer_acknowledged_at = COALESCE(customer_acknowledged_at, now())
      WHERE id = v_contract_id;
    ELSIF p_role = 'mechanic' THEN
      UPDATE public.job_contracts 
      SET mechanic_acknowledged_at = COALESCE(mechanic_acknowledged_at, now())
      WHERE id = v_contract_id;
    END IF;
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'acknowledgement_id', COALESCE(v_ack_id, (
      SELECT id FROM public.job_acknowledgements 
      WHERE job_id = p_job_id AND user_id = v_user_id AND role = p_role AND acknowledgement_version = p_ack_version
    ))
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.accept_job_acknowledgement(uuid, text, text, text, text) TO authenticated;

-- =====================================================
-- UPDATED RPC: accept_quote_and_create_contract (with enforcement)
-- =====================================================
CREATE OR REPLACE FUNCTION accept_quote_and_create_contract(
  p_quote_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_quote RECORD;
  v_job RECORD;
  v_contract_id uuid;
  v_progress_id uuid;
  v_platform_fee_cents int := 1500;
  v_commission_cents int;
  v_total_customer_cents int;
  v_mechanic_payout_cents int;
  v_line_item_id uuid;
  v_terms_check jsonb;
BEGIN
  -- ENFORCEMENT: Check platform terms accepted
  v_terms_check := public.check_terms_accepted('customer');
  IF NOT (v_terms_check->>'accepted')::boolean THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Please accept platform terms first',
      'requires_terms', true,
      'terms_version', v_terms_check->>'version'
    );
  END IF;

  -- Get quote with lock
  SELECT q.*, j.customer_id as job_customer_id, j.status as job_status, j.id as actual_job_id
  INTO v_quote
  FROM public.quotes q
  JOIN public.jobs j ON j.id = q.job_id
  WHERE q.id = p_quote_id
  FOR UPDATE OF q, j;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote not found');
  END IF;
  
  IF v_quote.job_customer_id != p_customer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  IF v_quote.status != 'pending' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote is no longer available');
  END IF;
  
  IF v_quote.job_status NOT IN ('searching', 'quoted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job is no longer accepting quotes');
  END IF;
  
  -- ENFORCEMENT: Check job acknowledgement exists
  IF NOT EXISTS (
    SELECT 1 FROM public.job_acknowledgements
    WHERE job_id = v_quote.actual_job_id 
    AND user_id = p_customer_id 
    AND role = 'customer'
  ) THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Please acknowledge job terms first',
      'requires_acknowledgement', true,
      'job_id', v_quote.actual_job_id
    );
  END IF;
  
  -- Calculate fees
  v_commission_cents := calculate_mechanic_commission(v_quote.price_cents);
  v_total_customer_cents := v_quote.price_cents + v_platform_fee_cents;
  v_mechanic_payout_cents := v_quote.price_cents - v_commission_cents;
  
  -- Create contract
  INSERT INTO public.job_contracts (
    job_id, quote_id, customer_id, mechanic_id,
    status, quoted_price_cents, platform_fee_cents, estimated_hours,
    subtotal_cents, total_customer_cents, mechanic_commission_cents, mechanic_payout_cents,
    customer_acknowledged_at
  ) VALUES (
    v_quote.job_id, p_quote_id, p_customer_id, v_quote.mechanic_id,
    'active', v_quote.price_cents, v_platform_fee_cents, v_quote.estimated_hours,
    v_quote.price_cents, v_total_customer_cents, v_commission_cents, v_mechanic_payout_cents,
    now()
  )
  RETURNING id INTO v_contract_id;
  
  -- Update job_acknowledgements with contract_id
  UPDATE public.job_acknowledgements
  SET contract_id = v_contract_id
  WHERE job_id = v_quote.job_id AND user_id = p_customer_id AND role = 'customer';
  
  -- Create initial line item for base labor
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'base_labor', 'Service as quoted', 1, v_quote.price_cents, v_quote.price_cents,
    'approved', false, v_quote.mechanic_id, 'mechanic', 0
  )
  RETURNING id INTO v_line_item_id;
  
  -- Create platform fee line item
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'platform_fee', 'WrenchGo platform fee', 1, v_platform_fee_cents, v_platform_fee_cents,
    'approved', false, p_customer_id, 'customer', 100
  );
  
  -- Create job progress record
  INSERT INTO public.job_progress (job_id, contract_id)
  VALUES (v_quote.job_id, v_contract_id)
  RETURNING id INTO v_progress_id;
  
  -- Update quote status
  UPDATE public.quotes
  SET status = 'accepted', updated_at = now()
  WHERE id = p_quote_id;
  
  -- Decline all other quotes for this job
  UPDATE public.quotes
  SET status = 'declined', updated_at = now()
  WHERE job_id = v_quote.job_id AND id != p_quote_id;
  
  -- Update job status
  UPDATE public.jobs
  SET 
    status = 'accepted',
    accepted_mechanic_id = v_quote.mechanic_id,
    updated_at = now()
  WHERE id = v_quote.job_id;
  
  -- Log event
  PERFORM log_job_event(
    v_quote.job_id, v_contract_id, 'contract_created',
    p_customer_id, 'customer',
    'Contract created',
    'Quote accepted and contract created',
    jsonb_build_object(
      'quoted_price_cents', v_quote.price_cents,
      'platform_fee_cents', v_platform_fee_cents,
      'total_cents', v_total_customer_cents
    ),
    v_total_customer_cents
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'contract_id', v_contract_id,
    'total_cents', v_total_customer_cents,
    'mechanic_id', v_quote.mechanic_id
  );
END;
$$;

-- =====================================================
-- UPDATED RPC: mechanic_start_work (with enforcement)
-- =====================================================
CREATE OR REPLACE FUNCTION mechanic_start_work(
  p_job_id uuid,
  p_mechanic_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_contract RECORD;
  v_terms_check jsonb;
BEGIN
  -- ENFORCEMENT: Check platform terms accepted
  v_terms_check := public.check_terms_accepted('mechanic');
  IF NOT (v_terms_check->>'accepted')::boolean THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Please accept platform terms first',
      'requires_terms', true,
      'terms_version', v_terms_check->>'version'
    );
  END IF;

  -- ENFORCEMENT: Check job acknowledgement exists
  IF NOT EXISTS (
    SELECT 1 FROM public.job_acknowledgements
    WHERE job_id = p_job_id 
    AND user_id = p_mechanic_id 
    AND role = 'mechanic'
  ) THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Please acknowledge job terms first',
      'requires_acknowledgement', true,
      'job_id', p_job_id
    );
  END IF;

  -- Get contract with lock
  SELECT c.*, jp.customer_confirmed_arrival_at, jp.work_started_at
  INTO v_contract
  FROM public.job_contracts c
  JOIN public.job_progress jp ON jp.contract_id = c.id
  WHERE c.job_id = p_job_id AND c.mechanic_id = p_mechanic_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract not found');
  END IF;
  
  IF v_contract.status != 'active' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Contract is not active');
  END IF;
  
  IF v_contract.work_started_at IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Work already started');
  END IF;
  
  -- Update progress and set mechanic_acknowledged_at
  UPDATE public.job_progress
  SET 
    work_started_at = now(),
    updated_at = now()
  WHERE contract_id = v_contract.id;

  UPDATE public.job_contracts
  SET mechanic_acknowledged_at = COALESCE(mechanic_acknowledged_at, now())
  WHERE id = v_contract.id;
  
  -- Update job status
  UPDATE public.jobs
  SET status = 'in_progress', updated_at = now()
  WHERE id = p_job_id;
  
  -- Log event
  PERFORM log_job_event(
    p_job_id, v_contract.id, 'work_started',
    p_mechanic_id, 'mechanic',
    'Work started',
    'Mechanic has begun working on the vehicle',
    jsonb_build_object()
  );
  
  RETURN jsonb_build_object('success', true);
END;
$$;

-- =====================================================
-- GRANTS
-- =====================================================
GRANT SELECT ON public.platform_terms_versions TO authenticated;
GRANT SELECT, INSERT ON public.platform_terms_acceptances TO authenticated;
GRANT SELECT, INSERT ON public.job_acknowledgements TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260120000010_platform_terms_phase45.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260121000001_fix_create_job_sets_job_lat_lng.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: Ensure create_job_with_payment_check sets job_lat/job_lng
--
-- Why:
-- - The trigger `public.assign_job_to_hub()` uses jobs.job_lat/jobs.job_lng.
-- - The app RPC only populated location_lat/location_lng.
-- - That meant hub assignment never happened (hub_id stayed NULL), which
--   breaks admin filters, ring logic, and downstream service area features.
--
-- Safe:
-- - This is an idempotent CREATE OR REPLACE on the RPC.
-- =====================================================

BEGIN;

CREATE OR REPLACE FUNCTION public.create_job_with_payment_check(
  p_title text,
  p_description text DEFAULT NULL,
  p_location_address text DEFAULT NULL,
  p_location_lat double precision DEFAULT NULL,
  p_location_lng double precision DEFAULT NULL,
  p_vehicle_id uuid DEFAULT NULL,
  p_preferred_time text DEFAULT NULL,
  p_symptom_key text DEFAULT NULL,
  p_symptom_id uuid DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_customer_id uuid;
  v_payment_status payment_method_status;
  v_job_id uuid;
  v_symptom_id uuid;
BEGIN
  v_customer_id := auth.uid();

  IF v_customer_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'code', 'NOT_AUTHENTICATED');
  END IF;

  SELECT payment_method_status INTO v_payment_status
  FROM profiles WHERE id = v_customer_id;

  IF v_payment_status IS NULL OR v_payment_status != 'active' THEN
    RETURN jsonb_build_object(
      'success', false,
      'code', 'PAYMENT_METHOD_REQUIRED',
      'message', 'A valid payment method is required to request service'
    );
  END IF;

  -- Look up symptom_id from symptom_key if not provided
  v_symptom_id := p_symptom_id;
  IF v_symptom_id IS NULL AND p_symptom_key IS NOT NULL THEN
    SELECT id INTO v_symptom_id
    FROM symptoms
    WHERE key = p_symptom_key
    LIMIT 1;
  END IF;

  INSERT INTO jobs (
    customer_id,
    title,
    description,
    location_address,
    location_lat,
    location_lng,
    -- IMPORTANT: populate the numeric fields used by assign_job_to_hub
    job_lat,
    job_lng,
    vehicle_id,
    preferred_time,
    symptom_key,
    symptom_id,
    status
  )
  VALUES (
    v_customer_id,
    p_title,
    p_description,
    p_location_address,
    p_location_lat,
    p_location_lng,
    CASE WHEN p_location_lat IS NULL THEN NULL ELSE p_location_lat::numeric END,
    CASE WHEN p_location_lng IS NULL THEN NULL ELSE p_location_lng::numeric END,
    p_vehicle_id,
    p_preferred_time,
    p_symptom_key,
    v_symptom_id,
    'searching'
  )
  RETURNING id INTO v_job_id;

  RETURN jsonb_build_object('success', true, 'job_id', v_job_id);
END;
$$;

-- Keep execute grants consistent
GRANT EXECUTE ON FUNCTION public.create_job_with_payment_check(
  text, text, text, double precision, double precision, uuid, text, text, uuid
) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260121000001_fix_create_job_sets_job_lat_lng.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260121000001_fix_job_location_hub_and_escrow.sql
-- ===================================================================\n
BEGIN;

-- =====================================================
-- Fix: Job location fields
--
-- The app passes p_location_lat/lng to create_job_with_payment_check, but
-- service-area features + hub assignment rely on jobs.job_lat/job_lng and
-- jobs.job_location. This migration ensures all RPC variants populate BOTH.
-- =====================================================

-- Variant 1 (legacy)
CREATE OR REPLACE FUNCTION public.create_job_with_payment_check(
  p_title text,
  p_description text DEFAULT NULL,
  p_location_address text DEFAULT NULL,
  p_location_lat double precision DEFAULT NULL,
  p_location_lng double precision DEFAULT NULL,
  p_vehicle_id uuid DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_job_id uuid;
  v_payment_method_status text;
BEGIN
  SELECT auth.uid() INTO v_user_id;
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  SELECT payment_method_status::text
  INTO v_payment_method_status
  FROM profiles
  WHERE id = v_user_id;

  IF v_payment_method_status IS NULL OR v_payment_method_status = 'none' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Payment method required');
  END IF;

  INSERT INTO jobs (
    customer_id,
    title,
    description,
    location_address,
    location_lat,
    location_lng,
    job_lat,
    job_lng,
    vehicle_id,
    status
  )
  VALUES (
    v_user_id,
    p_title,
    p_description,
    p_location_address,
    p_location_lat,
    p_location_lng,
    p_location_lat::numeric,
    p_location_lng::numeric,
    p_vehicle_id,
    'draft'
  )
  RETURNING id INTO v_job_id;

  RETURN jsonb_build_object('success', true, 'job_id', v_job_id);
END;
$$;

-- Variant 2 (preferred time)
CREATE OR REPLACE FUNCTION public.create_job_with_payment_check(
  p_title text,
  p_description text,
  p_location_address text,
  p_location_lat double precision,
  p_location_lng double precision,
  p_vehicle_id uuid,
  p_preferred_time text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_job_id uuid;
  v_payment_method_status text;
BEGIN
  SELECT auth.uid() INTO v_user_id;
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  SELECT payment_method_status::text
  INTO v_payment_method_status
  FROM profiles
  WHERE id = v_user_id;

  IF v_payment_method_status IS NULL OR v_payment_method_status = 'none' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Payment method required');
  END IF;

  INSERT INTO jobs (
    customer_id,
    title,
    description,
    location_address,
    location_lat,
    location_lng,
    job_lat,
    job_lng,
    vehicle_id,
    preferred_time,
    status
  )
  VALUES (
    v_user_id,
    p_title,
    p_description,
    p_location_address,
    p_location_lat,
    p_location_lng,
    p_location_lat::numeric,
    p_location_lng::numeric,
    p_vehicle_id,
    p_preferred_time,
    'draft'
  )
  RETURNING id INTO v_job_id;

  RETURN jsonb_build_object('success', true, 'job_id', v_job_id);
END;
$$;

-- Variant 3 (preferred time + symptom)
CREATE OR REPLACE FUNCTION public.create_job_with_payment_check(
  p_title text,
  p_description text,
  p_location_address text,
  p_location_lat double precision,
  p_location_lng double precision,
  p_vehicle_id uuid,
  p_preferred_time text,
  p_symptom_key text DEFAULT NULL,
  p_symptom_id uuid DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_job_id uuid;
  v_payment_method_status text;
  v_symptom_key text;
BEGIN
  SELECT auth.uid() INTO v_user_id;
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  SELECT payment_method_status::text
  INTO v_payment_method_status
  FROM profiles
  WHERE id = v_user_id;

  IF v_payment_method_status IS NULL OR v_payment_method_status = 'none' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Payment method required');
  END IF;

  v_symptom_key := p_symptom_key;
  IF v_symptom_key IS NULL AND p_symptom_id IS NOT NULL THEN
    SELECT key INTO v_symptom_key FROM symptoms WHERE key = p_symptom_id::text;
  END IF;

  INSERT INTO jobs (
    customer_id,
    title,
    description,
    location_address,
    location_lat,
    location_lng,
    job_lat,
    job_lng,
    vehicle_id,
    preferred_time,
    symptom_key,
    status
  )
  VALUES (
    v_user_id,
    p_title,
    p_description,
    p_location_address,
    p_location_lat,
    p_location_lng,
    p_location_lat::numeric,
    p_location_lng::numeric,
    p_vehicle_id,
    p_preferred_time,
    v_symptom_key,
    'draft'
  )
  RETURNING id INTO v_job_id;

  RETURN jsonb_build_object('success', true, 'job_id', v_job_id);
END;
$$;

-- =====================================================
-- Fix: Make hub assignment resilient (job_lat/lng vs location_lat/lng)
-- =====================================================

CREATE OR REPLACE FUNCTION public.assign_job_to_hub()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_lat numeric;
  v_lng numeric;
  v_hub_id uuid;
BEGIN
  -- Prefer normalized numeric columns, but fall back to legacy columns.
  v_lat := COALESCE(NEW.job_lat, NEW.location_lat::numeric);
  v_lng := COALESCE(NEW.job_lng, NEW.location_lng::numeric);

  IF v_lat IS NULL OR v_lng IS NULL THEN
    RETURN NEW;
  END IF;

  -- Find nearest hub within its max radius.
  SELECT h.id
  INTO v_hub_id
  FROM service_hubs h
  WHERE h.is_active = true
    AND ST_DWithin(
      h.location,
      ST_SetSRID(ST_MakePoint(v_lng::double precision, v_lat::double precision), 4326)::extensions.geography,
      (h.max_radius_miles * 1609.34)
    )
  ORDER BY ST_Distance(
    h.location,
    ST_SetSRID(ST_MakePoint(v_lng::double precision, v_lat::double precision), 4326)::extensions.geography
  )
  LIMIT 1;

  NEW.hub_id := v_hub_id;

  RETURN NEW;
END;
$$;

-- =====================================================
-- Escrow groundwork
-- =====================================================

-- Add an 'authorized' state for capture_method=manual PaymentIntents.
DO $$
BEGIN
  ALTER TYPE public.payment_status ADD VALUE IF NOT EXISTS 'authorized' BEFORE 'processing';
EXCEPTION
  WHEN duplicate_object THEN
    -- ignore
    NULL;
END$$;

-- Fix: Contracts created from quotes should start in pending_payment.
-- This unlocks the existing authorize_contract_payment() function.
CREATE OR REPLACE FUNCTION public.accept_quote_and_resolve_conflicts(
  p_quote_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_quote record;
  v_job record;
  v_contract_id uuid;
  v_payment_method_status text;
  v_platform_fee_cents integer := 1500;
  v_estimated_hours numeric := NULL;
BEGIN
  -- Fetch quote + job
  SELECT q.*, j.customer_id, j.status AS job_status, j.accepted_mechanic_id, j.scheduled_at
  INTO v_quote
  FROM quotes q
  JOIN jobs j ON j.id = q.job_id
  WHERE q.id = p_quote_id;

  IF v_quote.id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote not found');
  END IF;

  IF v_quote.customer_id != p_customer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Unauthorized');
  END IF;

  -- Ensure customer has an active payment method on file
  SELECT payment_method_status::text INTO v_payment_method_status
  FROM profiles
  WHERE id = p_customer_id;

  IF v_payment_method_status IS NULL OR v_payment_method_status = 'none' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Payment method required');
  END IF;

  -- Lock the job so we can safely create a contract and resolve conflicts
  SELECT * INTO v_job
  FROM jobs
  WHERE id = v_quote.job_id
  FOR UPDATE;

  -- Ensure the quote is still eligible
  IF v_quote.status != 'accepted' AND v_quote.status != 'pending' THEN
    -- app may set accepted before calling; tolerate both
    NULL;
  END IF;

  -- Reject other quotes for same job
  UPDATE quotes
  SET status = 'declined'
  WHERE job_id = v_quote.job_id
    AND id != p_quote_id
    AND status IN ('pending', 'accepted');

  -- Determine estimated hours
  v_estimated_hours := v_quote.estimated_hours;

  -- Create contract in PENDING_PAYMENT so payment authorization can activate it.
  INSERT INTO job_contracts (
    job_id,
    quote_id,
    customer_id,
    mechanic_id,
    status,
    quoted_price_cents,
    platform_fee_cents,
    subtotal_cents,
    total_customer_cents,
    mechanic_commission_cents,
    mechanic_payout_cents,
    estimated_hours,
    scheduled_start_at,
    scheduled_end_at
  )
  VALUES (
    v_quote.job_id,
    v_quote.id,
    v_quote.customer_id,
    v_quote.mechanic_id,
    'pending_payment',
    COALESCE(v_quote.price_cents, 0),
    v_platform_fee_cents,
    COALESCE(v_quote.price_cents, 0),
    COALESCE(v_quote.price_cents, 0) + v_platform_fee_cents,
    0,
    COALESCE(v_quote.price_cents, 0),
    v_estimated_hours,
    v_quote.proposed_start_at,
    v_quote.proposed_end_at
  )
  RETURNING id INTO v_contract_id;

  -- Mark job accepted and lock accepted mechanic
  UPDATE jobs
  SET status = 'accepted',
      accepted_mechanic_id = v_quote.mechanic_id
  WHERE id = v_quote.job_id;

  RETURN jsonb_build_object(
    'success', true,
    'contract_id', v_contract_id,
    'job_id', v_quote.job_id,
    'mechanic_id', v_quote.mechanic_id,
    'customer_id', v_quote.customer_id
  );
END;
$$;

-- Promo: when a promo credit is applied to a payment, also update the payments + contract totals.
CREATE OR REPLACE FUNCTION public.apply_promo_to_payment(
  p_payment_id uuid,
  p_platform_fee_cents integer DEFAULT 1500
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_payment record;
  v_job record;
  v_credit_id uuid;
  v_credit_type text;
  v_discount_cents integer;
  v_fee_after_cents integer;
BEGIN
  SELECT auth.uid() INTO v_user_id;
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  -- Get payment and verify ownership
  SELECT p.*, j.customer_id
  INTO v_payment
  FROM payments p
  JOIN jobs j ON j.id = p.job_id
  WHERE p.id = p_payment_id;

  IF v_payment.id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Payment not found');
  END IF;

  IF v_payment.customer_id != v_user_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;

  -- Get job
  SELECT * INTO v_job FROM jobs WHERE id = v_payment.job_id;

  IF v_job.applied_promo_credit_id IS NOT NULL THEN
    RETURN jsonb_build_object('success', true, 'message', 'Promo already applied');
  END IF;

  -- Find best available credit
  SELECT id, credit_type::text
  INTO v_credit_id, v_credit_type
  FROM promo_credits
  WHERE user_id = v_user_id
    AND remaining_uses > 0
    AND (expires_at IS NULL OR expires_at > now())
    AND paused = false
  ORDER BY
    CASE WHEN credit_type = 'FEELESS' THEN 0 ELSE 1 END,
    created_at ASC
  LIMIT 1;

  IF v_credit_id IS NULL THEN
    RETURN jsonb_build_object('success', true, 'has_discount', false, 'message', 'No promo credits available');
  END IF;

  v_discount_cents := CASE
    WHEN v_credit_type = 'FEELESS' THEN p_platform_fee_cents
    WHEN v_credit_type = 'FEELESS3' THEN LEAST(300, p_platform_fee_cents)
    ELSE 0
  END;

  v_fee_after_cents := GREATEST(0, p_platform_fee_cents - v_discount_cents);

  -- Record application
  INSERT INTO payment_promo_applications (
    payment_id,
    promo_credit_id,
    credit_type,
    fee_before_cents,
    discount_cents,
    fee_after_cents
  )
  VALUES (
    p_payment_id,
    v_credit_id,
    v_credit_type::promo_credit_type,
    p_platform_fee_cents,
    v_discount_cents,
    v_fee_after_cents
  );

  -- Consume 1 use
  UPDATE promo_credits
  SET remaining_uses = remaining_uses - 1,
      updated_at = now()
  WHERE id = v_credit_id;

  -- Update job
  UPDATE jobs
  SET applied_promo_credit_id = v_credit_id,
      promo_discount_cents = v_discount_cents,
      promo_credit_type = v_credit_type,
      updated_at = now()
  WHERE id = v_payment.job_id;

  -- Update payment to reflect discount
  UPDATE payments
  SET promo_credit_id = v_credit_id,
      promo_discount_cents = v_discount_cents,
      original_platform_fee_cents = COALESCE(original_platform_fee_cents, p_platform_fee_cents),
      platform_fee_cents = v_fee_after_cents,
      amount_cents = amount_cents - v_discount_cents,
      updated_at = now()
  WHERE id = p_payment_id;

  -- Update contract totals if contract exists
  UPDATE job_contracts
  SET platform_fee_cents = v_fee_after_cents,
      total_customer_cents = quoted_price_cents + v_fee_after_cents,
      updated_at = now()
  WHERE job_id = v_payment.job_id;

  RETURN jsonb_build_object(
    'success', true,
    'has_discount', true,
    'credit_type', v_credit_type,
    'discount_cents', v_discount_cents,
    'fee_after_cents', v_fee_after_cents
  );
END;
$$;

COMMIT;
\n-- ===================================================================
-- END: 20260121000001_fix_job_location_hub_and_escrow.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260121000002_accept_quote_pending_payment.sql
-- ===================================================================\n
BEGIN;

-- =====================================================
-- Escrow flow: keep contract in 'pending_payment' until
-- payment authorization succeeds (authorize_contract_payment).
--
-- We keep the no-double-booking logic and job_progress creation from
-- 20260130000001_no_double_booking, but change the initial status.
-- =====================================================

CREATE OR REPLACE FUNCTION public.accept_quote_and_resolve_conflicts(
  p_quote_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_quote RECORD;
  v_job RECORD;
  v_contract_id uuid;
  v_progress_id uuid;
  v_platform_fee_cents int := 1500;
  v_commission_cents int;
  v_total_customer_cents int;
  v_mechanic_payout_cents int;
  v_line_item_id uuid;
  v_terms_check jsonb;
  v_mechanic_promo_result jsonb;
  v_booking_start timestamptz;
  v_booking_end timestamptz;
  v_conflict_contract_id uuid;
  v_expired_quote_ids uuid[];
  v_expired_count int := 0;
  v_mechanic_name text;
  v_job_title text;
BEGIN
  -- ENFORCEMENT: Check platform terms accepted
  v_terms_check := public.check_terms_accepted('customer');
  IF NOT (v_terms_check->>'accepted')::boolean THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Please accept platform terms first',
      'requires_terms', true,
      'terms_version', v_terms_check->>'version'
    );
  END IF;

  -- Get quote with lock (FOR UPDATE prevents concurrent acceptance)
  SELECT 
    q.*, 
    j.customer_id as job_customer_id, 
    j.status as job_status, 
    j.id as actual_job_id,
    j.scheduled_at,
    j.estimated_duration_minutes,
    j.title as job_title
  INTO v_quote
  FROM public.quotes q
  JOIN public.jobs j ON j.id = q.job_id
  WHERE q.id = p_quote_id
  FOR UPDATE OF q, j;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote not found');
  END IF;
  
  IF v_quote.job_customer_id != p_customer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  IF v_quote.status NOT IN ('pending', 'accepted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote is no longer available');
  END IF;
  
  IF v_quote.job_status NOT IN ('searching', 'quoted', 'accepted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job is no longer accepting quotes');
  END IF;
  
  -- ENFORCEMENT: Check job acknowledgement exists
  IF NOT EXISTS (
    SELECT 1 FROM public.job_acknowledgements
    WHERE job_id = v_quote.actual_job_id 
    AND user_id = p_customer_id 
    AND role = 'customer'
  ) THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Please acknowledge job terms first',
      'requires_acknowledgement', true,
      'job_id', v_quote.actual_job_id
    );
  END IF;
  
  -- Calculate booking window
  v_booking_start := COALESCE(v_quote.proposed_start_at, v_quote.scheduled_at);
  v_booking_end := COALESCE(
    v_quote.proposed_end_at, 
    v_quote.scheduled_at + (COALESCE(v_quote.estimated_duration_minutes, 90) * interval '1 minute')
  );
  
  -- If no scheduled time, we can't do conflict checking
  IF v_booking_start IS NULL THEN
    v_booking_start := now();
    v_booking_end := now() + interval '90 minutes';
  END IF;
  
  -- =====================================================
  -- CONFLICT CHECK: Ensure mechanic isn't already booked
  -- =====================================================
  SELECT jc.id INTO v_conflict_contract_id
  FROM public.job_contracts jc
  WHERE jc.mechanic_id = v_quote.mechanic_id
    AND jc.status IN ('pending_payment', 'active')
    AND jc.scheduled_start_at < v_booking_end
    AND jc.scheduled_end_at > v_booking_start
  LIMIT 1
  FOR UPDATE;
  
  IF v_conflict_contract_id IS NOT NULL THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Mechanic is no longer available at that time.',
      'error_code', 'MECHANIC_UNAVAILABLE',
      'conflict_contract_id', v_conflict_contract_id
    );
  END IF;
  
  -- Check if contract already exists for this job (retry scenario)
  SELECT id INTO v_contract_id
  FROM public.job_contracts
  WHERE job_id = v_quote.job_id;
  
  IF v_contract_id IS NOT NULL THEN
    -- Contract exists, return it
    RETURN jsonb_build_object(
      'success', true,
      'contract_id', v_contract_id,
      'already_exists', true,
      'expired_quote_ids', ARRAY[]::uuid[],
      'expired_count', 0,
      'scheduled_start_at', v_booking_start,
      'scheduled_end_at', v_booking_end
    );
  END IF;
  
  -- Calculate fees
  v_commission_cents := calculate_mechanic_commission(v_quote.price_cents);
  v_total_customer_cents := v_quote.price_cents + v_platform_fee_cents;
  v_mechanic_payout_cents := v_quote.price_cents - v_commission_cents;
  
  -- Create contract with booking window
  INSERT INTO public.job_contracts (
    job_id, quote_id, customer_id, mechanic_id,
    status, quoted_price_cents, platform_fee_cents, estimated_hours,
    subtotal_cents, total_customer_cents, mechanic_commission_cents, mechanic_payout_cents,
    customer_acknowledged_at, scheduled_start_at, scheduled_end_at
  ) VALUES (
    v_quote.job_id, p_quote_id, p_customer_id, v_quote.mechanic_id,
    'pending_payment', v_quote.price_cents, v_platform_fee_cents, v_quote.estimated_hours,
    v_quote.price_cents, v_total_customer_cents, v_commission_cents, v_mechanic_payout_cents,
    now(), v_booking_start, v_booking_end
  )
  RETURNING id INTO v_contract_id;
  
  -- Auto-apply mechanic promo credit
  v_mechanic_promo_result := public.apply_mechanic_promo_to_contract(
    v_contract_id,
    v_quote.mechanic_id,
    v_commission_cents
  );
  
  -- Update job_acknowledgements with contract_id
  UPDATE public.job_acknowledgements
  SET contract_id = v_contract_id
  WHERE job_id = v_quote.job_id AND user_id = p_customer_id AND role = 'customer';
  
  -- Create initial line item for base labor
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'base_labor', 'Service as quoted', 1, v_quote.price_cents, v_quote.price_cents,
    'approved', false, v_quote.mechanic_id, 'mechanic', 0
  )
  RETURNING id INTO v_line_item_id;
  
  -- Create platform fee line item
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'platform_fee', 'WrenchGo platform fee', 1, v_platform_fee_cents, v_platform_fee_cents,
    'approved', false, p_customer_id, 'customer', 100
  );
  
  -- Create job progress record
  INSERT INTO public.job_progress (job_id, contract_id)
  VALUES (v_quote.job_id, v_contract_id)
  RETURNING id INTO v_progress_id;
  
  -- Update quote status
  UPDATE public.quotes
  SET status = 'accepted', updated_at = now()
  WHERE id = p_quote_id;
  
  -- Decline all other quotes for this job
  UPDATE public.quotes
  SET status = 'declined', updated_at = now()
  WHERE job_id = v_quote.job_id AND id != p_quote_id AND status = 'pending';
  
  -- Update job status
  UPDATE public.jobs
  SET 
    status = 'accepted',
    accepted_mechanic_id = v_quote.mechanic_id,
    updated_at = now()
  WHERE id = v_quote.job_id;
  
  -- =====================================================
  -- EXPIRE OVERLAPPING PENDING QUOTES FROM SAME MECHANIC
  -- =====================================================
  WITH expired AS (
    UPDATE public.quotes
    SET 
      status = 'expired_conflict', 
      conflict_status_reason = 'time_conflict',
      updated_at = now()
    WHERE mechanic_id = v_quote.mechanic_id
      AND id != p_quote_id
      AND status = 'pending'
      AND proposed_start_at IS NOT NULL
      AND proposed_end_at IS NOT NULL
      AND proposed_start_at < v_booking_end
      AND proposed_end_at > v_booking_start
    RETURNING id, job_id
  )
  SELECT array_agg(id), count(*) INTO v_expired_quote_ids, v_expired_count FROM expired;
  
  -- Default to empty array if null
  v_expired_quote_ids := COALESCE(v_expired_quote_ids, ARRAY[]::uuid[]);
  v_expired_count := COALESCE(v_expired_count, 0);
  
  -- Log event for accepted quote
  PERFORM log_job_event(
    v_quote.job_id, v_contract_id, 'contract_created',
    p_customer_id, 'customer',
    'Contract created',
    'Quote accepted and contract created',
    jsonb_build_object(
      'quoted_price_cents', v_quote.price_cents,
      'platform_fee_cents', v_platform_fee_cents,
      'total_cents', v_total_customer_cents,
      'mechanic_promo_applied', COALESCE((v_mechanic_promo_result->>'has_credit')::boolean, false),
      'mechanic_promo_discount_cents', COALESCE((v_mechanic_promo_result->>'discount_cents')::int, 0),
      'expired_conflict_count', v_expired_count,
      'scheduled_start_at', v_booking_start,
      'scheduled_end_at', v_booking_end
    ),
    v_total_customer_cents
  );
  
  -- Log events for expired quotes
  IF v_expired_count > 0 THEN
    PERFORM log_job_event(
      v_quote.job_id, v_contract_id, 'quote_expired_conflict',
      v_quote.mechanic_id, 'mechanic',
      'Overlapping quotes expired',
      format('%s pending quote(s) expired due to time conflict', v_expired_count),
      jsonb_build_object(
        'expired_quote_ids', v_expired_quote_ids,
        'expired_count', v_expired_count,
        'booking_start', v_booking_start,
        'booking_end', v_booking_end
      ),
      NULL
    );
  END IF;
  
  -- =====================================================
  -- NOTIFICATION: Notify mechanic of acceptance + conflicts
  -- =====================================================
  SELECT p.full_name INTO v_mechanic_name
  FROM public.profiles p
  WHERE p.id = v_quote.mechanic_id;
  
  v_job_title := v_quote.job_title;
  
  INSERT INTO public.notifications (
    user_id, title, body, type, entity_type, entity_id, data
  ) VALUES (
    v_quote.mechanic_id,
    'Quote accepted  booking confirmed',
    CASE 
      WHEN v_expired_count > 0 THEN
        format('%s booked for %s. %s overlapping quote(s) expired.', 
          v_job_title, 
          to_char(v_booking_start AT TIME ZONE 'UTC', 'Mon DD, HH12:MI AM'),
          v_expired_count)
      ELSE
        format('%s booked for %s', 
          v_job_title, 
          to_char(v_booking_start AT TIME ZONE 'UTC', 'Mon DD, HH12:MI AM'))
    END,
    'quote_accepted',
    'job',
    v_quote.job_id,
    jsonb_build_object(
      'accepted_job_id', v_quote.job_id,
      'accepted_quote_id', p_quote_id,
      'contract_id', v_contract_id,
      'expired_quote_ids', v_expired_quote_ids,
      'expired_count', v_expired_count,
      'scheduled_start_at', v_booking_start,
      'scheduled_end_at', v_booking_end
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'contract_id', v_contract_id,
    'total_cents', v_total_customer_cents,
    'mechanic_id', v_quote.mechanic_id,
    'mechanic_promo_applied', COALESCE((v_mechanic_promo_result->>'has_credit')::boolean, false),
    'mechanic_promo_discount_cents', COALESCE((v_mechanic_promo_result->>'discount_cents')::int, 0),
    'expired_quote_ids', v_expired_quote_ids,
    'expired_count', v_expired_count,
    'scheduled_start_at', v_booking_start,
    'scheduled_end_at', v_booking_end
  );
END;
$$;

COMMIT;

\n-- ===================================================================
-- END: 20260121000002_accept_quote_pending_payment.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260121000003_set_user_service_area_by_zip.sql
-- ===================================================================\n
BEGIN;

-- =====================================================
-- Assign the authenticated user to a hub (or waitlist)
-- based on ZIP code. This writes to profiles.service_*.
--
-- Why:
-- - New users were never automatically linked to a hub.
-- - Out-of-service users were not consistently placed on a waitlist.
-- =====================================================

CREATE OR REPLACE FUNCTION public.set_user_service_area_by_zip(
  p_zip text
) RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_zip record;
  v_nearest record;
  v_profile record;
  v_within boolean := false;
  v_user_type text := 'customer';
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  IF p_zip IS NULL OR length(trim(p_zip)) < 3 THEN
    RETURN jsonb_build_object('success', false, 'error', 'ZIP is required');
  END IF;

  SELECT * INTO v_zip
  FROM public.zip_codes
  WHERE zip = trim(p_zip)
  LIMIT 1;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'ZIP not found');
  END IF;

  SELECT * INTO v_nearest
  FROM public.get_nearest_hub(v_zip.lat, v_zip.lng)
  LIMIT 1;

  v_within := COALESCE(v_nearest.is_within_area, false);

  SELECT email, phone, role INTO v_profile
  FROM public.profiles
  WHERE id = v_user_id;

  IF FOUND AND v_profile.role IS NOT NULL THEN
    v_user_type := v_profile.role::text;
  END IF;

  -- Always persist the user's service location.
  UPDATE public.profiles
  SET
    service_zip = v_zip.zip,
    service_lat = v_zip.lat,
    service_lng = v_zip.lng,
    hub_id = CASE WHEN v_within THEN v_nearest.hub_id ELSE NULL END,
    updated_at = now()
  WHERE id = v_user_id;

  IF NOT v_within THEN
    IF v_profile.email IS NULL OR length(trim(v_profile.email)) = 0 THEN
      RETURN jsonb_build_object('success', false, 'error', 'Email required for waitlist');
    END IF;

    -- Place the user on the waitlist (upsert by unique (email, zip)).
    INSERT INTO public.waitlist (
      email,
      phone,
      zip,
      lat,
      lng,
      user_type,
      status,
      nearest_hub_id,
      distance_miles
    ) VALUES (
      v_profile.email,
      v_profile.phone,
      v_zip.zip,
      v_zip.lat,
      v_zip.lng,
      v_user_type,
      'waiting',
      v_nearest.hub_id,
      v_nearest.distance_miles
    )
    ON CONFLICT (email, zip)
    DO UPDATE SET
      phone = EXCLUDED.phone,
      lat = EXCLUDED.lat,
      lng = EXCLUDED.lng,
      user_type = EXCLUDED.user_type,
      status = 'waiting',
      nearest_hub_id = EXCLUDED.nearest_hub_id,
      distance_miles = EXCLUDED.distance_miles,
      updated_at = now();
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'within_area', v_within,
    'nearest_hub', jsonb_build_object(
      'hub_id', v_nearest.hub_id,
      'hub_name', v_nearest.hub_name,
      'distance_miles', v_nearest.distance_miles,
      'active_radius_miles', v_nearest.active_radius_miles,
      'max_radius_miles', v_nearest.max_radius_miles
    )
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.set_user_service_area_by_zip(text) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260121000003_set_user_service_area_by_zip.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260121000004_add_stripe_webhook_events.sql
-- ===================================================================\n
-- =====================================================
-- Stripe webhook idempotency table
--
-- Used by `supabase/functions/stripe-webhook` to ensure Stripe events are
-- only processed once.
-- =====================================================

CREATE TABLE IF NOT EXISTS public.stripe_webhook_events (
  id text PRIMARY KEY,
  type text NOT NULL,
  stripe_created timestamptz,
  processed_at timestamptz NOT NULL DEFAULT now(),
  payload jsonb
);

ALTER TABLE public.stripe_webhook_events ENABLE ROW LEVEL SECURITY;

-- Only admins should be able to read webhook events from SQL clients.
-- Service role (Edge Functions) bypasses RLS.
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'stripe_webhook_events'
      AND policyname = 'Admins can read stripe webhook events'
  ) THEN
    CREATE POLICY "Admins can read stripe webhook events"
      ON public.stripe_webhook_events
      FOR SELECT
      USING (public.is_admin());
  END IF;
END$$;
\n-- ===================================================================
-- END: 20260121000004_add_stripe_webhook_events.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260125000001_data_integrity_repair.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: Data Integrity Repair & Guardrails
-- =====================================================
-- Purpose: Diagnose, repair, and prevent data integrity issues
--          caused by manual profile inserts
-- 
-- Run order: After all previous migrations
-- 
-- IMPORTANT: Run diagnostic queries FIRST to assess scope,
--            then apply repairs in a transaction.
-- =====================================================

-- =====================================================
-- SECTION 0: QUARANTINE TABLE
-- =====================================================
-- Create a table to hold orphaned/problematic profile snapshots
-- for manual review before deletion

CREATE TABLE IF NOT EXISTS public.orphan_profiles_quarantine (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id uuid NOT NULL,
  snapshot jsonb NOT NULL,
  detected_at timestamptz DEFAULT now() NOT NULL,
  reason text NOT NULL,
  resolved_at timestamptz,
  resolved_by uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
  resolution_action text,
  notes text
);

CREATE INDEX IF NOT EXISTS idx_orphan_quarantine_profile ON public.orphan_profiles_quarantine(profile_id);
CREATE INDEX IF NOT EXISTS idx_orphan_quarantine_detected ON public.orphan_profiles_quarantine(detected_at DESC);
CREATE INDEX IF NOT EXISTS idx_orphan_quarantine_unresolved ON public.orphan_profiles_quarantine(resolved_at) WHERE resolved_at IS NULL;

COMMENT ON TABLE public.orphan_profiles_quarantine IS 'Quarantined profiles with data integrity issues for manual review';

-- RLS: Admin only
ALTER TABLE public.orphan_profiles_quarantine ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS orphan_quarantine_admin_all ON public.orphan_profiles_quarantine;
CREATE POLICY orphan_quarantine_admin_all ON public.orphan_profiles_quarantine
  FOR ALL TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

-- =====================================================
-- SECTION 1: DIAGNOSTIC QUERIES
-- =====================================================
-- These are SELECT-only queries to assess the scope of issues.
-- Run these BEFORE applying repairs to understand impact.

-- NOTE: Execute these diagnostics manually or via admin dashboard.
-- They are wrapped in a DO block for documentation but won't affect data.

/*
================================================================================
DIAGNOSTIC 1: Profiles missing auth.users (orphan profiles)
================================================================================
*/
-- SELECT 
--   p.id,
--   p.email,
--   p.full_name,
--   p.role,
--   p.created_at,
--   p.deleted_at,
--   'orphan_no_auth_user' AS issue_type
-- FROM public.profiles p
-- LEFT JOIN auth.users u ON p.id = u.id
-- WHERE u.id IS NULL;

/*
================================================================================
DIAGNOSTIC 2: Mechanics with payout_method_status='active' but no stripe account
================================================================================
*/
-- SELECT 
--   p.id,
--   p.email,
--   p.full_name,
--   p.payout_method_status,
--   msa.stripe_account_id,
--   msa.onboarding_complete,
--   msa.payouts_enabled,
--   'payout_status_mismatch' AS issue_type
-- FROM public.profiles p
-- LEFT JOIN public.mechanic_stripe_accounts msa ON p.id = msa.mechanic_id
-- WHERE p.role = 'mechanic'
--   AND p.payout_method_status = 'active'
--   AND (
--     msa.id IS NULL 
--     OR msa.onboarding_complete = false 
--     OR msa.payouts_enabled = false
--   );

/*
================================================================================
DIAGNOSTIC 3: Mechanics with role='mechanic' but missing location (home_lat/home_lng)
================================================================================
*/
-- SELECT 
--   p.id,
--   p.email,
--   p.full_name,
--   p.home_lat,
--   p.home_lng,
--   mp.tier,
--   mp.is_available,
--   'mechanic_missing_location' AS issue_type
-- FROM public.profiles p
-- LEFT JOIN public.mechanic_profiles mp ON p.id = mp.id
-- WHERE p.role = 'mechanic'
--   AND p.deleted_at IS NULL
--   AND (p.home_lat IS NULL OR p.home_lng IS NULL);

/*
================================================================================
DIAGNOSTIC 4: Mechanics with mechanic_profile but missing core setup
================================================================================
*/
-- SELECT 
--   p.id,
--   p.email,
--   p.role,
--   mp.tier,
--   mp.stripe_onboarding_complete,
--   p.payout_method_status,
--   CASE 
--     WHEN p.role != 'mechanic' THEN 'profile_mechanic_mismatch'
--     WHEN mp.id IS NULL THEN 'mechanic_profile_missing'
--     ELSE 'unknown'
--   END AS issue_type
-- FROM public.mechanic_profiles mp
-- LEFT JOIN public.profiles p ON mp.id = p.id
-- WHERE p.role != 'mechanic' OR p.id IS NULL;

/*
================================================================================
DIAGNOSTIC 5: Invalid lat/lng values (out of range or stored incorrectly)
================================================================================
*/
-- SELECT 
--   id,
--   email,
--   home_lat,
--   home_lng,
--   'invalid_coordinates' AS issue_type
-- FROM public.profiles
-- WHERE (home_lat IS NOT NULL AND (home_lat < -90 OR home_lat > 90))
--    OR (home_lng IS NOT NULL AND (home_lng < -180 OR home_lng > 180));

/*
================================================================================
DIAGNOSTIC 6: Profiles with deleted_at but still appearing in active queries
================================================================================
*/
-- SELECT 
--   p.id,
--   p.email,
--   p.deleted_at,
--   p.deleted_reason,
--   p.can_reapply,
--   'deleted_but_not_quarantined' AS issue_type
-- FROM public.profiles p
-- WHERE p.deleted_at IS NOT NULL
--   AND p.deleted_reason IS NULL;

/*
================================================================================
DIAGNOSTIC 7: Count summary of all issues
================================================================================
*/
-- SELECT 
--   'orphan_profiles' AS issue_type,
--   COUNT(*) AS count
-- FROM public.profiles p
-- LEFT JOIN auth.users u ON p.id = u.id
-- WHERE u.id IS NULL
-- UNION ALL
-- SELECT 
--   'payout_status_mismatch',
--   COUNT(*)
-- FROM public.profiles p
-- LEFT JOIN public.mechanic_stripe_accounts msa ON p.id = msa.mechanic_id
-- WHERE p.role = 'mechanic'
--   AND p.payout_method_status = 'active'
--   AND (msa.id IS NULL OR msa.onboarding_complete = false OR msa.payouts_enabled = false)
-- UNION ALL
-- SELECT 
--   'mechanic_missing_location',
--   COUNT(*)
-- FROM public.profiles p
-- WHERE p.role = 'mechanic'
--   AND p.deleted_at IS NULL
--   AND (p.home_lat IS NULL OR p.home_lng IS NULL)
-- UNION ALL
-- SELECT 
--   'invalid_coordinates',
--   COUNT(*)
-- FROM public.profiles
-- WHERE (home_lat IS NOT NULL AND (home_lat < -90 OR home_lat > 90))
--    OR (home_lng IS NOT NULL AND (home_lng < -180 OR home_lng > 180));


-- =====================================================
-- SECTION 2: REPAIR SQL (TRANSACTIONAL)
-- =====================================================

BEGIN;

-- =====================================================
-- REPAIR 2A: Quarantine orphan profiles (no auth.users)
-- =====================================================
-- Move orphan profiles to quarantine and soft-delete them

-- First, snapshot and quarantine
INSERT INTO public.orphan_profiles_quarantine (profile_id, snapshot, reason)
SELECT 
  p.id,
  to_jsonb(p),
  'orphan_profile_no_auth_user'
FROM public.profiles p
LEFT JOIN auth.users u ON p.id = u.id
WHERE u.id IS NULL
  AND NOT EXISTS (
    SELECT 1 FROM public.orphan_profiles_quarantine q 
    WHERE q.profile_id = p.id AND q.reason = 'orphan_profile_no_auth_user'
  );

-- Then soft-delete them
UPDATE public.profiles p
SET 
  deleted_at = COALESCE(p.deleted_at, now()),
  deleted_reason = COALESCE(p.deleted_reason, 'orphan_profile_no_auth_user'),
  can_reapply = false,
  updated_at = now()
FROM (
  SELECT p2.id
  FROM public.profiles p2
  LEFT JOIN auth.users u ON p2.id = u.id
  WHERE u.id IS NULL
) orphans
WHERE p.id = orphans.id;

-- Log the repair action
DO $$
DECLARE
  v_count int;
BEGIN
  SELECT COUNT(*) INTO v_count
  FROM public.orphan_profiles_quarantine
  WHERE reason = 'orphan_profile_no_auth_user'
    AND detected_at > now() - interval '1 minute';
    
  IF v_count > 0 THEN
    PERFORM public.system_audit_log(
      'DATA_REPAIR',
      'profiles',
      NULL,
      jsonb_build_object(
        'repair_type', 'orphan_profiles_quarantined',
        'count', v_count,
        'action', 'soft_delete_and_quarantine'
      )
    );
  END IF;
END $$;

-- =====================================================
-- REPAIR 2B: Fix payout_method_status inconsistencies
-- =====================================================
-- Set payout_method_status to 'none' for mechanics without proper stripe setup

UPDATE public.profiles p
SET 
  payout_method_status = 'none',
  updated_at = now()
FROM (
  SELECT p2.id
  FROM public.profiles p2
  LEFT JOIN public.mechanic_stripe_accounts msa ON p2.id = msa.mechanic_id
  WHERE p2.role = 'mechanic'
    AND p2.payout_method_status = 'active'
    AND (
      msa.id IS NULL 
      OR msa.onboarding_complete = false 
      OR msa.payouts_enabled = false
    )
) invalid_payout
WHERE p.id = invalid_payout.id
RETURNING p.id, p.email, 'payout_status_reset' AS repair_type;

-- Log the repair
DO $$
DECLARE
  v_count int;
BEGIN
  SELECT COUNT(*) INTO v_count
  FROM public.profiles p
  LEFT JOIN public.mechanic_stripe_accounts msa ON p.id = msa.mechanic_id
  WHERE p.role = 'mechanic'
    AND p.payout_method_status = 'none'
    AND p.updated_at > now() - interval '1 minute';
    
  IF v_count > 0 THEN
    PERFORM public.system_audit_log(
      'DATA_REPAIR',
      'profiles',
      NULL,
      jsonb_build_object(
        'repair_type', 'payout_status_reset_to_none',
        'count', v_count,
        'reason', 'no_valid_stripe_account'
      )
    );
  END IF;
END $$;

-- =====================================================
-- REPAIR 2C: Set payout_method_status to 'pending' for incomplete onboarding
-- =====================================================

UPDATE public.profiles p
SET 
  payout_method_status = 'pending',
  updated_at = now()
FROM public.mechanic_stripe_accounts msa
WHERE p.id = msa.mechanic_id
  AND p.role = 'mechanic'
  AND p.payout_method_status = 'none'
  AND msa.stripe_account_id IS NOT NULL
  AND msa.onboarding_complete = false;

-- =====================================================
-- REPAIR 2D: Ensure mechanics without location are flagged
-- =====================================================
-- Mark mechanic_profiles as unavailable if no location set

UPDATE public.mechanic_profiles mp
SET 
  is_available = false,
  updated_at = now()
FROM public.profiles p
WHERE mp.id = p.id
  AND p.role = 'mechanic'
  AND p.deleted_at IS NULL
  AND (p.home_lat IS NULL OR p.home_lng IS NULL)
  AND mp.is_available = true;

-- Log the repair
DO $$
DECLARE
  v_count int;
BEGIN
  SELECT COUNT(*) INTO v_count
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON mp.id = p.id
  WHERE p.role = 'mechanic'
    AND (p.home_lat IS NULL OR p.home_lng IS NULL)
    AND mp.is_available = false
    AND mp.updated_at > now() - interval '1 minute';
    
  IF v_count > 0 THEN
    PERFORM public.system_audit_log(
      'DATA_REPAIR',
      'mechanic_profiles',
      NULL,
      jsonb_build_object(
        'repair_type', 'mechanic_marked_unavailable',
        'count', v_count,
        'reason', 'missing_location_coordinates'
      )
    );
  END IF;
END $$;

-- =====================================================
-- REPAIR 2E: Normalize can_reapply for deleted profiles
-- =====================================================
-- Ensure deleted profiles have can_reapply set appropriately

UPDATE public.profiles
SET 
  can_reapply = false,
  updated_at = now()
WHERE deleted_at IS NOT NULL
  AND deleted_reason IN ('fraud', 'abuse', 'permanent_ban', 'orphan_profile_no_auth_user')
  AND (can_reapply IS NULL OR can_reapply = true);

UPDATE public.profiles
SET 
  can_reapply = true,
  updated_at = now()
WHERE deleted_at IS NOT NULL
  AND deleted_reason NOT IN ('fraud', 'abuse', 'permanent_ban', 'orphan_profile_no_auth_user')
  AND can_reapply IS NULL;

-- =====================================================
-- REPAIR 2F: Clear invalid coordinates
-- =====================================================

UPDATE public.profiles
SET 
  home_lat = NULL,
  home_lng = NULL,
  updated_at = now()
WHERE (home_lat IS NOT NULL AND (home_lat < -90 OR home_lat > 90))
   OR (home_lng IS NOT NULL AND (home_lng < -180 OR home_lng > 180));

COMMIT;


-- =====================================================
-- SECTION 3: GUARDRAILS (Constraints & Triggers)
-- =====================================================

-- =====================================================
-- GUARDRAIL 3A: Trigger to validate payout_method_status
-- =====================================================
-- Prevents setting payout_method_status='active' without valid stripe account

CREATE OR REPLACE FUNCTION public.check_payout_status_consistency()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_stripe_valid boolean := false;
BEGIN
  -- Only check for mechanics
  IF NEW.role != 'mechanic' THEN
    RETURN NEW;
  END IF;
  
  -- If setting payout_method_status to 'active', verify stripe account
  IF NEW.payout_method_status = 'active' THEN
    SELECT EXISTS (
      SELECT 1 
      FROM public.mechanic_stripe_accounts msa
      WHERE msa.mechanic_id = NEW.id
        AND msa.onboarding_complete = true
        AND msa.payouts_enabled = true
        AND msa.deleted_at IS NULL
    ) INTO v_stripe_valid;
    
    IF NOT v_stripe_valid THEN
      -- Auto-correct instead of failing
      NEW.payout_method_status := 'none';
      
      -- Log the auto-correction
      INSERT INTO public.audit_log (actor_id, actor_type, action, entity_type, entity_id, metadata)
      VALUES (
        NEW.id, 
        'system', 
        'AUTO_CORRECT_PAYOUT_STATUS',
        'profiles',
        NEW.id,
        jsonb_build_object(
          'attempted_status', 'active',
          'corrected_to', 'none',
          'reason', 'no_valid_stripe_account'
        )
      );
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_check_payout_status ON public.profiles;
CREATE TRIGGER trg_check_payout_status
  BEFORE INSERT OR UPDATE OF payout_method_status ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.check_payout_status_consistency();

-- =====================================================
-- GUARDRAIL 3B: Trigger to validate mechanic availability
-- =====================================================
-- Auto-corrects is_available if mechanic has no location

CREATE OR REPLACE FUNCTION public.check_mechanic_availability_requirements()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_has_location boolean := false;
  v_profile record;
BEGIN
  -- Only check when setting is_available to true
  IF NEW.is_available = true AND (OLD IS NULL OR OLD.is_available = false) THEN
    SELECT home_lat, home_lng, role, deleted_at
    INTO v_profile
    FROM public.profiles
    WHERE id = NEW.id;
    
    -- Check if mechanic has required location
    v_has_location := (
      v_profile.role = 'mechanic' AND
      v_profile.home_lat IS NOT NULL AND 
      v_profile.home_lng IS NOT NULL AND
      v_profile.deleted_at IS NULL
    );
    
    IF NOT v_has_location THEN
      -- Auto-correct
      NEW.is_available := false;
      
      -- Log the auto-correction
      INSERT INTO public.audit_log (actor_id, actor_type, action, entity_type, entity_id, metadata)
      VALUES (
        NEW.id, 
        'system', 
        'AUTO_CORRECT_AVAILABILITY',
        'mechanic_profiles',
        NEW.id,
        jsonb_build_object(
          'attempted_available', true,
          'corrected_to', false,
          'reason', 'missing_location_or_deleted'
        )
      );
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_check_mechanic_availability ON public.mechanic_profiles;
CREATE TRIGGER trg_check_mechanic_availability
  BEFORE INSERT OR UPDATE OF is_available ON public.mechanic_profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.check_mechanic_availability_requirements();

-- =====================================================
-- GUARDRAIL 3C: Constraint on coordinates
-- =====================================================

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'profiles_valid_lat'
  ) THEN
    ALTER TABLE public.profiles
      ADD CONSTRAINT profiles_valid_lat
      CHECK (home_lat IS NULL OR (home_lat >= -90 AND home_lat <= 90));
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'profiles_valid_lng'
  ) THEN
    ALTER TABLE public.profiles
      ADD CONSTRAINT profiles_valid_lng
      CHECK (home_lng IS NULL OR (home_lng >= -180 AND home_lng <= 180));
  END IF;
END $$;

-- =====================================================
-- GUARDRAIL 3D: Trigger to prevent orphan profile creation
-- =====================================================
-- This runs AFTER insert to verify auth.users exists

CREATE OR REPLACE FUNCTION public.verify_profile_has_auth_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Check if auth.users record exists
  IF NOT EXISTS (SELECT 1 FROM auth.users WHERE id = NEW.id) THEN
    -- Quarantine immediately
    INSERT INTO public.orphan_profiles_quarantine (profile_id, snapshot, reason)
    VALUES (NEW.id, to_jsonb(NEW), 'orphan_profile_no_auth_user_on_insert');
    
    -- Soft-delete
    UPDATE public.profiles
    SET 
      deleted_at = now(),
      deleted_reason = 'orphan_profile_no_auth_user',
      can_reapply = false
    WHERE id = NEW.id;
    
    -- Log the incident
    INSERT INTO public.audit_log (actor_id, actor_type, action, entity_type, entity_id, metadata)
    VALUES (
      NULL, 
      'system', 
      'ORPHAN_PROFILE_BLOCKED',
      'profiles',
      NEW.id,
      jsonb_build_object(
        'email', NEW.email,
        'reason', 'no_auth_user_record',
        'action_taken', 'quarantined_and_soft_deleted'
      )
    );
  END IF;
  
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_verify_profile_auth ON public.profiles;
CREATE TRIGGER trg_verify_profile_auth
  AFTER INSERT ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.verify_profile_has_auth_user();

-- =====================================================
-- GUARDRAIL 3E: Function to sync payout status from stripe
-- =====================================================
-- Call this when stripe webhook updates account status

CREATE OR REPLACE FUNCTION public.sync_payout_status_from_stripe(p_mechanic_id uuid)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_stripe record;
  v_new_status public.payout_method_status;
  v_old_status public.payout_method_status;
BEGIN
  -- Get current profile status
  SELECT payout_method_status INTO v_old_status
  FROM public.profiles
  WHERE id = p_mechanic_id;
  
  -- Get stripe account status
  SELECT * INTO v_stripe
  FROM public.mechanic_stripe_accounts
  WHERE mechanic_id = p_mechanic_id
    AND deleted_at IS NULL;
  
  -- Determine correct status
  IF v_stripe.id IS NULL THEN
    v_new_status := 'none';
  ELSIF v_stripe.onboarding_complete AND v_stripe.payouts_enabled THEN
    v_new_status := 'active';
  ELSIF v_stripe.stripe_account_id IS NOT NULL THEN
    v_new_status := 'pending';
  ELSE
    v_new_status := 'none';
  END IF;
  
  -- Update if changed
  IF v_new_status != v_old_status THEN
    UPDATE public.profiles
    SET 
      payout_method_status = v_new_status,
      updated_at = now()
    WHERE id = p_mechanic_id;
    
    -- Log the change
    PERFORM public.system_audit_log(
      'PAYOUT_STATUS_SYNCED',
      'profiles',
      p_mechanic_id,
      jsonb_build_object(
        'old_status', v_old_status,
        'new_status', v_new_status,
        'stripe_onboarding_complete', v_stripe.onboarding_complete,
        'stripe_payouts_enabled', v_stripe.payouts_enabled
      )
    );
  END IF;
  
  RETURN v_new_status::text;
END;
$$;

GRANT EXECUTE ON FUNCTION public.sync_payout_status_from_stripe(uuid) TO service_role;


-- =====================================================
-- SECTION 4: ADMIN DIAGNOSTIC RPC
-- =====================================================
-- Provides a single RPC for admins to run diagnostics

CREATE OR REPLACE FUNCTION public.admin_run_data_integrity_diagnostics()
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result jsonb := '{}'::jsonb;
  v_count int;
BEGIN
  -- Check admin
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Admin access required';
  END IF;
  
  -- Count orphan profiles
  SELECT COUNT(*) INTO v_count
  FROM public.profiles p
  LEFT JOIN auth.users u ON p.id = u.id
  WHERE u.id IS NULL AND p.deleted_at IS NULL;
  v_result := v_result || jsonb_build_object('orphan_profiles', v_count);
  
  -- Count payout mismatches
  SELECT COUNT(*) INTO v_count
  FROM public.profiles p
  LEFT JOIN public.mechanic_stripe_accounts msa ON p.id = msa.mechanic_id
  WHERE p.role = 'mechanic'
    AND p.payout_method_status = 'active'
    AND p.deleted_at IS NULL
    AND (msa.id IS NULL OR msa.onboarding_complete = false OR msa.payouts_enabled = false);
  v_result := v_result || jsonb_build_object('payout_status_mismatches', v_count);
  
  -- Count mechanics without location
  SELECT COUNT(*) INTO v_count
  FROM public.profiles p
  JOIN public.mechanic_profiles mp ON p.id = mp.id
  WHERE p.role = 'mechanic'
    AND p.deleted_at IS NULL
    AND mp.is_available = true
    AND (p.home_lat IS NULL OR p.home_lng IS NULL);
  v_result := v_result || jsonb_build_object('mechanics_available_without_location', v_count);
  
  -- Count invalid coordinates
  SELECT COUNT(*) INTO v_count
  FROM public.profiles
  WHERE (home_lat IS NOT NULL AND (home_lat < -90 OR home_lat > 90))
     OR (home_lng IS NOT NULL AND (home_lng < -180 OR home_lng > 180));
  v_result := v_result || jsonb_build_object('invalid_coordinates', v_count);
  
  -- Count quarantined (unresolved)
  SELECT COUNT(*) INTO v_count
  FROM public.orphan_profiles_quarantine
  WHERE resolved_at IS NULL;
  v_result := v_result || jsonb_build_object('quarantined_unresolved', v_count);
  
  -- Log the diagnostic run
  PERFORM public.admin_audit_log(
    'DATA_INTEGRITY_DIAGNOSTIC',
    NULL,
    NULL,
    v_result
  );
  
  RETURN v_result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_run_data_integrity_diagnostics() TO authenticated;


-- =====================================================
-- SECTION 5: ADMIN REPAIR RPC
-- =====================================================
-- Provides a single RPC for admins to run repairs

CREATE OR REPLACE FUNCTION public.admin_run_data_integrity_repairs()
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result jsonb := '{}'::jsonb;
  v_count int;
BEGIN
  -- Check admin
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Admin access required';
  END IF;
  
  -- Repair orphan profiles
  WITH quarantined AS (
    INSERT INTO public.orphan_profiles_quarantine (profile_id, snapshot, reason)
    SELECT 
      p.id,
      to_jsonb(p),
      'orphan_profile_no_auth_user'
    FROM public.profiles p
    LEFT JOIN auth.users u ON p.id = u.id
    WHERE u.id IS NULL
      AND p.deleted_at IS NULL
      AND NOT EXISTS (
        SELECT 1 FROM public.orphan_profiles_quarantine q 
        WHERE q.profile_id = p.id AND q.reason = 'orphan_profile_no_auth_user'
      )
    RETURNING profile_id
  ),
  soft_deleted AS (
    UPDATE public.profiles p
    SET 
      deleted_at = now(),
      deleted_reason = 'orphan_profile_no_auth_user',
      can_reapply = false,
      updated_at = now()
    FROM quarantined q
    WHERE p.id = q.profile_id
    RETURNING p.id
  )
  SELECT COUNT(*) INTO v_count FROM soft_deleted;
  v_result := v_result || jsonb_build_object('orphans_quarantined', v_count);
  
  -- Repair payout status
  WITH fixed AS (
    UPDATE public.profiles p
    SET 
      payout_method_status = 'none',
      updated_at = now()
    FROM (
      SELECT p2.id
      FROM public.profiles p2
      LEFT JOIN public.mechanic_stripe_accounts msa ON p2.id = msa.mechanic_id
      WHERE p2.role = 'mechanic'
        AND p2.payout_method_status = 'active'
        AND p2.deleted_at IS NULL
        AND (msa.id IS NULL OR msa.onboarding_complete = false OR msa.payouts_enabled = false)
    ) invalid
    WHERE p.id = invalid.id
    RETURNING p.id
  )
  SELECT COUNT(*) INTO v_count FROM fixed;
  v_result := v_result || jsonb_build_object('payout_statuses_fixed', v_count);
  
  -- Fix mechanics without location
  WITH fixed AS (
    UPDATE public.mechanic_profiles mp
    SET 
      is_available = false,
      updated_at = now()
    FROM public.profiles p
    WHERE mp.id = p.id
      AND p.role = 'mechanic'
      AND p.deleted_at IS NULL
      AND (p.home_lat IS NULL OR p.home_lng IS NULL)
      AND mp.is_available = true
    RETURNING mp.id
  )
  SELECT COUNT(*) INTO v_count FROM fixed;
  v_result := v_result || jsonb_build_object('mechanics_marked_unavailable', v_count);
  
  -- Clear invalid coordinates
  WITH fixed AS (
    UPDATE public.profiles
    SET 
      home_lat = NULL,
      home_lng = NULL,
      updated_at = now()
    WHERE (home_lat IS NOT NULL AND (home_lat < -90 OR home_lat > 90))
       OR (home_lng IS NOT NULL AND (home_lng < -180 OR home_lng > 180))
    RETURNING id
  )
  SELECT COUNT(*) INTO v_count FROM fixed;
  v_result := v_result || jsonb_build_object('invalid_coordinates_cleared', v_count);
  
  -- Log the repair run
  PERFORM public.admin_audit_log(
    'DATA_INTEGRITY_REPAIR',
    NULL,
    NULL,
    v_result
  );
  
  RETURN v_result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_run_data_integrity_repairs() TO authenticated;
\n-- ===================================================================
-- END: 20260125000001_data_integrity_repair.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260125000002_has_used_referral.sql
-- ===================================================================\n
-- MIGRATION: Referral Code UX Enforcement
-- 
-- Provides a dedicated RPC to check if user has ever used a referral code.
-- Source of truth: existence of row in invitations where invited_id = current_user

BEGIN;

-- Create has_used_referral function for clean frontend querying
CREATE OR REPLACE FUNCTION public.has_used_referral()
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 FROM invitations WHERE invited_id = auth.uid()
  );
$$;

GRANT EXECUTE ON FUNCTION public.has_used_referral() TO authenticated;

COMMENT ON FUNCTION public.has_used_referral() IS 
  'Returns true if the current user has ever applied a referral code. Used to hide referral input UI.';

-- Ensure defensive constraint exists on invitations.invited_id
-- This prevents a user from being invited more than once at DB level
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint 
    WHERE conname = 'invitations_invited_unique' 
    AND conrelid = 'public.invitations'::regclass
  ) THEN
    ALTER TABLE public.invitations 
      ADD CONSTRAINT invitations_invited_unique UNIQUE (invited_id);
  END IF;
EXCEPTION WHEN duplicate_object THEN
  NULL;
END $$;

COMMIT;
\n-- ===================================================================
-- END: 20260125000002_has_used_referral.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260125000003_fix_admin_tier_defaults.sql
-- ===================================================================\n
-- Fix admin RPCs to use correct tier values (probation/standard/trusted instead of bronze)
-- The mechanic_profiles.tier column uses CHECK constraint: tier IN ('probation', 'standard', 'trusted')

-- =====================================================
-- 1) Fix admin_get_mechanics - change default from 'bronze' to 'standard'
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_get_mechanics(text, uuid, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_mechanics(
  p_status text DEFAULT NULL,
  p_hub_id uuid DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  full_name text,
  email text,
  phone text,
  verification_status text,
  tier text,
  hub_id uuid,
  hub_name text,
  rating_avg numeric,
  rating_count int,
  jobs_completed int,
  is_available boolean,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT
    mp.id,
    p.full_name::text,
    p.email::text,
    p.phone::text,
    mp.verification_status::text,
    COALESCE(mp.tier, 'standard')::text as tier,
    p.hub_id,
    h.name::text as hub_name,
    mp.rating_avg,
    COALESCE(mp.rating_count, 0)::int,
    COALESCE(mp.jobs_completed, 0)::int,
    mp.is_available,
    mp.created_at
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON p.id = mp.id
  LEFT JOIN public.service_hubs h ON h.id = p.hub_id
  WHERE (p_status IS NULL OR mp.verification_status::text = p_status)
    AND (p_hub_id IS NULL OR p.hub_id = p_hub_id)
  ORDER BY mp.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_mechanics(text, uuid, int, int) TO authenticated;

-- =====================================================
-- 2) Fix admin_get_mechanic_detail - change default from 'bronze' to 'standard'
-- =====================================================
DROP FUNCTION IF EXISTS public.admin_get_mechanic_detail(uuid);

CREATE OR REPLACE FUNCTION public.admin_get_mechanic_detail(p_mechanic_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic jsonb;
  v_docs jsonb;
  v_vetting jsonb;
  v_jobs jsonb;
  v_reviews jsonb;
  v_disputes jsonb;
  v_support jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT jsonb_build_object(
    'id', mp.id,
    'full_name', p.full_name::text,
    'email', p.email::text,
    'phone', p.phone::text,
    'role', p.role::text,
    'city', p.city::text,
    'state', p.state::text,
    'hub_id', p.hub_id,
    'hub_name', h.name::text,
    'verification_status', mp.verification_status::text,
    'verification_reason', mp.verification_reason::text,
    'tier', COALESCE(mp.tier, 'standard')::text,
    'bio', mp.bio::text,
    'years_experience', mp.years_experience,
    'hourly_rate_cents', mp.hourly_rate_cents,
    'service_radius_km', mp.service_radius_km,
    'mobile_service', mp.mobile_service,
    'is_available', mp.is_available,
    'rating_avg', mp.rating_avg,
    'rating_count', COALESCE(mp.rating_count, 0),
    'jobs_completed', COALESCE(mp.jobs_completed, 0),
    'stripe_account_id', mp.stripe_account_id::text,
    'stripe_onboarding_complete', mp.stripe_onboarding_complete,
    'created_at', mp.created_at,
    'updated_at', mp.updated_at
  ) INTO v_mechanic
  FROM public.mechanic_profiles mp
  JOIN public.profiles p ON p.id = mp.id
  LEFT JOIN public.service_hubs h ON h.id = p.hub_id
  WHERE mp.id = p_mechanic_id;

  IF v_mechanic IS NULL THEN
    RETURN jsonb_build_object('error', 'Mechanic not found');
  END IF;

  SELECT jsonb_agg(jsonb_build_object(
    'id', d.id,
    'doc_type', d.doc_type::text,
    'status', d.status::text,
    'uploaded_at', d.uploaded_at,
    'reviewed_at', d.reviewed_at,
    'review_notes', d.review_notes::text
  ) ORDER BY d.uploaded_at DESC)
  INTO v_docs
  FROM public.mechanic_verification_documents d
  WHERE d.mechanic_id = p_mechanic_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', v.id,
    'question_key', v.question_key::text,
    'answer', v.answer,
    'created_at', v.created_at
  ) ORDER BY v.created_at)
  INTO v_vetting
  FROM public.mechanic_vetting_responses v
  WHERE v.mechanic_id = p_mechanic_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', j.id,
    'title', j.title::text,
    'status', j.status::text,
    'customer_name', pc.full_name::text,
    'created_at', j.created_at,
    'completed_at', j.completed_at
  ) ORDER BY j.created_at DESC)
  INTO v_jobs
  FROM (
    SELECT j.* FROM public.jobs j
    JOIN public.job_contracts jc ON jc.job_id = j.id
    WHERE jc.mechanic_id = p_mechanic_id
    ORDER BY j.created_at DESC
    LIMIT 20
  ) j
  JOIN public.profiles pc ON pc.id = j.customer_id;

  SELECT jsonb_agg(jsonb_build_object(
    'id', r.id,
    'overall_rating', r.overall_rating,
    'comment', r.comment::text,
    'reviewer_name', pr.full_name::text,
    'created_at', r.created_at
  ) ORDER BY r.created_at DESC)
  INTO v_reviews
  FROM public.reviews r
  JOIN public.profiles pr ON pr.id = r.reviewer_id
  WHERE r.reviewee_id = p_mechanic_id
  LIMIT 20;

  SELECT jsonb_agg(jsonb_build_object(
    'id', d.id,
    'job_id', d.job_id,
    'status', d.status::text,
    'category', d.category::text,
    'created_at', d.created_at,
    'resolved_at', d.resolved_at
  ) ORDER BY d.created_at DESC)
  INTO v_disputes
  FROM public.disputes d
  WHERE d.mechanic_id = p_mechanic_id
  LIMIT 10;

  SELECT jsonb_agg(jsonb_build_object(
    'id', sr.id,
    'job_id', sr.job_id,
    'category', sr.category::text,
    'status', sr.status::text,
    'message', sr.message::text,
    'created_at', sr.created_at
  ) ORDER BY sr.created_at DESC)
  INTO v_support
  FROM public.support_requests sr
  WHERE sr.user_id = p_mechanic_id
  LIMIT 10;

  RETURN jsonb_build_object(
    'mechanic', v_mechanic,
    'documents', COALESCE(v_docs, '[]'::jsonb),
    'vetting', COALESCE(v_vetting, '[]'::jsonb),
    'jobs', COALESCE(v_jobs, '[]'::jsonb),
    'reviews', COALESCE(v_reviews, '[]'::jsonb),
    'disputes', COALESCE(v_disputes, '[]'::jsonb),
    'support_requests', COALESCE(v_support, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_mechanic_detail(uuid) TO authenticated;

-- =====================================================
-- 3) Update set_mechanic_tier to validate tier values
-- =====================================================
CREATE OR REPLACE FUNCTION public.set_mechanic_tier(
  p_mechanic_id uuid,
  p_tier text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_old_tier text;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('success', false, 'error', 'Admin access required');
  END IF;

  -- Validate tier value
  IF p_tier NOT IN ('probation', 'standard', 'trusted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid tier. Must be: probation, standard, or trusted');
  END IF;

  SELECT tier INTO v_old_tier
  FROM public.mechanic_profiles
  WHERE id = p_mechanic_id;

  IF v_old_tier IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Mechanic not found');
  END IF;

  UPDATE public.mechanic_profiles
  SET tier = p_tier, updated_at = now()
  WHERE id = p_mechanic_id;

  -- Write to audit_log if function exists
  BEGIN
    PERFORM public.admin_audit_log(
      'ADMIN_SET_MECHANIC_TIER',
      'mechanic_profiles',
      p_mechanic_id,
      jsonb_build_object('old_tier', v_old_tier, 'new_tier', p_tier)
    );
  EXCEPTION WHEN undefined_function THEN
    -- admin_audit_log doesn't exist, skip
    NULL;
  END;

  RETURN jsonb_build_object('success', true, 'mechanic_id', p_mechanic_id, 'old_tier', v_old_tier, 'new_tier', p_tier);
END;
$$;

GRANT EXECUTE ON FUNCTION public.set_mechanic_tier(uuid, text) TO authenticated;
\n-- ===================================================================
-- END: 20260125000003_fix_admin_tier_defaults.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260126000001_mechanic_promo_auto_apply.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: Mechanic Promo Credit Auto-Apply
-- =====================================================
-- Fixes: Mechanic promo credits were not being auto-applied.
-- Customer credits work via apply_promo_to_payment, but mechanics
-- had no equivalent function called during contract creation.
--
-- This migration:
-- 1. Adds job_event_type enum value
-- 2. Creates mechanic_promo_applications table (parallel to payment_promo_applications)
-- 3. Adds tracking columns to job_contracts
-- 4. Creates apply_mechanic_promo_to_contract function
-- 5. Creates preview_mechanic_promo_discount function
-- 6. Updates accept_quote_and_create_contract to auto-apply mechanic promo
-- =====================================================

-- Add enum value BEFORE transaction (required for some PG versions)
DO $$
BEGIN
  ALTER TYPE public.job_event_type ADD VALUE IF NOT EXISTS 'mechanic_promo_applied';
EXCEPTION WHEN duplicate_object THEN
  NULL;
END $$;

BEGIN;

-- =====================================================
-- TABLE: mechanic_promo_applications
-- =====================================================
-- Tracks mechanic promo credit applications per contract
-- contract_id is UNIQUE to prevent double-application
CREATE TABLE IF NOT EXISTS public.mechanic_promo_applications (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  contract_id uuid NOT NULL UNIQUE REFERENCES public.job_contracts(id) ON DELETE CASCADE,
  promo_credit_id uuid NOT NULL REFERENCES public.promo_credits(id) ON DELETE RESTRICT,
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  credit_type text NOT NULL,
  commission_before_cents int NOT NULL,
  discount_cents int NOT NULL,
  commission_after_cents int NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_mechanic_promo_applications_mechanic 
  ON public.mechanic_promo_applications(mechanic_id);
CREATE INDEX IF NOT EXISTS idx_mechanic_promo_applications_credit 
  ON public.mechanic_promo_applications(promo_credit_id);

COMMENT ON TABLE public.mechanic_promo_applications IS 'Tracks promo credits applied to mechanic commissions';
COMMENT ON COLUMN public.mechanic_promo_applications.contract_id IS 'The contract this promo was applied to (UNIQUE)';
COMMENT ON COLUMN public.mechanic_promo_applications.commission_before_cents IS 'Commission before discount';
COMMENT ON COLUMN public.mechanic_promo_applications.discount_cents IS 'Amount reduced from commission';
COMMENT ON COLUMN public.mechanic_promo_applications.commission_after_cents IS 'Commission after discount';

-- RLS for mechanic_promo_applications
ALTER TABLE public.mechanic_promo_applications ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Mechanics can view their own promo applications"
  ON public.mechanic_promo_applications FOR SELECT
  USING (mechanic_id = auth.uid());

CREATE POLICY "Service role full access to mechanic_promo_applications"
  ON public.mechanic_promo_applications FOR ALL
  USING (auth.jwt() ->> 'role' = 'service_role');

-- =====================================================
-- ALTER TABLE: job_contracts - add mechanic promo tracking
-- =====================================================
ALTER TABLE public.job_contracts
ADD COLUMN IF NOT EXISTS applied_mechanic_promo_credit_id uuid REFERENCES public.promo_credits(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS mechanic_promo_discount_cents int DEFAULT 0,
ADD COLUMN IF NOT EXISTS original_mechanic_commission_cents int;

COMMENT ON COLUMN public.job_contracts.applied_mechanic_promo_credit_id IS 'Mechanic promo credit applied to this contract';
COMMENT ON COLUMN public.job_contracts.mechanic_promo_discount_cents IS 'Amount of commission discount for mechanic';
COMMENT ON COLUMN public.job_contracts.original_mechanic_commission_cents IS 'Original commission before mechanic promo discount';

CREATE INDEX IF NOT EXISTS idx_job_contracts_mechanic_promo 
  ON public.job_contracts(applied_mechanic_promo_credit_id) 
  WHERE applied_mechanic_promo_credit_id IS NOT NULL;

-- =====================================================
-- FUNCTION: preview_mechanic_promo_discount
-- =====================================================
-- Preview what discount a mechanic would get on their commission
CREATE OR REPLACE FUNCTION public.preview_mechanic_promo_discount(
  p_mechanic_id uuid DEFAULT NULL,
  p_commission_cents int DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_credit RECORD;
  v_discount_cents int;
  v_actual_commission int;
BEGIN
  v_user_id := COALESCE(p_mechanic_id, auth.uid());
  v_actual_commission := COALESCE(p_commission_cents, 0);
  
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', true,
      'has_discount', false,
      'reason', 'not_authenticated'
    );
  END IF;
  
  -- Find best available credit for this mechanic
  SELECT id, credit_type, remaining_uses
  INTO v_credit
  FROM public.promo_credits
  WHERE user_id = v_user_id
    AND remaining_uses > 0
    AND paused = false
    AND (expires_at IS NULL OR expires_at > now())
  ORDER BY 
    CASE credit_type 
      WHEN 'FEELESS' THEN 1  -- Prefer FEELESS (full waiver)
      WHEN 'FEELESS3' THEN 2 
      ELSE 3 
    END,
    created_at ASC
  LIMIT 1;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', true,
      'has_discount', false,
      'reason', 'no_eligible_credit'
    );
  END IF;
  
  -- Calculate discount based on credit type
  v_discount_cents := CASE v_credit.credit_type
    WHEN 'FEELESS' THEN v_actual_commission  -- Full commission waiver
    WHEN 'FEELESS3' THEN LEAST(300, v_actual_commission)  -- $3 off or full if less
    ELSE 0
  END;
  
  RETURN jsonb_build_object(
    'success', true,
    'has_discount', true,
    'credit_id', v_credit.id,
    'credit_type', v_credit.credit_type,
    'remaining_uses', v_credit.remaining_uses,
    'discount_cents', v_discount_cents,
    'commission_after_cents', GREATEST(0, v_actual_commission - v_discount_cents)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.preview_mechanic_promo_discount(uuid, int) TO authenticated;

-- =====================================================
-- FUNCTION: apply_mechanic_promo_to_contract
-- =====================================================
-- Applies mechanic's best available promo credit to a contract
-- Called during contract creation to reduce mechanic commission
-- Idempotent: UNIQUE constraint on contract_id prevents double-application
CREATE OR REPLACE FUNCTION public.apply_mechanic_promo_to_contract(
  p_contract_id uuid,
  p_mechanic_id uuid,
  p_commission_cents int
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_credit RECORD;
  v_discount_cents int;
  v_commission_after int;
  v_contract RECORD;
  v_existing RECORD;
BEGIN
  -- Check if already applied (idempotency)
  SELECT * INTO v_existing 
  FROM public.mechanic_promo_applications 
  WHERE contract_id = p_contract_id;
  
  IF FOUND THEN
    RAISE LOG '[MECHANIC_PROMO] Already applied to contract %, returning existing application', p_contract_id;
    RETURN jsonb_build_object(
      'success', true,
      'has_credit', true,
      'already_applied', true,
      'credit_type', v_existing.credit_type,
      'discount_cents', v_existing.discount_cents,
      'commission_after_cents', v_existing.commission_after_cents
    );
  END IF;
  
  -- Verify contract exists and belongs to mechanic
  SELECT * INTO v_contract
  FROM public.job_contracts
  WHERE id = p_contract_id AND mechanic_id = p_mechanic_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RAISE LOG '[MECHANIC_PROMO] Contract % not found or not owned by mechanic %', p_contract_id, p_mechanic_id;
    RETURN jsonb_build_object(
      'success', false,
      'has_credit', false,
      'error', 'Contract not found or not authorized'
    );
  END IF;
  
  -- Find and lock best available credit for this mechanic
  SELECT id, credit_type, remaining_uses
  INTO v_credit
  FROM public.promo_credits
  WHERE user_id = p_mechanic_id
    AND remaining_uses > 0
    AND paused = false
    AND (expires_at IS NULL OR expires_at > now())
  ORDER BY 
    CASE credit_type 
      WHEN 'FEELESS' THEN 1
      WHEN 'FEELESS3' THEN 2 
      ELSE 3 
    END,
    created_at ASC
  LIMIT 1
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RAISE LOG '[MECHANIC_PROMO] No eligible credit for mechanic %', p_mechanic_id;
    RETURN jsonb_build_object(
      'success', true,
      'has_credit', false,
      'reason', 'no_eligible_credit'
    );
  END IF;
  
  -- Calculate discount
  v_discount_cents := CASE v_credit.credit_type
    WHEN 'FEELESS' THEN p_commission_cents
    WHEN 'FEELESS3' THEN LEAST(300, p_commission_cents)
    ELSE 0
  END;
  v_commission_after := GREATEST(0, p_commission_cents - v_discount_cents);
  
  RAISE LOG '[MECHANIC_PROMO] Applying % credit (%) to contract %, discount: % cents', 
    v_credit.credit_type, v_credit.id, p_contract_id, v_discount_cents;
  
  -- Decrement remaining uses
  UPDATE public.promo_credits
  SET remaining_uses = remaining_uses - 1,
      updated_at = now()
  WHERE id = v_credit.id;
  
  -- Record application (UNIQUE constraint ensures idempotency)
  INSERT INTO public.mechanic_promo_applications (
    contract_id, promo_credit_id, mechanic_id, credit_type,
    commission_before_cents, discount_cents, commission_after_cents
  ) VALUES (
    p_contract_id, v_credit.id, p_mechanic_id, v_credit.credit_type,
    p_commission_cents, v_discount_cents, v_commission_after
  );
  
  -- Update contract with promo info
  UPDATE public.job_contracts
  SET applied_mechanic_promo_credit_id = v_credit.id,
      mechanic_promo_discount_cents = v_discount_cents,
      original_mechanic_commission_cents = p_commission_cents,
      mechanic_commission_cents = v_commission_after,
      mechanic_payout_cents = quoted_price_cents - v_commission_after
  WHERE id = p_contract_id;
  
  RAISE LOG '[MECHANIC_PROMO] Successfully applied to contract %, new commission: % cents, new payout: % cents',
    p_contract_id, v_commission_after, (SELECT mechanic_payout_cents FROM public.job_contracts WHERE id = p_contract_id);
  
  RETURN jsonb_build_object(
    'success', true,
    'has_credit', true,
    'credit_id', v_credit.id,
    'credit_type', v_credit.credit_type,
    'discount_cents', v_discount_cents,
    'commission_after_cents', v_commission_after
  );
EXCEPTION WHEN unique_violation THEN
  -- Another transaction already applied - return existing
  SELECT * INTO v_existing 
  FROM public.mechanic_promo_applications 
  WHERE contract_id = p_contract_id;
  
  RAISE LOG '[MECHANIC_PROMO] Concurrent application detected for contract %, returning existing', p_contract_id;
  RETURN jsonb_build_object(
    'success', true,
    'has_credit', true,
    'already_applied', true,
    'credit_type', v_existing.credit_type,
    'discount_cents', v_existing.discount_cents,
    'commission_after_cents', v_existing.commission_after_cents
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.apply_mechanic_promo_to_contract(uuid, uuid, int) TO authenticated;
GRANT EXECUTE ON FUNCTION public.apply_mechanic_promo_to_contract(uuid, uuid, int) TO service_role;

-- =====================================================
-- FUNCTION: get_contract_mechanic_promo_info
-- =====================================================
-- Returns promo info for a contract (for UI display)
CREATE OR REPLACE FUNCTION public.get_contract_mechanic_promo_info(p_contract_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_app RECORD;
BEGIN
  SELECT mpa.*, jc.mechanic_id
  INTO v_app
  FROM public.mechanic_promo_applications mpa
  JOIN public.job_contracts jc ON jc.id = mpa.contract_id
  WHERE mpa.contract_id = p_contract_id
    AND (jc.mechanic_id = auth.uid() OR jc.customer_id = auth.uid());
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'has_promo', false
    );
  END IF;
  
  RETURN jsonb_build_object(
    'has_promo', true,
    'credit_type', v_app.credit_type,
    'commission_before_cents', v_app.commission_before_cents,
    'discount_cents', v_app.discount_cents,
    'commission_after_cents', v_app.commission_after_cents,
    'discount_description', CASE v_app.credit_type
      WHEN 'FEELESS' THEN 'Free commission (referral credit)'
      WHEN 'FEELESS3' THEN '$3 off commission (referral credit)'
      ELSE 'Promo discount'
    END
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_contract_mechanic_promo_info(uuid) TO authenticated;

-- =====================================================
-- UPDATED FUNCTION: accept_quote_and_create_contract
-- =====================================================
-- Now auto-applies mechanic promo credit after contract creation
CREATE OR REPLACE FUNCTION accept_quote_and_create_contract(
  p_quote_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_quote RECORD;
  v_job RECORD;
  v_contract_id uuid;
  v_progress_id uuid;
  v_platform_fee_cents int := 1500;
  v_commission_cents int;
  v_total_customer_cents int;
  v_mechanic_payout_cents int;
  v_line_item_id uuid;
  v_terms_check jsonb;
  v_mechanic_promo_result jsonb;
BEGIN
  -- ENFORCEMENT: Check platform terms accepted
  v_terms_check := public.check_terms_accepted('customer');
  IF NOT (v_terms_check->>'accepted')::boolean THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Please accept platform terms first',
      'requires_terms', true,
      'terms_version', v_terms_check->>'version'
    );
  END IF;

  -- Get quote with lock
  SELECT q.*, j.customer_id as job_customer_id, j.status as job_status, j.id as actual_job_id
  INTO v_quote
  FROM public.quotes q
  JOIN public.jobs j ON j.id = q.job_id
  WHERE q.id = p_quote_id
  FOR UPDATE OF q, j;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote not found');
  END IF;
  
  IF v_quote.job_customer_id != p_customer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  IF v_quote.status != 'pending' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote is no longer available');
  END IF;
  
  IF v_quote.job_status NOT IN ('searching', 'quoted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job is no longer accepting quotes');
  END IF;
  
  -- ENFORCEMENT: Check job acknowledgement exists
  IF NOT EXISTS (
    SELECT 1 FROM public.job_acknowledgements
    WHERE job_id = v_quote.actual_job_id 
    AND user_id = p_customer_id 
    AND role = 'customer'
  ) THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Please acknowledge job terms first',
      'requires_acknowledgement', true,
      'job_id', v_quote.actual_job_id
    );
  END IF;
  
  -- Calculate fees (initial, before mechanic promo)
  v_commission_cents := calculate_mechanic_commission(v_quote.price_cents);
  v_total_customer_cents := v_quote.price_cents + v_platform_fee_cents;
  v_mechanic_payout_cents := v_quote.price_cents - v_commission_cents;
  
  -- Create contract
  INSERT INTO public.job_contracts (
    job_id, quote_id, customer_id, mechanic_id,
    status, quoted_price_cents, platform_fee_cents, estimated_hours,
    subtotal_cents, total_customer_cents, mechanic_commission_cents, mechanic_payout_cents,
    customer_acknowledged_at
  ) VALUES (
    v_quote.job_id, p_quote_id, p_customer_id, v_quote.mechanic_id,
    'active', v_quote.price_cents, v_platform_fee_cents, v_quote.estimated_hours,
    v_quote.price_cents, v_total_customer_cents, v_commission_cents, v_mechanic_payout_cents,
    now()
  )
  RETURNING id INTO v_contract_id;
  
  -- =====================================================
  -- AUTO-APPLY MECHANIC PROMO CREDIT
  -- =====================================================
  -- This is the key fix: apply mechanic's promo credit to reduce their commission
  v_mechanic_promo_result := public.apply_mechanic_promo_to_contract(
    v_contract_id,
    v_quote.mechanic_id,
    v_commission_cents
  );
  
  -- Log mechanic promo application result
  IF (v_mechanic_promo_result->>'has_credit')::boolean THEN
    RAISE LOG '[CONTRACT_CREATE] Mechanic promo applied to contract %: type=%, discount=% cents',
      v_contract_id, 
      v_mechanic_promo_result->>'credit_type',
      v_mechanic_promo_result->>'discount_cents';
    
    -- Log job event for mechanic promo
    PERFORM log_job_event(
      v_quote.job_id, v_contract_id, 'mechanic_promo_applied',
      v_quote.mechanic_id, 'mechanic',
      'Promo credit applied',
      'Mechanic promo credit reduced commission',
      jsonb_build_object(
        'credit_type', v_mechanic_promo_result->>'credit_type',
        'discount_cents', (v_mechanic_promo_result->>'discount_cents')::int,
        'commission_before_cents', v_commission_cents,
        'commission_after_cents', (v_mechanic_promo_result->>'commission_after_cents')::int
      ),
      (v_mechanic_promo_result->>'discount_cents')::int
    );
  ELSE
    RAISE LOG '[CONTRACT_CREATE] No mechanic promo for contract %: reason=%',
      v_contract_id, 
      COALESCE(v_mechanic_promo_result->>'reason', 'unknown');
  END IF;
  
  -- Update job_acknowledgements with contract_id
  UPDATE public.job_acknowledgements
  SET contract_id = v_contract_id
  WHERE job_id = v_quote.job_id AND user_id = p_customer_id AND role = 'customer';
  
  -- Create initial line item for base labor
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'base_labor', 'Service as quoted', 1, v_quote.price_cents, v_quote.price_cents,
    'approved', false, v_quote.mechanic_id, 'mechanic', 0
  )
  RETURNING id INTO v_line_item_id;
  
  -- Create platform fee line item
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'platform_fee', 'WrenchGo platform fee', 1, v_platform_fee_cents, v_platform_fee_cents,
    'approved', false, p_customer_id, 'customer', 100
  );
  
  -- Create job progress record
  INSERT INTO public.job_progress (job_id, contract_id)
  VALUES (v_quote.job_id, v_contract_id)
  RETURNING id INTO v_progress_id;
  
  -- Update quote status
  UPDATE public.quotes
  SET status = 'accepted', updated_at = now()
  WHERE id = p_quote_id;
  
  -- Decline all other quotes for this job
  UPDATE public.quotes
  SET status = 'declined', updated_at = now()
  WHERE job_id = v_quote.job_id AND id != p_quote_id;
  
  -- Update job status
  UPDATE public.jobs
  SET 
    status = 'accepted',
    accepted_mechanic_id = v_quote.mechanic_id,
    updated_at = now()
  WHERE id = v_quote.job_id;
  
  -- Log event
  PERFORM log_job_event(
    v_quote.job_id, v_contract_id, 'contract_created',
    p_customer_id, 'customer',
    'Contract created',
    'Quote accepted and contract created',
    jsonb_build_object(
      'quoted_price_cents', v_quote.price_cents,
      'platform_fee_cents', v_platform_fee_cents,
      'total_cents', v_total_customer_cents,
      'mechanic_promo_applied', (v_mechanic_promo_result->>'has_credit')::boolean,
      'mechanic_promo_discount_cents', COALESCE((v_mechanic_promo_result->>'discount_cents')::int, 0)
    ),
    v_total_customer_cents
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'contract_id', v_contract_id,
    'total_cents', v_total_customer_cents,
    'mechanic_id', v_quote.mechanic_id,
    'mechanic_promo_applied', (v_mechanic_promo_result->>'has_credit')::boolean,
    'mechanic_promo_discount_cents', COALESCE((v_mechanic_promo_result->>'discount_cents')::int, 0)
  );
END;
$$;

COMMIT;
\n-- ===================================================================
-- END: 20260126000001_mechanic_promo_auto_apply.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260126000002_add_mechanic_promo_event_type.sql
-- ===================================================================\n
-- Add missing enum value for mechanic promo events
DO $$ 
BEGIN 
  ALTER TYPE public.job_event_type ADD VALUE IF NOT EXISTS 'mechanic_promo_applied';
EXCEPTION WHEN duplicate_object THEN 
  NULL;
END $$;
\n-- ===================================================================
-- END: 20260126000002_add_mechanic_promo_event_type.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000001_admin_messaging.sql
-- ===================================================================\n
-- =====================================================
-- Admin Messaging System
-- Separate table for admin-to-user messages (account-level)
-- This avoids requiring a job_id which is mandatory in public.messages
-- =====================================================

-- 1. Create admin_messages table
CREATE TABLE IF NOT EXISTS public.admin_messages (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  sender_admin_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  recipient_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  body text NOT NULL,
  related_job_id uuid REFERENCES public.jobs(id) ON DELETE SET NULL,
  related_support_request_id uuid REFERENCES public.support_requests(id) ON DELETE SET NULL,
  related_dispute_id uuid REFERENCES public.disputes(id) ON DELETE SET NULL,
  attachment_url text,
  attachment_type text CHECK (attachment_type IS NULL OR attachment_type IN ('image', 'file')),
  read_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  deleted_at timestamptz,
  
  CONSTRAINT body_length CHECK (char_length(body) >= 1 AND char_length(body) <= 4000)
);

-- 2. Create indexes
CREATE INDEX IF NOT EXISTS idx_admin_messages_recipient_created 
  ON public.admin_messages(recipient_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_admin_messages_job 
  ON public.admin_messages(related_job_id) WHERE related_job_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_admin_messages_support 
  ON public.admin_messages(related_support_request_id) WHERE related_support_request_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_admin_messages_dispute 
  ON public.admin_messages(related_dispute_id) WHERE related_dispute_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_admin_messages_sender 
  ON public.admin_messages(sender_admin_id);

-- 3. Enable RLS
ALTER TABLE public.admin_messages ENABLE ROW LEVEL SECURITY;

-- 4. RLS Policies

-- Recipients can read their own messages
CREATE POLICY admin_messages_recipient_select ON public.admin_messages
  FOR SELECT TO authenticated
  USING (
    recipient_id = auth.uid() 
    AND deleted_at IS NULL
  );

-- Admins can read all messages
CREATE POLICY admin_messages_admin_select ON public.admin_messages
  FOR SELECT TO authenticated
  USING (public.is_admin());

-- Only admins can insert (via RPC, but policy as fallback)
CREATE POLICY admin_messages_admin_insert ON public.admin_messages
  FOR INSERT TO authenticated
  WITH CHECK (public.is_admin());

-- Recipients can update only read_at
CREATE POLICY admin_messages_recipient_update ON public.admin_messages
  FOR UPDATE TO authenticated
  USING (recipient_id = auth.uid())
  WITH CHECK (recipient_id = auth.uid());

-- Admins can update (for soft delete)
CREATE POLICY admin_messages_admin_update ON public.admin_messages
  FOR UPDATE TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

-- No hard deletes allowed
CREATE POLICY admin_messages_no_delete ON public.admin_messages
  FOR DELETE TO authenticated
  USING (false);

-- =====================================================
-- 5. RPCs
-- =====================================================

-- Send admin message
CREATE OR REPLACE FUNCTION public.admin_send_message(
  p_recipient_id uuid,
  p_body text,
  p_related_job_id uuid DEFAULT NULL,
  p_support_request_id uuid DEFAULT NULL,
  p_dispute_id uuid DEFAULT NULL,
  p_attachment_url text DEFAULT NULL,
  p_attachment_type text DEFAULT NULL
)
RETURNS public.admin_messages
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id uuid;
  v_new_message public.admin_messages;
  v_recipient_exists boolean;
  v_job_participant boolean := true;
BEGIN
  v_admin_id := auth.uid();
  
  -- Check admin permission
  IF NOT public.is_admin(v_admin_id) THEN
    RAISE EXCEPTION 'Permission denied: admin role required';
  END IF;
  
  -- Validate recipient exists
  SELECT EXISTS(SELECT 1 FROM public.profiles WHERE id = p_recipient_id)
  INTO v_recipient_exists;
  
  IF NOT v_recipient_exists THEN
    RAISE EXCEPTION 'Recipient not found';
  END IF;
  
  -- Validate body length
  IF p_body IS NULL OR char_length(trim(p_body)) < 1 THEN
    RAISE EXCEPTION 'Message body is required';
  END IF;
  
  IF char_length(p_body) > 4000 THEN
    RAISE EXCEPTION 'Message body exceeds 4000 characters';
  END IF;
  
  -- Validate attachment_type if provided
  IF p_attachment_type IS NOT NULL AND p_attachment_type NOT IN ('image', 'file') THEN
    RAISE EXCEPTION 'Invalid attachment type';
  END IF;
  
  -- If job is linked, check if recipient is part of job (log warning but allow)
  IF p_related_job_id IS NOT NULL THEN
    SELECT EXISTS(
      SELECT 1 FROM public.jobs j
      LEFT JOIN public.job_contracts c ON c.job_id = j.id
      WHERE j.id = p_related_job_id
        AND (j.customer_id = p_recipient_id OR c.mechanic_id = p_recipient_id)
    ) INTO v_job_participant;
  END IF;
  
  -- Insert the message
  INSERT INTO public.admin_messages (
    sender_admin_id,
    recipient_id,
    body,
    related_job_id,
    related_support_request_id,
    related_dispute_id,
    attachment_url,
    attachment_type
  ) VALUES (
    v_admin_id,
    p_recipient_id,
    trim(p_body),
    p_related_job_id,
    p_support_request_id,
    p_dispute_id,
    p_attachment_url,
    p_attachment_type
  )
  RETURNING * INTO v_new_message;
  
  -- Write audit log
  INSERT INTO public.message_audit_logs (
    message_id,
    action,
    actor_id,
    metadata
  ) VALUES (
    v_new_message.id,
    'ADMIN_SEND_MESSAGE',
    v_admin_id,
    jsonb_build_object(
      'recipient_id', p_recipient_id,
      'related_job_id', p_related_job_id,
      'related_support_request_id', p_support_request_id,
      'related_dispute_id', p_dispute_id,
      'job_participant', v_job_participant
    )
  );
  
  -- If job linked, write job_event
  IF p_related_job_id IS NOT NULL THEN
    INSERT INTO public.job_events (
      job_id,
      event_type,
      actor_id,
      actor_role,
      visible_to_customer,
      visible_to_mechanic,
      metadata
    ) VALUES (
      p_related_job_id,
      'admin_message_sent',
      v_admin_id,
      'admin',
      true,
      true,
      jsonb_build_object(
        'admin_message_id', v_new_message.id,
        'recipient_id', p_recipient_id
      )
    );
  END IF;
  
  RETURN v_new_message;
END;
$$;

-- List user's admin messages
CREATE OR REPLACE FUNCTION public.list_my_admin_messages(
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  sender_admin_id uuid,
  sender_name text,
  body text,
  related_job_id uuid,
  related_job_title text,
  related_support_request_id uuid,
  related_dispute_id uuid,
  attachment_url text,
  attachment_type text,
  read_at timestamptz,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    am.id,
    am.sender_admin_id,
    COALESCE(p.full_name, 'Support Team') as sender_name,
    am.body,
    am.related_job_id,
    j.title as related_job_title,
    am.related_support_request_id,
    am.related_dispute_id,
    am.attachment_url,
    am.attachment_type,
    am.read_at,
    am.created_at
  FROM public.admin_messages am
  LEFT JOIN public.profiles p ON p.id = am.sender_admin_id
  LEFT JOIN public.jobs j ON j.id = am.related_job_id
  WHERE am.recipient_id = auth.uid()
    AND am.deleted_at IS NULL
  ORDER BY am.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

-- Mark message as read
CREATE OR REPLACE FUNCTION public.mark_admin_message_read(p_message_id uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_updated boolean;
BEGIN
  UPDATE public.admin_messages
  SET read_at = now()
  WHERE id = p_message_id
    AND recipient_id = auth.uid()
    AND read_at IS NULL
    AND deleted_at IS NULL;
  
  GET DIAGNOSTICS v_updated = ROW_COUNT;
  RETURN v_updated > 0;
END;
$$;

-- Admin list user's messages (for admin user detail view)
CREATE OR REPLACE FUNCTION public.admin_list_user_messages(
  p_user_id uuid,
  p_limit int DEFAULT 100
)
RETURNS TABLE (
  id uuid,
  sender_admin_id uuid,
  sender_name text,
  recipient_id uuid,
  body text,
  related_job_id uuid,
  related_support_request_id uuid,
  related_dispute_id uuid,
  attachment_url text,
  attachment_type text,
  read_at timestamptz,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Permission denied: admin role required';
  END IF;
  
  RETURN QUERY
  SELECT 
    am.id,
    am.sender_admin_id,
    COALESCE(p.full_name, 'Support Team') as sender_name,
    am.recipient_id,
    am.body,
    am.related_job_id,
    am.related_support_request_id,
    am.related_dispute_id,
    am.attachment_url,
    am.attachment_type,
    am.read_at,
    am.created_at
  FROM public.admin_messages am
  LEFT JOIN public.profiles p ON p.id = am.sender_admin_id
  WHERE am.recipient_id = p_user_id
    AND am.deleted_at IS NULL
  ORDER BY am.created_at DESC
  LIMIT p_limit;
END;
$$;

-- Get unread admin message count for user
CREATE OR REPLACE FUNCTION public.get_unread_admin_message_count()
RETURNS int
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT COUNT(*)::int
  FROM public.admin_messages
  WHERE recipient_id = auth.uid()
    AND read_at IS NULL
    AND deleted_at IS NULL;
$$;

-- Grant permissions
GRANT SELECT, INSERT, UPDATE ON public.admin_messages TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_send_message TO authenticated;
GRANT EXECUTE ON FUNCTION public.list_my_admin_messages TO authenticated;
GRANT EXECUTE ON FUNCTION public.mark_admin_message_read TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_list_user_messages TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_unread_admin_message_count TO authenticated;
\n-- ===================================================================
-- END: 20260127000001_admin_messaging.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000002_create_storage_buckets.sql
-- ===================================================================\n
-- Create storage buckets for the application
-- This migration ensures all required buckets exist

-- job-media bucket (for job photos, evidence, etc.)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'job-media',
  'job-media',
  true,
  10485760, -- 10MB
  ARRAY['image/jpeg', 'image/png', 'image/webp', 'image/heic']
)
ON CONFLICT (id) DO UPDATE SET
  public = EXCLUDED.public,
  file_size_limit = EXCLUDED.file_size_limit,
  allowed_mime_types = EXCLUDED.allowed_mime_types;

-- avatars bucket (for profile photos)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'avatars',
  'avatars',
  true,
  5242880, -- 5MB
  ARRAY['image/jpeg', 'image/png', 'image/webp', 'image/heic']
)
ON CONFLICT (id) DO UPDATE SET
  public = EXCLUDED.public,
  file_size_limit = EXCLUDED.file_size_limit,
  allowed_mime_types = EXCLUDED.allowed_mime_types;

-- chat-attachments bucket (for messaging attachments)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'chat-attachments',
  'chat-attachments',
  false,
  10485760, -- 10MB
  ARRAY['image/jpeg', 'image/png', 'image/webp', 'application/pdf']
)
ON CONFLICT (id) DO UPDATE SET
  public = EXCLUDED.public,
  file_size_limit = EXCLUDED.file_size_limit,
  allowed_mime_types = EXCLUDED.allowed_mime_types;

-- support-screenshots bucket (for support request attachments)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'support-screenshots',
  'support-screenshots',
  false,
  10485760, -- 10MB
  ARRAY['image/jpeg', 'image/png', 'image/webp']
)
ON CONFLICT (id) DO UPDATE SET
  public = EXCLUDED.public,
  file_size_limit = EXCLUDED.file_size_limit,
  allowed_mime_types = EXCLUDED.allowed_mime_types;
\n-- ===================================================================
-- END: 20260127000002_create_storage_buckets.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000003_add_media_uploaded_event_type.sql
-- ===================================================================\n
-- Add media_uploaded to job_event_type enum
DO $$
BEGIN
  ALTER TYPE public.job_event_type ADD VALUE IF NOT EXISTS 'media_uploaded';
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;
\n-- ===================================================================
-- END: 20260127000003_add_media_uploaded_event_type.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000004_fix_job_media_event_title.sql
-- ===================================================================\n
-- Drop all overloaded versions of create_job_media_record
DROP FUNCTION IF EXISTS public.create_job_media_record(uuid, text, text, text, int, uuid, text, timestamptz);
DROP FUNCTION IF EXISTS public.create_job_media_record(uuid, text, text, text, bigint, uuid, text, timestamptz);

-- Recreate with bigint for file size
CREATE OR REPLACE FUNCTION public.create_job_media_record(
  p_job_id uuid,
  p_media_category text,
  p_path text,
  p_mime_type text,
  p_file_size_bytes bigint,
  p_contract_id uuid DEFAULT NULL,
  p_caption text DEFAULT NULL,
  p_taken_at timestamptz DEFAULT now()
)
RETURNS public.job_media
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_user_role public.user_role;
  v_result public.job_media;
  v_title text;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT role INTO v_user_role FROM public.profiles WHERE id = v_user_id;

  -- Check authorization
  IF v_user_role = 'admin' THEN
    NULL;
  ELSIF v_user_role = 'customer' THEN
    IF NOT EXISTS (SELECT 1 FROM public.jobs WHERE id = p_job_id AND customer_id = v_user_id) THEN
      RAISE EXCEPTION 'Not authorized to upload to this job';
    END IF;
  ELSIF v_user_role = 'mechanic' THEN
    IF NOT EXISTS (
      SELECT 1 FROM public.job_contracts 
      WHERE job_id = p_job_id AND mechanic_id = v_user_id
    ) THEN
      RAISE EXCEPTION 'Not authorized to upload to this job';
    END IF;
  ELSE
    RAISE EXCEPTION 'Not authorized';
  END IF;

  INSERT INTO public.job_media (
    job_id,
    contract_id,
    uploaded_by,
    uploaded_by_role,
    media_type,
    media_category,
    bucket,
    path,
    caption,
    file_size_bytes,
    mime_type,
    taken_at
  ) VALUES (
    p_job_id,
    p_contract_id,
    v_user_id,
    v_user_role,
    'image',
    p_media_category,
    'job-media',
    p_path,
    p_caption,
    p_file_size_bytes,
    p_mime_type,
    p_taken_at
  )
  RETURNING * INTO v_result;

  v_title := CASE p_media_category
    WHEN 'customer_initial' THEN 'Customer uploaded initial photo'
    WHEN 'mechanic_before' THEN 'Mechanic uploaded before photo'
    WHEN 'mechanic_after' THEN 'Mechanic uploaded after photo'
    WHEN 'mechanic_diagnostic' THEN 'Mechanic uploaded diagnostic photo'
    WHEN 'customer_evidence' THEN 'Customer uploaded evidence'
    WHEN 'mechanic_evidence' THEN 'Mechanic uploaded evidence'
    ELSE 'Photo uploaded'
  END;

  INSERT INTO public.job_events (
    job_id,
    contract_id,
    event_type,
    actor_id,
    actor_role,
    title,
    metadata
  ) VALUES (
    p_job_id,
    p_contract_id,
    'media_uploaded',
    v_user_id,
    v_user_role,
    v_title,
    jsonb_build_object(
      'media_id', v_result.id,
      'category', p_media_category,
      'role', v_user_role::text
    )
  );

  RETURN v_result;
END;
$$;
\n-- ===================================================================
-- END: 20260127000004_fix_job_media_event_title.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000005_fix_job_media_function_overload.sql
-- ===================================================================\n
-- Aggressively drop ALL variants of create_job_media_record
DROP FUNCTION IF EXISTS public.create_job_media_record(uuid, text, text, text, int, uuid, text, timestamptz);
DROP FUNCTION IF EXISTS public.create_job_media_record(uuid, text, text, text, bigint, uuid, text, timestamptz);
DROP FUNCTION IF EXISTS public.create_job_media_record(uuid, text, text, text, integer, uuid, text, timestamptz);

-- Also try with explicit parameter names
DROP FUNCTION IF EXISTS public.create_job_media_record(
  p_job_id uuid,
  p_media_category text,
  p_path text,
  p_mime_type text,
  p_file_size_bytes int,
  p_contract_id uuid,
  p_caption text,
  p_taken_at timestamptz
);

DROP FUNCTION IF EXISTS public.create_job_media_record(
  p_job_id uuid,
  p_media_category text,
  p_path text,
  p_mime_type text,
  p_file_size_bytes bigint,
  p_contract_id uuid,
  p_caption text,
  p_taken_at timestamptz
);

-- Recreate with int (matching original schema)
CREATE OR REPLACE FUNCTION public.create_job_media_record(
  p_job_id uuid,
  p_media_category text,
  p_path text,
  p_mime_type text,
  p_file_size_bytes int,
  p_contract_id uuid DEFAULT NULL,
  p_caption text DEFAULT NULL,
  p_taken_at timestamptz DEFAULT now()
)
RETURNS public.job_media
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_user_role public.user_role;
  v_result public.job_media;
  v_title text;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT role INTO v_user_role FROM public.profiles WHERE id = v_user_id;

  IF v_user_role = 'admin' THEN
    NULL;
  ELSIF v_user_role = 'customer' THEN
    IF NOT EXISTS (SELECT 1 FROM public.jobs WHERE id = p_job_id AND customer_id = v_user_id) THEN
      RAISE EXCEPTION 'Not authorized to upload to this job';
    END IF;
  ELSIF v_user_role = 'mechanic' THEN
    IF NOT EXISTS (
      SELECT 1 FROM public.job_contracts 
      WHERE job_id = p_job_id AND mechanic_id = v_user_id
    ) THEN
      RAISE EXCEPTION 'Not authorized to upload to this job';
    END IF;
  ELSE
    RAISE EXCEPTION 'Not authorized';
  END IF;

  INSERT INTO public.job_media (
    job_id, contract_id, uploaded_by, uploaded_by_role, media_type,
    media_category, bucket, path, caption, file_size_bytes, mime_type, taken_at
  ) VALUES (
    p_job_id, p_contract_id, v_user_id, v_user_role, 'image',
    p_media_category, 'job-media', p_path, p_caption, p_file_size_bytes, p_mime_type, p_taken_at
  )
  RETURNING * INTO v_result;

  v_title := CASE p_media_category
    WHEN 'customer_initial' THEN 'Customer uploaded initial photo'
    WHEN 'mechanic_before' THEN 'Mechanic uploaded before photo'
    WHEN 'mechanic_after' THEN 'Mechanic uploaded after photo'
    WHEN 'mechanic_diagnostic' THEN 'Mechanic uploaded diagnostic photo'
    WHEN 'customer_evidence' THEN 'Customer uploaded evidence'
    WHEN 'mechanic_evidence' THEN 'Mechanic uploaded evidence'
    ELSE 'Photo uploaded'
  END;

  INSERT INTO public.job_events (
    job_id, contract_id, event_type, actor_id, actor_role, title, metadata
  ) VALUES (
    p_job_id, p_contract_id, 'media_uploaded', v_user_id, v_user_role, v_title,
    jsonb_build_object('media_id', v_result.id, 'category', p_media_category, 'role', v_user_role::text)
  );

  RETURN v_result;
END;
$$;
\n-- ===================================================================
-- END: 20260127000005_fix_job_media_function_overload.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000006_add_mechanic_verification_tier.sql
-- ===================================================================\n
-- Add verification status and tier level for mechanics

-- Create enum for verification status
DO $$ BEGIN
  CREATE TYPE public.mechanic_verification_status AS ENUM ('unverified', 'pending', 'verified', 'suspended');
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- Create enum for mechanic tier
DO $$ BEGIN
  CREATE TYPE public.mechanic_tier AS ENUM ('bronze', 'silver', 'gold', 'platinum');
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- Add columns to profiles table
ALTER TABLE public.profiles 
  ADD COLUMN IF NOT EXISTS verification_status public.mechanic_verification_status DEFAULT 'unverified',
  ADD COLUMN IF NOT EXISTS mechanic_tier public.mechanic_tier DEFAULT 'bronze',
  ADD COLUMN IF NOT EXISTS verified_at timestamptz,
  ADD COLUMN IF NOT EXISTS verified_by uuid REFERENCES public.profiles(id);

-- Update get_public_profile_card to include verification status and tier
CREATE OR REPLACE FUNCTION public.get_public_profile_card(p_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  result jsonb;
  profile_ratings jsonb;
  profile_badges jsonb;
  profile_skills jsonb;
  profile_trust_score jsonb;
  v_role text;
  v_profile_id uuid;
  v_total_jobs bigint := 0;
  v_completed_jobs bigint := 0;
BEGIN
  -- Get user role and profile id
  SELECT p.role, p.id INTO v_role, v_profile_id
  FROM profiles p
  WHERE p.id = p_user_id
    AND p.deleted_at IS NULL;

  IF v_profile_id IS NULL THEN
    RETURN NULL;
  END IF;

  -- Count jobs based on role
  IF v_role = 'customer' THEN
    SELECT 
      COALESCE(COUNT(*), 0),
      COALESCE(COUNT(*) FILTER (WHERE j.status = 'completed'), 0)
    INTO v_total_jobs, v_completed_jobs
    FROM jobs j
    WHERE j.customer_id = v_profile_id;
  ELSE
    SELECT 
      COALESCE(COUNT(*), 0),
      COALESCE(COUNT(*) FILTER (WHERE j.status = 'completed'), 0)
    INTO v_total_jobs, v_completed_jobs
    FROM jobs j
    WHERE j.accepted_mechanic_id = v_profile_id;
  END IF;

  -- Get ratings data
  SELECT jsonb_build_object(
    'overall_avg', COALESCE(AVG(r.overall_rating), 0),
    'performance_avg', COALESCE(AVG(r.performance_rating), 0),
    'timing_avg', COALESCE(AVG(r.timing_rating), 0),
    'cost_avg', COALESCE(AVG(r.cost_rating), 0),
    'professionalism_avg', COALESCE(AVG(r.professionalism_rating), 0),
    'communication_avg', COALESCE(AVG(r.communication_rating), 0),
    'punctuality_avg', COALESCE(AVG(r.punctuality_rating), 0),
    'payment_avg', COALESCE(AVG(r.payment_rating), 0),
    'review_count', COALESCE(COUNT(r.id), 0)::integer,
    'would_recommend_count', COALESCE(COUNT(r.id) FILTER (WHERE r.would_recommend = true), 0)::integer,
    'would_recommend_total', COALESCE(COUNT(r.id) FILTER (WHERE r.would_recommend IS NOT NULL), 0)::integer
  )
  INTO profile_ratings
  FROM reviews r
  WHERE r.reviewee_id = p_user_id;

  -- Get badges data
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ub.id,
      'badge_id', ub.badge_id,
      'awarded_at', ub.created_at,
      'badge', jsonb_build_object(
        'code', b.code,
        'title', b.title,
        'description', COALESCE(b.description, ''),
        'icon', COALESCE(b.icon, ''),
        'category', COALESCE(b.badge_type, 'earned'),
        'tier', 1
      )
    )
  ), '[]'::jsonb)
  INTO profile_badges
  FROM user_badges ub
  INNER JOIN badges b ON b.id = ub.badge_id
  WHERE ub.user_id = p_user_id;

  -- Get skills data (for mechanics only)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ms.id,
      'is_verified', COALESCE(ms.is_verified, false),
      'verified_job_count', 0,
      'avg_job_rating', null,
      'skill', jsonb_build_object(
        'key', s.key,
        'label', s.label,
        'name', s.label,
        'category', COALESCE(s.category, 'general')
      )
    )
  ), '[]'::jsonb)
  INTO profile_skills
  FROM mechanic_skills ms
  INNER JOIN skills s ON s.key = ms.skill_key
  WHERE ms.mechanic_id = p_user_id;

  -- Build trust score with actual job counts
  profile_trust_score := jsonb_build_object(
    'overall_score', 50,
    'rating_score', CASE WHEN COALESCE((profile_ratings->>'review_count')::int, 0) > 0 
      THEN LEAST(100, COALESCE((profile_ratings->>'overall_avg')::numeric, 0) * 20) 
      ELSE 50 END,
    'completion_score', CASE WHEN v_total_jobs > 0 
      THEN LEAST(100, (v_completed_jobs::numeric / v_total_jobs::numeric) * 100)
      ELSE 50 END,
    'reliability_score', 50,
    'badge_score', LEAST(100, COALESCE(jsonb_array_length(profile_badges), 0) * 20),
    'tenure_score', 50,
    'completed_jobs', COALESCE(v_completed_jobs, 0),
    'total_jobs', COALESCE(v_total_jobs, 0)
  );

  -- Build final result with verification status and tier
  SELECT jsonb_build_object(
    'id', p.id,
    'role', p.role,
    'display_name', COALESCE(p.full_name, 'Unknown User'),
    'avatar_url', p.avatar_url,
    'created_at', p.created_at,
    'verification_status', COALESCE(p.verification_status::text, 'unverified'),
    'mechanic_tier', COALESCE(p.mechanic_tier::text, 'bronze'),
    'ratings', COALESCE(profile_ratings, '{}'::jsonb),
    'badges', COALESCE(profile_badges, '[]'::jsonb),
    'skills', COALESCE(profile_skills, '[]'::jsonb),
    'trust_score', profile_trust_score
  )
  INTO result
  FROM profiles p
  WHERE p.id = p_user_id
    AND p.deleted_at IS NULL;

  RETURN result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO anon;

-- =====================================================
-- DATA MIGRATION EXAMPLES
-- Run these manually to update existing mechanics
-- =====================================================

-- Example: Set a specific mechanic as verified
-- UPDATE profiles SET verification_status = 'verified', verified_at = now() WHERE id = 'mechanic-uuid-here';

-- Example: Verify all mechanics with high trust scores (completed_jobs >= 10 and good ratings)
-- UPDATE profiles p
-- SET verification_status = 'verified', verified_at = now()
-- FROM mechanic_profiles mp
-- WHERE p.id = mp.id
--   AND p.role = 'mechanic'
--   AND mp.jobs_completed >= 10
--   AND mp.rating_avg >= 4.5;

-- Example: Set tier based on completed jobs
-- UPDATE profiles p
-- SET mechanic_tier = CASE
--   WHEN mp.jobs_completed >= 100 THEN 'platinum'
--   WHEN mp.jobs_completed >= 50 THEN 'gold'
--   WHEN mp.jobs_completed >= 20 THEN 'silver'
--   ELSE 'bronze'
-- END
-- FROM mechanic_profiles mp
-- WHERE p.id = mp.id AND p.role = 'mechanic';\n-- ===================================================================
-- END: 20260127000006_add_mechanic_verification_tier.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000007_fix_admin_mechanics_no_hubs.sql
-- ===================================================================\n
-- Fix admin_get_mechanics and admin_get_mechanic_detail RPCs
-- Remove hub_mechanics and hubs references (tables don't exist yet)

-- =====================================================
-- FIX admin_get_mechanics
-- =====================================================

-- Drop all overloads to avoid signature conflicts
DROP FUNCTION IF EXISTS admin_get_mechanics(text, uuid, int, int);
DROP FUNCTION IF EXISTS admin_get_mechanics(text, uuid, text, text, timestamptz, timestamptz, int, int);

CREATE OR REPLACE FUNCTION admin_get_mechanics(
  p_status text DEFAULT NULL,
  p_hub_id uuid DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  full_name text,
  email text,
  phone text,
  verification_status text,
  tier text,
  hub_id uuid,
  hub_name text,
  rating_avg numeric,
  rating_count int,
  jobs_completed int,
  is_available boolean,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Access denied: admin only';
  END IF;

  RETURN QUERY
  SELECT
    p.id,
    p.full_name,
    p.email,
    p.phone,
    mp.verification_status,
    mp.tier,
    NULL::uuid AS hub_id,
    NULL::text AS hub_name,
    mp.rating_avg,
    mp.rating_count,
    mp.jobs_completed,
    mp.is_available,
    p.created_at
  FROM profiles p
  JOIN mechanic_profiles mp ON mp.id = p.id
  WHERE p.role = 'mechanic'
    AND p.deleted_at IS NULL
    AND mp.deleted_at IS NULL
    AND (p_status IS NULL OR mp.verification_status = p_status)
  ORDER BY p.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

-- =====================================================
-- FIX admin_get_mechanic_detail
-- =====================================================

CREATE OR REPLACE FUNCTION admin_get_mechanic_detail(p_mechanic_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result jsonb;
  v_mechanic jsonb;
  v_documents jsonb;
  v_vetting jsonb;
  v_jobs jsonb;
  v_reviews jsonb;
  v_disputes jsonb;
  v_support jsonb;
BEGIN
  IF NOT is_admin() THEN
    RETURN jsonb_build_object('error', 'Access denied: admin only');
  END IF;

  -- Get mechanic profile (without hub references)
  SELECT jsonb_build_object(
    'id', p.id,
    'full_name', p.full_name,
    'email', p.email,
    'phone', p.phone,
    'role', p.role::text,
    'city', p.city,
    'state', p.state,
    'hub_id', NULL,
    'hub_name', NULL,
    'verification_status', mp.verification_status,
    'verification_reason', mp.verification_reason,
    'tier', mp.tier,
    'bio', mp.bio,
    'years_experience', mp.years_experience,
    'hourly_rate_cents', mp.hourly_rate_cents,
    'service_radius_km', mp.service_radius_km,
    'mobile_service', mp.mobile_service,
    'is_available', mp.is_available,
    'rating_avg', mp.rating_avg,
    'rating_count', mp.rating_count,
    'jobs_completed', mp.jobs_completed,
    'stripe_account_id', mp.stripe_account_id,
    'stripe_onboarding_complete', mp.stripe_onboarding_complete,
    'created_at', p.created_at,
    'updated_at', p.updated_at
  ) INTO v_mechanic
  FROM profiles p
  JOIN mechanic_profiles mp ON mp.id = p.id
  WHERE p.id = p_mechanic_id;

  IF v_mechanic IS NULL THEN
    RETURN jsonb_build_object('error', 'Mechanic not found');
  END IF;

  -- Get documents (if table exists, otherwise empty)
  BEGIN
    SELECT COALESCE(jsonb_agg(
      jsonb_build_object(
        'id', d.id,
        'doc_type', d.doc_type,
        'status', d.status,
        'uploaded_at', d.created_at,
        'reviewed_at', d.reviewed_at,
        'review_notes', d.review_notes
      ) ORDER BY d.created_at DESC
    ), '[]'::jsonb) INTO v_documents
    FROM mechanic_documents d
    WHERE d.mechanic_id = p_mechanic_id;
  EXCEPTION WHEN undefined_table THEN
    v_documents := '[]'::jsonb;
  END;

  -- Get vetting responses (if table exists, otherwise empty)
  BEGIN
    SELECT COALESCE(jsonb_agg(
      jsonb_build_object(
        'id', v.id,
        'prompt_key', v.prompt_key,
        'prompt_text', vp.prompt_text,
        'response_text', v.response_text,
        'created_at', v.created_at
      ) ORDER BY v.created_at
    ), '[]'::jsonb) INTO v_vetting
    FROM mechanic_vetting_responses v
    LEFT JOIN mechanic_vetting_prompts vp ON vp.prompt_key = v.prompt_key
    WHERE v.mechanic_id = p_mechanic_id;
  EXCEPTION WHEN undefined_table THEN
    v_vetting := '[]'::jsonb;
  END;

  -- Get recent jobs
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', j.id,
      'title', j.title,
      'status', j.status::text,
      'customer_name', cp.full_name,
      'created_at', j.created_at,
      'completed_at', j.completed_at
    ) ORDER BY j.created_at DESC
  ), '[]'::jsonb) INTO v_jobs
  FROM jobs j
  LEFT JOIN profiles cp ON cp.id = j.customer_id
  WHERE j.accepted_mechanic_id = p_mechanic_id
  LIMIT 20;

  -- Get recent reviews
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', r.id,
      'reviewer_name', rp.full_name,
      'overall_rating', r.overall_rating,
      'comment', r.comment,
      'created_at', r.created_at
    ) ORDER BY r.created_at DESC
  ), '[]'::jsonb) INTO v_reviews
  FROM reviews r
  LEFT JOIN profiles rp ON rp.id = r.reviewer_id
  WHERE r.reviewee_id = p_mechanic_id
  LIMIT 10;

  -- Get disputes
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', d.id,
      'job_id', d.job_id,
      'status', d.status,
      'category', d.category,
      'description', d.description,
      'created_at', d.created_at
    ) ORDER BY d.created_at DESC
  ), '[]'::jsonb) INTO v_disputes
  FROM disputes d
  JOIN jobs j ON j.id = d.job_id
  WHERE j.accepted_mechanic_id = p_mechanic_id
  LIMIT 10;

  -- Get support requests
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', s.id,
      'category', s.category,
      'status', s.status,
      'created_at', s.created_at
    ) ORDER BY s.created_at DESC
  ), '[]'::jsonb) INTO v_support
  FROM support_requests s
  WHERE s.user_id = p_mechanic_id
  LIMIT 10;

  -- Build final result
  v_result := jsonb_build_object(
    'mechanic', v_mechanic,
    'documents', v_documents,
    'vetting', v_vetting,
    'recent_jobs', v_jobs,
    'reviews', v_reviews,
    'disputes', v_disputes,
    'support_requests', v_support
  );

  RETURN v_result;
END;
$$;

GRANT EXECUTE ON FUNCTION admin_get_mechanics(text, uuid, int, int) TO authenticated;
GRANT EXECUTE ON FUNCTION admin_get_mechanic_detail(uuid) TO authenticated;\n-- ===================================================================
-- END: 20260127000007_fix_admin_mechanics_no_hubs.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000008_fix_admin_list_customers_payment_status.sql
-- ===================================================================\n
-- Fix admin_list_customers - 'paid' is not a valid payment_status enum value
-- Valid values: pending, processing, succeeded, failed, refunded, partially_refunded

DROP FUNCTION IF EXISTS public.admin_list_customers(int, int, text);

CREATE OR REPLACE FUNCTION public.admin_list_customers(
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0,
  p_query text DEFAULT NULL
)
RETURNS TABLE (
  customer_id uuid,
  full_name text,
  email text,
  phone text,
  city text,
  state text,
  hub_id uuid,
  created_at timestamptz,
  total_jobs bigint,
  completed_jobs bigint,
  total_spent_cents bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT 
    p.id as customer_id,
    p.full_name::text,
    p.email::text,
    p.phone::text,
    p.city::text,
    p.state::text,
    p.hub_id,
    p.created_at,
    (SELECT COUNT(*) FROM public.jobs j WHERE j.customer_id = p.id) as total_jobs,
    (SELECT COUNT(*) FROM public.jobs j WHERE j.customer_id = p.id AND j.status = 'completed') as completed_jobs,
    COALESCE((SELECT SUM(pay.amount_cents) FROM public.payments pay 
              JOIN public.jobs j ON j.id = pay.job_id 
              WHERE j.customer_id = p.id AND pay.status = 'succeeded'), 0)::bigint as total_spent_cents
  FROM public.profiles p
  WHERE p.role = 'customer'
    AND p.deleted_at IS NULL
    AND (p_query IS NULL OR 
         p.full_name ILIKE '%' || p_query || '%' OR 
         p.email ILIKE '%' || p_query || '%' OR
         p.phone ILIKE '%' || p_query || '%')
  ORDER BY p.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_list_customers(int, int, text) TO authenticated;\n-- ===================================================================
-- END: 20260127000008_fix_admin_list_customers_payment_status.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000009_fix_profile_card_verification_source.sql
-- ===================================================================\n
-- Fix get_public_profile_card to read verification_status from mechanic_profiles table
-- The admin interface updates mechanic_profiles.verification_status, not profiles.verification_status

CREATE OR REPLACE FUNCTION public.get_public_profile_card(p_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  result jsonb;
  profile_ratings jsonb;
  profile_badges jsonb;
  profile_skills jsonb;
  profile_trust_score jsonb;
  v_role text;
  v_profile_id uuid;
  v_total_jobs bigint := 0;
  v_completed_jobs bigint := 0;
  v_verification_status text := 'unverified';
  v_mechanic_tier text := 'bronze';
BEGIN
  -- Get user role and profile id
  SELECT p.role, p.id INTO v_role, v_profile_id
  FROM profiles p
  WHERE p.id = p_user_id
    AND p.deleted_at IS NULL;

  IF v_profile_id IS NULL THEN
    RETURN NULL;
  END IF;

  -- Get verification status from mechanic_profiles for mechanics
  IF v_role = 'mechanic' THEN
    SELECT
      CASE mp.verification_status
        WHEN 'active' THEN 'verified'
        WHEN 'pending_verification' THEN 'pending'
        WHEN 'paused' THEN 'suspended'
        WHEN 'removed' THEN 'suspended'
        ELSE 'unverified'
      END,
      COALESCE(mp.tier, 'bronze')
    INTO v_verification_status, v_mechanic_tier
    FROM mechanic_profiles mp
    WHERE mp.id = p_user_id;
    
    -- Fallback if no mechanic_profile record
    IF v_verification_status IS NULL THEN
      v_verification_status := 'unverified';
    END IF;
    IF v_mechanic_tier IS NULL THEN
      v_mechanic_tier := 'bronze';
    END IF;
  END IF;

  -- Count jobs based on role
  IF v_role = 'customer' THEN
    SELECT 
      COALESCE(COUNT(*), 0),
      COALESCE(COUNT(*) FILTER (WHERE j.status = 'completed'), 0)
    INTO v_total_jobs, v_completed_jobs
    FROM jobs j
    WHERE j.customer_id = v_profile_id;
  ELSE
    SELECT 
      COALESCE(COUNT(*), 0),
      COALESCE(COUNT(*) FILTER (WHERE j.status = 'completed'), 0)
    INTO v_total_jobs, v_completed_jobs
    FROM jobs j
    WHERE j.accepted_mechanic_id = v_profile_id;
  END IF;

  -- Get ratings data
  SELECT jsonb_build_object(
    'overall_avg', COALESCE(AVG(r.overall_rating), 0),
    'performance_avg', COALESCE(AVG(r.performance_rating), 0),
    'timing_avg', COALESCE(AVG(r.timing_rating), 0),
    'cost_avg', COALESCE(AVG(r.cost_rating), 0),
    'professionalism_avg', COALESCE(AVG(r.professionalism_rating), 0),
    'communication_avg', COALESCE(AVG(r.communication_rating), 0),
    'punctuality_avg', COALESCE(AVG(r.punctuality_rating), 0),
    'payment_avg', COALESCE(AVG(r.payment_rating), 0),
    'review_count', COALESCE(COUNT(r.id), 0)::integer,
    'would_recommend_count', COALESCE(COUNT(r.id) FILTER (WHERE r.would_recommend = true), 0)::integer,
    'would_recommend_total', COALESCE(COUNT(r.id) FILTER (WHERE r.would_recommend IS NOT NULL), 0)::integer
  )
  INTO profile_ratings
  FROM reviews r
  WHERE r.reviewee_id = p_user_id;

  -- Get badges data
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ub.id,
      'badge_id', ub.badge_id,
      'awarded_at', ub.created_at,
      'badge', jsonb_build_object(
        'code', b.code,
        'title', b.title,
        'description', COALESCE(b.description, ''),
        'icon', COALESCE(b.icon, ''),
        'category', COALESCE(b.badge_type, 'earned'),
        'tier', 1
      )
    )
  ), '[]'::jsonb)
  INTO profile_badges
  FROM user_badges ub
  INNER JOIN badges b ON b.id = ub.badge_id
  WHERE ub.user_id = p_user_id;

  -- Get skills data (for mechanics only)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ms.id,
      'is_verified', COALESCE(ms.is_verified, false),
      'verified_job_count', 0,
      'avg_job_rating', null,
      'skill', jsonb_build_object(
        'key', s.key,
        'label', s.label,
        'name', s.label,
        'category', COALESCE(s.category, 'general')
      )
    )
  ), '[]'::jsonb)
  INTO profile_skills
  FROM mechanic_skills ms
  INNER JOIN skills s ON s.key = ms.skill_key
  WHERE ms.mechanic_id = p_user_id;

  -- Build trust score with actual job counts
  profile_trust_score := jsonb_build_object(
    'overall_score', 50,
    'rating_score', CASE WHEN COALESCE((profile_ratings->>'review_count')::int, 0) > 0 
      THEN LEAST(100, COALESCE((profile_ratings->>'overall_avg')::numeric, 0) * 20) 
      ELSE 50 END,
    'completion_score', CASE WHEN v_total_jobs > 0 
      THEN LEAST(100, (v_completed_jobs::numeric / v_total_jobs::numeric) * 100)
      ELSE 50 END,
    'reliability_score', 50,
    'badge_score', LEAST(100, COALESCE(jsonb_array_length(profile_badges), 0) * 20),
    'tenure_score', 50,
    'completed_jobs', COALESCE(v_completed_jobs, 0),
    'total_jobs', COALESCE(v_total_jobs, 0)
  );

  -- Build final result with verification status from mechanic_profiles
  SELECT jsonb_build_object(
    'id', p.id,
    'role', p.role,
    'display_name', COALESCE(p.full_name, 'Unknown User'),
    'avatar_url', p.avatar_url,
    'created_at', p.created_at,
    'verification_status', v_verification_status,
    'mechanic_tier', v_mechanic_tier,
    'ratings', COALESCE(profile_ratings, '{}'::jsonb),
    'badges', COALESCE(profile_badges, '[]'::jsonb),
    'skills', COALESCE(profile_skills, '[]'::jsonb),
    'trust_score', profile_trust_score
  )
  INTO result
  FROM profiles p
  WHERE p.id = p_user_id
    AND p.deleted_at IS NULL;

  RETURN result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_public_profile_card(uuid) TO anon;\n-- ===================================================================
-- END: 20260127000009_fix_profile_card_verification_source.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000010_trust_score_system_complete.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: COMPLETE TRUST SCORE SYSTEM
-- =====================================================
-- Implements:
-- 1) Canonical RPC: recalculate_trust_score
-- 2) DB Triggers for automatic recalculation
-- 3) Admin RPC for manual recalculation
-- 4) Required indexes for performance
-- =====================================================

BEGIN;

-- =====================================================
-- HELPER: is_admin already exists, skip recreation
-- =====================================================

-- =====================================================
-- ENSURE trust_score_history has snapshot_reason column
-- =====================================================
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'trust_score_history'
      AND column_name = 'snapshot_reason'
  ) THEN
    ALTER TABLE public.trust_score_history
    ADD COLUMN snapshot_reason text;
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'trust_score_history'
      AND column_name = 'job_id'
  ) THEN
    ALTER TABLE public.trust_score_history
    ADD COLUMN job_id uuid REFERENCES public.jobs(id);
  END IF;
END $$;

-- =====================================================
-- CANONICAL RPC: recalculate_trust_score
-- =====================================================
-- This is the single source of truth for trust score calculation
-- Called by triggers and can be called by app/admin
CREATE OR REPLACE FUNCTION public.recalculate_trust_score(
  p_user_id uuid,
  p_reason text DEFAULT 'manual_recalc',
  p_job_id uuid DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_jobs int := 0;
  v_completed_jobs int := 0;
  v_cancelled_jobs int := 0;
  v_disputed_jobs int := 0;
  v_no_show_count int := 0;
  v_reviews_received int := 0;
  v_reviews_given int := 0;
  v_avg_rating_received numeric := 0;
  v_avg_rating_given numeric := 0;
  v_badge_count int := 0;
  v_tenure_days int := 0;
  v_user_role text;
  v_rating_score int := 50;
  v_completion_score int := 100;
  v_reliability_score int := 100;
  v_badge_score int := 0;
  v_tenure_score int := 0;
  v_overall_score int := 50;
  v_created_at timestamptz;
BEGIN
  -- Permission check: user can recalc own score, or admin can recalc any
  IF auth.uid() IS NOT NULL AND auth.uid() != p_user_id AND NOT public.is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Permission denied: cannot recalculate trust score for another user';
  END IF;

  -- Get user role and created_at
  SELECT role, created_at INTO v_user_role, v_created_at
  FROM public.profiles
  WHERE id = p_user_id;

  IF v_user_role IS NULL THEN
    RETURN jsonb_build_object('error', 'User not found');
  END IF;

  -- Calculate tenure days
  v_tenure_days := GREATEST(0, EXTRACT(DAY FROM (now() - v_created_at))::int);

  -- =====================================================
  -- COUNT JOBS (role-dependent)
  -- =====================================================
  IF v_user_role = 'mechanic' THEN
    -- For mechanics: count jobs where they are the accepted mechanic
    SELECT 
      COUNT(*),
      COUNT(*) FILTER (WHERE j.status = 'completed' OR j.completed_at IS NOT NULL),
      COUNT(*) FILTER (WHERE j.status IN ('cancelled', 'canceled') OR j.cancelled_at IS NOT NULL OR j.canceled_at IS NOT NULL)
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs
    FROM public.jobs j
    WHERE j.accepted_mechanic_id = p_user_id;
    
    -- Also count from job_contracts
    SELECT 
      COALESCE(v_total_jobs, 0) + COUNT(*),
      COALESCE(v_completed_jobs, 0) + COUNT(*) FILTER (WHERE jc.status = 'completed'),
      COALESCE(v_cancelled_jobs, 0) + COUNT(*) FILTER (WHERE jc.status IN ('cancelled', 'canceled'))
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs
    FROM public.job_contracts jc
    WHERE jc.mechanic_id = p_user_id
      AND NOT EXISTS (
        SELECT 1 FROM public.jobs j2 
        WHERE j2.id = jc.job_id AND j2.accepted_mechanic_id = p_user_id
      );
  ELSE
    -- For customers: count jobs they created
    SELECT 
      COUNT(*),
      COUNT(*) FILTER (WHERE j.status = 'completed' OR j.completed_at IS NOT NULL),
      COUNT(*) FILTER (WHERE j.status IN ('cancelled', 'canceled') OR j.cancelled_at IS NOT NULL OR j.canceled_at IS NOT NULL)
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs
    FROM public.jobs j
    WHERE j.customer_id = p_user_id;
  END IF;

  -- =====================================================
  -- COUNT DISPUTES
  -- =====================================================
  SELECT COUNT(*)
  INTO v_disputed_jobs
  FROM public.disputes d
  WHERE d.filed_against = p_user_id
    AND d.status IN ('open', 'resolved', 'closed');

  -- =====================================================
  -- COUNT NO-SHOWS (from existing trust_scores if available)
  -- =====================================================
  SELECT COALESCE(no_show_count, 0)
  INTO v_no_show_count
  FROM public.trust_scores
  WHERE user_id = p_user_id;

  -- =====================================================
  -- COUNT REVIEWS
  -- =====================================================
  SELECT 
    COUNT(*),
    COALESCE(AVG(overall_rating), 0)
  INTO v_reviews_received, v_avg_rating_received
  FROM public.reviews
  WHERE reviewee_id = p_user_id
    AND (visibility = 'visible' OR visibility IS NULL);

  SELECT 
    COUNT(*),
    COALESCE(AVG(overall_rating), 0)
  INTO v_reviews_given, v_avg_rating_given
  FROM public.reviews
  WHERE reviewer_id = p_user_id;

  -- =====================================================
  -- COUNT ACTIVE BADGES
  -- =====================================================
  SELECT COUNT(*)
  INTO v_badge_count
  FROM public.user_badges
  WHERE user_id = p_user_id
    AND revoked_at IS NULL
    AND (expires_at IS NULL OR expires_at > now());

  -- =====================================================
  -- CALCULATE COMPONENT SCORES
  -- =====================================================
  
  -- Rating score: (avg_rating - 1) / 4 * 100, default 50 if no reviews
  IF v_reviews_received > 0 AND v_avg_rating_received > 0 THEN
    v_rating_score := LEAST(100, GREATEST(0, ROUND(((v_avg_rating_received - 1) / 4.0) * 100)::int));
  ELSE
    v_rating_score := 50;
  END IF;

  -- Completion score: completed_jobs / total_jobs * 100
  IF v_total_jobs > 0 THEN
    v_completion_score := LEAST(100, GREATEST(0, ROUND((v_completed_jobs::numeric / v_total_jobs) * 100)::int));
  ELSE
    v_completion_score := 100;
  END IF;

  -- Reliability score: start at 100, subtract penalties
  v_reliability_score := 100;
  v_reliability_score := v_reliability_score - (10 * COALESCE(v_cancelled_jobs, 0));
  v_reliability_score := v_reliability_score - (25 * COALESCE(v_no_show_count, 0));
  v_reliability_score := v_reliability_score - (15 * COALESCE(v_disputed_jobs, 0));
  v_reliability_score := LEAST(100, GREATEST(0, v_reliability_score));

  -- Badge score: badge_count * 10, capped at 100
  v_badge_score := LEAST(100, GREATEST(0, v_badge_count * 10));

  -- Tenure score: floor(days / 30) * 5, capped at 100
  v_tenure_score := LEAST(100, GREATEST(0, FLOOR(v_tenure_days / 30.0) * 5)::int);

  -- =====================================================
  -- CALCULATE OVERALL SCORE (weighted)
  -- =====================================================
  v_overall_score := ROUND(
    0.35 * v_rating_score +
    0.25 * v_completion_score +
    0.25 * v_reliability_score +
    0.10 * v_badge_score +
    0.05 * v_tenure_score
  )::int;
  v_overall_score := LEAST(100, GREATEST(0, v_overall_score));

  -- =====================================================
  -- UPSERT trust_scores
  -- =====================================================
  INSERT INTO public.trust_scores (
    user_id,
    overall_score,
    rating_score,
    completion_score,
    reliability_score,
    badge_score,
    tenure_score,
    total_jobs,
    completed_jobs,
    cancelled_jobs,
    disputed_jobs,
    no_show_count,
    reviews_given,
    reviews_received,
    avg_rating_given,
    avg_rating_received,
    last_calculated_at,
    created_at,
    updated_at
  ) VALUES (
    p_user_id,
    v_overall_score,
    v_rating_score,
    v_completion_score,
    v_reliability_score,
    v_badge_score,
    v_tenure_score,
    v_total_jobs,
    v_completed_jobs,
    v_cancelled_jobs,
    v_disputed_jobs,
    v_no_show_count,
    v_reviews_given,
    v_reviews_received,
    v_avg_rating_given,
    v_avg_rating_received,
    now(),
    now(),
    now()
  )
  ON CONFLICT (user_id) DO UPDATE SET
    overall_score = EXCLUDED.overall_score,
    rating_score = EXCLUDED.rating_score,
    completion_score = EXCLUDED.completion_score,
    reliability_score = EXCLUDED.reliability_score,
    badge_score = EXCLUDED.badge_score,
    tenure_score = EXCLUDED.tenure_score,
    total_jobs = EXCLUDED.total_jobs,
    completed_jobs = EXCLUDED.completed_jobs,
    cancelled_jobs = EXCLUDED.cancelled_jobs,
    disputed_jobs = EXCLUDED.disputed_jobs,
    no_show_count = EXCLUDED.no_show_count,
    reviews_given = EXCLUDED.reviews_given,
    reviews_received = EXCLUDED.reviews_received,
    avg_rating_given = EXCLUDED.avg_rating_given,
    avg_rating_received = EXCLUDED.avg_rating_received,
    last_calculated_at = now(),
    updated_at = now();

  -- =====================================================
  -- INSERT HISTORY SNAPSHOT
  -- =====================================================
  INSERT INTO public.trust_score_history (
    user_id,
    overall_score,
    rating_score,
    completion_score,
    reliability_score,
    badge_score,
    tenure_score,
    snapshot_reason,
    job_id,
    created_at
  ) VALUES (
    p_user_id,
    v_overall_score,
    v_rating_score,
    v_completion_score,
    v_reliability_score,
    v_badge_score,
    v_tenure_score,
    p_reason,
    p_job_id,
    now()
  );

  RETURN jsonb_build_object(
    'user_id', p_user_id,
    'overall_score', v_overall_score,
    'rating_score', v_rating_score,
    'completion_score', v_completion_score,
    'reliability_score', v_reliability_score,
    'badge_score', v_badge_score,
    'tenure_score', v_tenure_score,
    'total_jobs', v_total_jobs,
    'completed_jobs', v_completed_jobs,
    'cancelled_jobs', v_cancelled_jobs,
    'disputed_jobs', v_disputed_jobs,
    'reviews_received', v_reviews_received,
    'avg_rating_received', v_avg_rating_received,
    'badge_count', v_badge_count,
    'tenure_days', v_tenure_days,
    'reason', p_reason
  );
END;
$$;

-- =====================================================
-- ADMIN RPC: admin_recalculate_trust_score
-- =====================================================
CREATE OR REPLACE FUNCTION public.admin_recalculate_trust_score(
  p_user_id uuid,
  p_reason text DEFAULT 'admin_manual'
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result jsonb;
BEGIN
  -- Check admin permission
  IF NOT public.is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Permission denied: admin access required';
  END IF;

  -- Call the canonical recalculate function
  v_result := public.recalculate_trust_score(p_user_id, p_reason, NULL);

  -- Log to audit_log if table exists
  BEGIN
    INSERT INTO public.audit_log (
      user_id,
      action,
      entity_type,
      entity_id,
      details,
      created_at
    ) VALUES (
      auth.uid(),
      'ADMIN_RECALC_TRUST',
      'trust_scores',
      p_user_id,
      v_result,
      now()
    );
  EXCEPTION WHEN undefined_table THEN
    -- audit_log table doesn't exist, skip
    NULL;
  END;

  RETURN v_result;
END;
$$;

-- =====================================================
-- TRIGGER FUNCTION: On job status change
-- =====================================================
CREATE OR REPLACE FUNCTION public.trigger_recalc_trust_on_job_change()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_customer_id uuid;
  v_mechanic_id uuid;
BEGIN
  -- Get customer and mechanic IDs
  v_customer_id := COALESCE(NEW.customer_id, OLD.customer_id);
  v_mechanic_id := COALESCE(NEW.accepted_mechanic_id, OLD.accepted_mechanic_id);

  -- Job completed
  IF (NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed'))
     OR (NEW.completed_at IS NOT NULL AND OLD.completed_at IS NULL) THEN
    IF v_customer_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(v_customer_id, 'job_completed', NEW.id);
    END IF;
    IF v_mechanic_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(v_mechanic_id, 'job_completed', NEW.id);
    END IF;
  END IF;

  -- Job cancelled
  IF (NEW.status IN ('cancelled', 'canceled') AND OLD.status NOT IN ('cancelled', 'canceled'))
     OR (NEW.cancelled_at IS NOT NULL AND OLD.cancelled_at IS NULL)
     OR (NEW.canceled_at IS NOT NULL AND OLD.canceled_at IS NULL) THEN
    IF v_customer_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(v_customer_id, 'job_cancelled', NEW.id);
    END IF;
    IF v_mechanic_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(v_mechanic_id, 'job_cancelled', NEW.id);
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

-- =====================================================
-- TRIGGER FUNCTION: On job_contracts status change
-- =====================================================
CREATE OR REPLACE FUNCTION public.trigger_recalc_trust_on_contract_change()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_customer_id uuid;
BEGIN
  -- Get customer ID from job
  SELECT customer_id INTO v_customer_id
  FROM public.jobs
  WHERE id = NEW.job_id;

  -- Contract completed
  IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
    IF v_customer_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(v_customer_id, 'job_completed', NEW.job_id);
    END IF;
    IF NEW.mechanic_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(NEW.mechanic_id, 'job_completed', NEW.job_id);
    END IF;
  END IF;

  -- Contract cancelled
  IF NEW.status IN ('cancelled', 'canceled') AND OLD.status NOT IN ('cancelled', 'canceled') THEN
    IF v_customer_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(v_customer_id, 'job_cancelled', NEW.job_id);
    END IF;
    IF NEW.mechanic_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(NEW.mechanic_id, 'job_cancelled', NEW.job_id);
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

-- =====================================================
-- TRIGGER FUNCTION: On review insert
-- =====================================================
CREATE OR REPLACE FUNCTION public.trigger_recalc_trust_on_review()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Recalculate for reviewee when review is added
  IF TG_OP = 'INSERT' THEN
    PERFORM public.recalculate_trust_score(NEW.reviewee_id, 'review_added', NEW.job_id);
  END IF;

  -- Also recalculate when review becomes visible
  IF TG_OP = 'UPDATE' AND NEW.visibility = 'visible' AND (OLD.visibility IS NULL OR OLD.visibility != 'visible') THEN
    PERFORM public.recalculate_trust_score(NEW.reviewee_id, 'review_visible', NEW.job_id);
  END IF;

  RETURN NEW;
END;
$$;

-- =====================================================
-- TRIGGER FUNCTION: On dispute change
-- =====================================================
CREATE OR REPLACE FUNCTION public.trigger_recalc_trust_on_dispute()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- On dispute opened
  IF TG_OP = 'INSERT' THEN
    IF NEW.filed_against IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(NEW.filed_against, 'dispute_opened', NEW.job_id);
    END IF;
  END IF;

  -- On dispute resolved
  IF TG_OP = 'UPDATE' THEN
    IF (NEW.status IN ('resolved', 'closed') AND OLD.status NOT IN ('resolved', 'closed'))
       OR (NEW.resolved_at IS NOT NULL AND OLD.resolved_at IS NULL) THEN
      IF NEW.filed_against IS NOT NULL THEN
        PERFORM public.recalculate_trust_score(NEW.filed_against, 'dispute_resolved', NEW.job_id);
      END IF;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

-- =====================================================
-- TRIGGER FUNCTION: On badge change
-- =====================================================
CREATE OR REPLACE FUNCTION public.trigger_recalc_trust_on_badge()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- On badge awarded
  IF TG_OP = 'INSERT' THEN
    PERFORM public.recalculate_trust_score(NEW.user_id, 'badge_awarded', NULL);
  END IF;

  -- On badge revoked
  IF TG_OP = 'UPDATE' AND NEW.revoked_at IS NOT NULL AND OLD.revoked_at IS NULL THEN
    PERFORM public.recalculate_trust_score(NEW.user_id, 'badge_revoked', NULL);
  END IF;

  RETURN NEW;
END;
$$;

-- =====================================================
-- DROP EXISTING TRIGGERS (to avoid duplicates)
-- =====================================================
DROP TRIGGER IF EXISTS trigger_recalc_trust_on_job_change ON public.jobs;
DROP TRIGGER IF EXISTS trigger_recalc_trust_on_contract_change ON public.job_contracts;
DROP TRIGGER IF EXISTS trigger_recalc_trust_on_review_insert ON public.reviews;
DROP TRIGGER IF EXISTS trigger_recalc_trust_on_review_update ON public.reviews;
DROP TRIGGER IF EXISTS trigger_recalc_trust_on_dispute_insert ON public.disputes;
DROP TRIGGER IF EXISTS trigger_recalc_trust_on_dispute_update ON public.disputes;
DROP TRIGGER IF EXISTS trigger_recalc_trust_on_badge_insert ON public.user_badges;
DROP TRIGGER IF EXISTS trigger_recalc_trust_on_badge_update ON public.user_badges;

-- =====================================================
-- CREATE TRIGGERS
-- =====================================================

-- Jobs trigger
CREATE TRIGGER trigger_recalc_trust_on_job_change
  AFTER UPDATE ON public.jobs
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_recalc_trust_on_job_change();

-- Job contracts trigger
CREATE TRIGGER trigger_recalc_trust_on_contract_change
  AFTER UPDATE ON public.job_contracts
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_recalc_trust_on_contract_change();

-- Reviews triggers
CREATE TRIGGER trigger_recalc_trust_on_review_insert
  AFTER INSERT ON public.reviews
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_recalc_trust_on_review();

CREATE TRIGGER trigger_recalc_trust_on_review_update
  AFTER UPDATE ON public.reviews
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_recalc_trust_on_review();

-- Disputes triggers
CREATE TRIGGER trigger_recalc_trust_on_dispute_insert
  AFTER INSERT ON public.disputes
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_recalc_trust_on_dispute();

CREATE TRIGGER trigger_recalc_trust_on_dispute_update
  AFTER UPDATE ON public.disputes
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_recalc_trust_on_dispute();

-- User badges triggers
CREATE TRIGGER trigger_recalc_trust_on_badge_insert
  AFTER INSERT ON public.user_badges
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_recalc_trust_on_badge();

CREATE TRIGGER trigger_recalc_trust_on_badge_update
  AFTER UPDATE ON public.user_badges
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_recalc_trust_on_badge();

-- =====================================================
-- INDEXES FOR PERFORMANCE
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_reviews_reviewee_id ON public.reviews(reviewee_id);
CREATE INDEX IF NOT EXISTS idx_reviews_reviewer_id ON public.reviews(reviewer_id);
CREATE INDEX IF NOT EXISTS idx_disputes_filed_against ON public.disputes(filed_against);
CREATE INDEX IF NOT EXISTS idx_disputes_filed_by ON public.disputes(filed_by);
CREATE INDEX IF NOT EXISTS idx_user_badges_user_id ON public.user_badges(user_id);
CREATE INDEX IF NOT EXISTS idx_user_badges_active ON public.user_badges(user_id) WHERE revoked_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_jobs_customer_id ON public.jobs(customer_id);
CREATE INDEX IF NOT EXISTS idx_jobs_accepted_mechanic_id ON public.jobs(accepted_mechanic_id);
CREATE INDEX IF NOT EXISTS idx_job_contracts_mechanic_id ON public.job_contracts(mechanic_id);
CREATE INDEX IF NOT EXISTS idx_trust_scores_user_id ON public.trust_scores(user_id);
CREATE INDEX IF NOT EXISTS idx_trust_score_history_user_id ON public.trust_score_history(user_id);

-- =====================================================
-- GRANT PERMISSIONS
-- =====================================================
GRANT EXECUTE ON FUNCTION public.recalculate_trust_score(uuid, text, uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_recalculate_trust_score(uuid, text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.is_admin(uuid) TO authenticated;

-- =====================================================
-- RLS POLICY FOR trust_scores (allow public read)
-- =====================================================
DROP POLICY IF EXISTS "trust_scores_public_read" ON public.trust_scores;
CREATE POLICY "trust_scores_public_read" ON public.trust_scores
  FOR SELECT
  USING (true);

COMMIT;
\n-- ===================================================================
-- END: 20260127000010_trust_score_system_complete.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000011_fix_trust_trigger_enum.sql
-- ===================================================================\n
-- Fix trust score triggers to handle job_status enum properly
-- The enum only has 'cancelled' (British spelling), not 'canceled'

BEGIN;

-- =====================================================
-- TRIGGER FUNCTION: On job status change (FIXED)
-- =====================================================
CREATE OR REPLACE FUNCTION public.trigger_recalc_trust_on_job_change()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_customer_id uuid;
  v_mechanic_id uuid;
  v_new_status text;
  v_old_status text;
BEGIN
  -- Cast to text to avoid enum comparison issues
  v_new_status := NEW.status::text;
  v_old_status := OLD.status::text;

  -- Get customer and mechanic IDs
  v_customer_id := COALESCE(NEW.customer_id, OLD.customer_id);
  v_mechanic_id := COALESCE(NEW.accepted_mechanic_id, OLD.accepted_mechanic_id);

  -- Job completed
  IF (v_new_status = 'completed' AND (v_old_status IS NULL OR v_old_status != 'completed'))
     OR (NEW.completed_at IS NOT NULL AND OLD.completed_at IS NULL) THEN
    IF v_customer_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(v_customer_id, 'job_completed', NEW.id);
    END IF;
    IF v_mechanic_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(v_mechanic_id, 'job_completed', NEW.id);
    END IF;
  END IF;

  -- Job cancelled (check both spellings via text comparison)
  IF (v_new_status IN ('cancelled', 'canceled') AND v_old_status NOT IN ('cancelled', 'canceled'))
     OR (NEW.cancelled_at IS NOT NULL AND OLD.cancelled_at IS NULL) THEN
    IF v_customer_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(v_customer_id, 'job_cancelled', NEW.id);
    END IF;
    IF v_mechanic_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(v_mechanic_id, 'job_cancelled', NEW.id);
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

-- =====================================================
-- TRIGGER FUNCTION: On job_contracts status change (FIXED)
-- =====================================================
CREATE OR REPLACE FUNCTION public.trigger_recalc_trust_on_contract_change()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_customer_id uuid;
  v_new_status text;
  v_old_status text;
BEGIN
  -- Cast to text to avoid enum comparison issues
  v_new_status := NEW.status::text;
  v_old_status := OLD.status::text;

  -- Get customer ID from job
  SELECT customer_id INTO v_customer_id
  FROM public.jobs
  WHERE id = NEW.job_id;

  -- Contract completed
  IF v_new_status = 'completed' AND (v_old_status IS NULL OR v_old_status != 'completed') THEN
    IF v_customer_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(v_customer_id, 'job_completed', NEW.job_id);
    END IF;
    IF NEW.mechanic_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(NEW.mechanic_id, 'job_completed', NEW.job_id);
    END IF;
  END IF;

  -- Contract cancelled (check both spellings via text comparison)
  IF v_new_status IN ('cancelled', 'canceled') AND v_old_status NOT IN ('cancelled', 'canceled') THEN
    IF v_customer_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(v_customer_id, 'job_cancelled', NEW.job_id);
    END IF;
    IF NEW.mechanic_id IS NOT NULL THEN
      PERFORM public.recalculate_trust_score(NEW.mechanic_id, 'job_cancelled', NEW.job_id);
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

-- =====================================================
-- Also fix the main recalculate function to cast status to text
-- =====================================================
CREATE OR REPLACE FUNCTION public.recalculate_trust_score(
  p_user_id uuid,
  p_reason text DEFAULT 'manual_recalc',
  p_job_id uuid DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_jobs int := 0;
  v_completed_jobs int := 0;
  v_cancelled_jobs int := 0;
  v_disputed_jobs int := 0;
  v_no_show_count int := 0;
  v_reviews_received int := 0;
  v_reviews_given int := 0;
  v_avg_rating_received numeric := 0;
  v_avg_rating_given numeric := 0;
  v_badge_count int := 0;
  v_tenure_days int := 0;
  v_user_role text;
  v_rating_score int := 50;
  v_completion_score int := 100;
  v_reliability_score int := 100;
  v_badge_score int := 0;
  v_tenure_score int := 0;
  v_overall_score int := 50;
  v_created_at timestamptz;
BEGIN
  -- Permission check: user can recalc own score, or admin can recalc any
  IF auth.uid() IS NOT NULL AND auth.uid() != p_user_id AND NOT public.is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Permission denied: cannot recalculate trust score for another user';
  END IF;

  -- Get user role and created_at
  SELECT role, created_at INTO v_user_role, v_created_at
  FROM public.profiles
  WHERE id = p_user_id;

  IF v_user_role IS NULL THEN
    RETURN jsonb_build_object('error', 'User not found');
  END IF;

  -- Calculate tenure days
  v_tenure_days := GREATEST(0, EXTRACT(DAY FROM (now() - v_created_at))::int);

  -- =====================================================
  -- COUNT JOBS (role-dependent) - cast status to text
  -- =====================================================
  IF v_user_role = 'mechanic' THEN
    -- For mechanics: count jobs where they are the accepted mechanic
    SELECT 
      COUNT(*),
      COUNT(*) FILTER (WHERE j.status::text = 'completed' OR j.completed_at IS NOT NULL),
      COUNT(*) FILTER (WHERE j.status::text IN ('cancelled', 'canceled') OR j.cancelled_at IS NOT NULL)
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs
    FROM public.jobs j
    WHERE j.accepted_mechanic_id = p_user_id;
    
    -- Also count from job_contracts
    SELECT 
      COALESCE(v_total_jobs, 0) + COUNT(*),
      COALESCE(v_completed_jobs, 0) + COUNT(*) FILTER (WHERE jc.status::text = 'completed'),
      COALESCE(v_cancelled_jobs, 0) + COUNT(*) FILTER (WHERE jc.status::text IN ('cancelled', 'canceled'))
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs
    FROM public.job_contracts jc
    WHERE jc.mechanic_id = p_user_id
      AND NOT EXISTS (
        SELECT 1 FROM public.jobs j2 
        WHERE j2.id = jc.job_id AND j2.accepted_mechanic_id = p_user_id
      );
  ELSE
    -- For customers: count jobs they created
    SELECT 
      COUNT(*),
      COUNT(*) FILTER (WHERE j.status::text = 'completed' OR j.completed_at IS NOT NULL),
      COUNT(*) FILTER (WHERE j.status::text IN ('cancelled', 'canceled') OR j.cancelled_at IS NOT NULL)
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs
    FROM public.jobs j
    WHERE j.customer_id = p_user_id;
  END IF;

  -- =====================================================
  -- COUNT DISPUTES
  -- =====================================================
  SELECT COUNT(*)
  INTO v_disputed_jobs
  FROM public.disputes d
  WHERE d.filed_against = p_user_id
    AND d.status::text IN ('open', 'resolved', 'closed');

  -- =====================================================
  -- COUNT NO-SHOWS (from existing trust_scores if available)
  -- =====================================================
  SELECT COALESCE(no_show_count, 0)
  INTO v_no_show_count
  FROM public.trust_scores
  WHERE user_id = p_user_id;

  -- =====================================================
  -- COUNT REVIEWS
  -- =====================================================
  SELECT 
    COUNT(*),
    COALESCE(AVG(overall_rating), 0)
  INTO v_reviews_received, v_avg_rating_received
  FROM public.reviews
  WHERE reviewee_id = p_user_id
    AND (visibility::text = 'visible' OR visibility IS NULL);

  SELECT 
    COUNT(*),
    COALESCE(AVG(overall_rating), 0)
  INTO v_reviews_given, v_avg_rating_given
  FROM public.reviews
  WHERE reviewer_id = p_user_id;

  -- =====================================================
  -- COUNT ACTIVE BADGES
  -- =====================================================
  SELECT COUNT(*)
  INTO v_badge_count
  FROM public.user_badges
  WHERE user_id = p_user_id
    AND revoked_at IS NULL
    AND (expires_at IS NULL OR expires_at > now());

  -- =====================================================
  -- CALCULATE COMPONENT SCORES
  -- =====================================================
  
  -- Rating score: (avg_rating - 1) / 4 * 100, default 50 if no reviews
  IF v_reviews_received > 0 AND v_avg_rating_received > 0 THEN
    v_rating_score := LEAST(100, GREATEST(0, ROUND(((v_avg_rating_received - 1) / 4.0) * 100)::int));
  ELSE
    v_rating_score := 50;
  END IF;

  -- Completion score: completed_jobs / total_jobs * 100
  IF v_total_jobs > 0 THEN
    v_completion_score := LEAST(100, GREATEST(0, ROUND((v_completed_jobs::numeric / v_total_jobs) * 100)::int));
  ELSE
    v_completion_score := 100;
  END IF;

  -- Reliability score: start at 100, subtract penalties
  v_reliability_score := 100;
  v_reliability_score := v_reliability_score - (10 * COALESCE(v_cancelled_jobs, 0));
  v_reliability_score := v_reliability_score - (25 * COALESCE(v_no_show_count, 0));
  v_reliability_score := v_reliability_score - (15 * COALESCE(v_disputed_jobs, 0));
  v_reliability_score := LEAST(100, GREATEST(0, v_reliability_score));

  -- Badge score: badge_count * 10, capped at 100
  v_badge_score := LEAST(100, GREATEST(0, v_badge_count * 10));

  -- Tenure score: floor(days / 30) * 5, capped at 100
  v_tenure_score := LEAST(100, GREATEST(0, FLOOR(v_tenure_days / 30.0) * 5)::int);

  -- =====================================================
  -- CALCULATE OVERALL SCORE (weighted)
  -- =====================================================
  v_overall_score := ROUND(
    0.35 * v_rating_score +
    0.25 * v_completion_score +
    0.25 * v_reliability_score +
    0.10 * v_badge_score +
    0.05 * v_tenure_score
  )::int;
  v_overall_score := LEAST(100, GREATEST(0, v_overall_score));

  -- =====================================================
  -- UPSERT trust_scores
  -- =====================================================
  INSERT INTO public.trust_scores (
    user_id,
    overall_score,
    rating_score,
    completion_score,
    reliability_score,
    badge_score,
    tenure_score,
    total_jobs,
    completed_jobs,
    cancelled_jobs,
    disputed_jobs,
    no_show_count,
    reviews_given,
    reviews_received,
    avg_rating_given,
    avg_rating_received,
    last_calculated_at,
    created_at,
    updated_at
  ) VALUES (
    p_user_id,
    v_overall_score,
    v_rating_score,
    v_completion_score,
    v_reliability_score,
    v_badge_score,
    v_tenure_score,
    v_total_jobs,
    v_completed_jobs,
    v_cancelled_jobs,
    v_disputed_jobs,
    v_no_show_count,
    v_reviews_given,
    v_reviews_received,
    v_avg_rating_given,
    v_avg_rating_received,
    now(),
    now(),
    now()
  )
  ON CONFLICT (user_id) DO UPDATE SET
    overall_score = EXCLUDED.overall_score,
    rating_score = EXCLUDED.rating_score,
    completion_score = EXCLUDED.completion_score,
    reliability_score = EXCLUDED.reliability_score,
    badge_score = EXCLUDED.badge_score,
    tenure_score = EXCLUDED.tenure_score,
    total_jobs = EXCLUDED.total_jobs,
    completed_jobs = EXCLUDED.completed_jobs,
    cancelled_jobs = EXCLUDED.cancelled_jobs,
    disputed_jobs = EXCLUDED.disputed_jobs,
    no_show_count = EXCLUDED.no_show_count,
    reviews_given = EXCLUDED.reviews_given,
    reviews_received = EXCLUDED.reviews_received,
    avg_rating_given = EXCLUDED.avg_rating_given,
    avg_rating_received = EXCLUDED.avg_rating_received,
    last_calculated_at = now(),
    updated_at = now();

  -- =====================================================
  -- INSERT HISTORY SNAPSHOT
  -- =====================================================
  INSERT INTO public.trust_score_history (
    user_id,
    overall_score,
    rating_score,
    completion_score,
    reliability_score,
    badge_score,
    tenure_score,
    snapshot_reason,
    job_id,
    created_at
  ) VALUES (
    p_user_id,
    v_overall_score,
    v_rating_score,
    v_completion_score,
    v_reliability_score,
    v_badge_score,
    v_tenure_score,
    p_reason,
    p_job_id,
    now()
  );

  RETURN jsonb_build_object(
    'user_id', p_user_id,
    'overall_score', v_overall_score,
    'rating_score', v_rating_score,
    'completion_score', v_completion_score,
    'reliability_score', v_reliability_score,
    'badge_score', v_badge_score,
    'tenure_score', v_tenure_score,
    'total_jobs', v_total_jobs,
    'completed_jobs', v_completed_jobs,
    'cancelled_jobs', v_cancelled_jobs,
    'disputed_jobs', v_disputed_jobs,
    'reviews_received', v_reviews_received,
    'avg_rating_received', v_avg_rating_received,
    'badge_count', v_badge_count,
    'tenure_days', v_tenure_days,
    'reason', p_reason
  );
END;
$$;

COMMIT;\n-- ===================================================================
-- END: 20260127000011_fix_trust_trigger_enum.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000012_fix_trust_score_trigger_permission.sql
-- ===================================================================\n
-- Fix trust score permission check to allow trigger-based calls
-- The issue: when a review is submitted, the trigger tries to recalculate
-- the reviewee's trust score, but auth.uid() is the reviewer, causing permission denied

BEGIN;

-- Update recalculate_trust_score to skip permission check when called from trigger context
-- (when auth.uid() is NULL, it means it's being called from a trigger or internal function)
CREATE OR REPLACE FUNCTION public.recalculate_trust_score(
  p_user_id uuid,
  p_reason text DEFAULT 'manual_recalc',
  p_job_id uuid DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_jobs int := 0;
  v_completed_jobs int := 0;
  v_cancelled_jobs int := 0;
  v_disputed_jobs int := 0;
  v_no_show_count int := 0;
  v_reviews_received int := 0;
  v_reviews_given int := 0;
  v_avg_rating_received numeric := 0;
  v_avg_rating_given numeric := 0;
  v_badge_count int := 0;
  v_tenure_days int := 0;
  v_user_role text;
  v_rating_score int := 50;
  v_completion_score int := 100;
  v_reliability_score int := 100;
  v_badge_score int := 0;
  v_tenure_score int := 0;
  v_overall_score int := 50;
  v_created_at timestamptz;
  v_calling_uid uuid;
BEGIN
  -- Get calling user ID
  v_calling_uid := auth.uid();
  
  -- Permission check: 
  -- Allow if: no auth context (trigger/internal), user recalcing own score, or admin
  -- Skip check for trigger-based reasons
  IF v_calling_uid IS NOT NULL 
     AND v_calling_uid != p_user_id 
     AND NOT public.is_admin(v_calling_uid)
     AND p_reason NOT IN ('review_added', 'review_visible', 'job_completed', 'job_cancelled', 
                          'dispute_opened', 'dispute_resolved', 'badge_awarded', 'badge_revoked') THEN
    RAISE EXCEPTION 'Permission denied: cannot recalculate trust score for another user';
  END IF;

  -- Get user role and created_at
  SELECT role, created_at INTO v_user_role, v_created_at
  FROM public.profiles
  WHERE id = p_user_id;

  IF v_user_role IS NULL THEN
    RETURN jsonb_build_object('error', 'User not found');
  END IF;

  -- Calculate tenure days
  v_tenure_days := GREATEST(0, EXTRACT(DAY FROM (now() - v_created_at))::int);

  -- =====================================================
  -- COUNT JOBS (role-dependent) - cast status to text
  -- =====================================================
  IF v_user_role = 'mechanic' THEN
    SELECT 
      COUNT(*),
      COUNT(*) FILTER (WHERE j.status::text = 'completed' OR j.completed_at IS NOT NULL),
      COUNT(*) FILTER (WHERE j.status::text IN ('cancelled', 'canceled') OR j.cancelled_at IS NOT NULL)
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs
    FROM public.jobs j
    WHERE j.accepted_mechanic_id = p_user_id;
    
    SELECT 
      COALESCE(v_total_jobs, 0) + COUNT(*),
      COALESCE(v_completed_jobs, 0) + COUNT(*) FILTER (WHERE jc.status::text = 'completed'),
      COALESCE(v_cancelled_jobs, 0) + COUNT(*) FILTER (WHERE jc.status::text IN ('cancelled', 'canceled'))
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs
    FROM public.job_contracts jc
    WHERE jc.mechanic_id = p_user_id
      AND NOT EXISTS (
        SELECT 1 FROM public.jobs j2 
        WHERE j2.id = jc.job_id AND j2.accepted_mechanic_id = p_user_id
      );
  ELSE
    SELECT 
      COUNT(*),
      COUNT(*) FILTER (WHERE j.status::text = 'completed' OR j.completed_at IS NOT NULL),
      COUNT(*) FILTER (WHERE j.status::text IN ('cancelled', 'canceled') OR j.cancelled_at IS NOT NULL)
    INTO v_total_jobs, v_completed_jobs, v_cancelled_jobs
    FROM public.jobs j
    WHERE j.customer_id = p_user_id;
  END IF;

  -- COUNT DISPUTES
  SELECT COUNT(*)
  INTO v_disputed_jobs
  FROM public.disputes d
  WHERE d.filed_against = p_user_id
    AND d.status::text IN ('open', 'resolved', 'closed');

  -- COUNT NO-SHOWS
  SELECT COALESCE(no_show_count, 0)
  INTO v_no_show_count
  FROM public.trust_scores
  WHERE user_id = p_user_id;

  -- COUNT REVIEWS
  SELECT 
    COUNT(*),
    COALESCE(AVG(overall_rating), 0)
  INTO v_reviews_received, v_avg_rating_received
  FROM public.reviews
  WHERE reviewee_id = p_user_id
    AND (visibility::text = 'visible' OR visibility IS NULL);

  SELECT 
    COUNT(*),
    COALESCE(AVG(overall_rating), 0)
  INTO v_reviews_given, v_avg_rating_given
  FROM public.reviews
  WHERE reviewer_id = p_user_id;

  -- COUNT ACTIVE BADGES
  SELECT COUNT(*)
  INTO v_badge_count
  FROM public.user_badges
  WHERE user_id = p_user_id
    AND revoked_at IS NULL
    AND (expires_at IS NULL OR expires_at > now());

  -- CALCULATE COMPONENT SCORES
  IF v_reviews_received > 0 AND v_avg_rating_received > 0 THEN
    v_rating_score := LEAST(100, GREATEST(0, ROUND(((v_avg_rating_received - 1) / 4.0) * 100)::int));
  ELSE
    v_rating_score := 50;
  END IF;

  IF v_total_jobs > 0 THEN
    v_completion_score := LEAST(100, GREATEST(0, ROUND((v_completed_jobs::numeric / v_total_jobs) * 100)::int));
  ELSE
    v_completion_score := 100;
  END IF;

  v_reliability_score := 100;
  v_reliability_score := v_reliability_score - (10 * COALESCE(v_cancelled_jobs, 0));
  v_reliability_score := v_reliability_score - (25 * COALESCE(v_no_show_count, 0));
  v_reliability_score := v_reliability_score - (15 * COALESCE(v_disputed_jobs, 0));
  v_reliability_score := LEAST(100, GREATEST(0, v_reliability_score));

  v_badge_score := LEAST(100, GREATEST(0, v_badge_count * 10));
  v_tenure_score := LEAST(100, GREATEST(0, FLOOR(v_tenure_days / 30.0) * 5)::int);

  -- CALCULATE OVERALL SCORE
  v_overall_score := ROUND(
    0.35 * v_rating_score +
    0.25 * v_completion_score +
    0.25 * v_reliability_score +
    0.10 * v_badge_score +
    0.05 * v_tenure_score
  )::int;
  v_overall_score := LEAST(100, GREATEST(0, v_overall_score));

  -- UPSERT trust_scores
  INSERT INTO public.trust_scores (
    user_id, overall_score, rating_score, completion_score, reliability_score,
    badge_score, tenure_score, total_jobs, completed_jobs, cancelled_jobs,
    disputed_jobs, no_show_count, reviews_given, reviews_received,
    avg_rating_given, avg_rating_received, last_calculated_at, created_at, updated_at
  ) VALUES (
    p_user_id, v_overall_score, v_rating_score, v_completion_score, v_reliability_score,
    v_badge_score, v_tenure_score, v_total_jobs, v_completed_jobs, v_cancelled_jobs,
    v_disputed_jobs, v_no_show_count, v_reviews_given, v_reviews_received,
    v_avg_rating_given, v_avg_rating_received, now(), now(), now()
  )
  ON CONFLICT (user_id) DO UPDATE SET
    overall_score = EXCLUDED.overall_score,
    rating_score = EXCLUDED.rating_score,
    completion_score = EXCLUDED.completion_score,
    reliability_score = EXCLUDED.reliability_score,
    badge_score = EXCLUDED.badge_score,
    tenure_score = EXCLUDED.tenure_score,
    total_jobs = EXCLUDED.total_jobs,
    completed_jobs = EXCLUDED.completed_jobs,
    cancelled_jobs = EXCLUDED.cancelled_jobs,
    disputed_jobs = EXCLUDED.disputed_jobs,
    no_show_count = EXCLUDED.no_show_count,
    reviews_given = EXCLUDED.reviews_given,
    reviews_received = EXCLUDED.reviews_received,
    avg_rating_given = EXCLUDED.avg_rating_given,
    avg_rating_received = EXCLUDED.avg_rating_received,
    last_calculated_at = now(),
    updated_at = now();

  -- INSERT HISTORY SNAPSHOT
  INSERT INTO public.trust_score_history (
    user_id, overall_score, rating_score, completion_score, reliability_score,
    badge_score, tenure_score, snapshot_reason, job_id, created_at
  ) VALUES (
    p_user_id, v_overall_score, v_rating_score, v_completion_score, v_reliability_score,
    v_badge_score, v_tenure_score, p_reason, p_job_id, now()
  );

  RETURN jsonb_build_object(
    'user_id', p_user_id,
    'overall_score', v_overall_score,
    'rating_score', v_rating_score,
    'completion_score', v_completion_score,
    'reliability_score', v_reliability_score,
    'badge_score', v_badge_score,
    'tenure_score', v_tenure_score,
    'total_jobs', v_total_jobs,
    'completed_jobs', v_completed_jobs,
    'cancelled_jobs', v_cancelled_jobs,
    'disputed_jobs', v_disputed_jobs,
    'reviews_received', v_reviews_received,
    'avg_rating_received', v_avg_rating_received,
    'badge_count', v_badge_count,
    'tenure_days', v_tenure_days,
    'reason', p_reason
  );
END;
$$;

COMMIT;\n-- ===================================================================
-- END: 20260127000012_fix_trust_score_trigger_permission.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000013_fix_submit_review_finalized.sql
-- ===================================================================\n
-- Fix submit_review to handle missing finalized_at
-- Use job.completed_at or job_contracts.completed_at as fallback

BEGIN;

CREATE OR REPLACE FUNCTION public.submit_review(
  p_job_id uuid,
  p_reviewer_id uuid,
  p_reviewee_id uuid,
  p_rating int,
  p_comment text DEFAULT NULL,
  p_professionalism_rating int DEFAULT NULL,
  p_communication_rating int DEFAULT NULL,
  p_would_recommend boolean DEFAULT NULL,
  p_performance_rating int DEFAULT NULL,
  p_timing_rating int DEFAULT NULL,
  p_cost_rating int DEFAULT NULL,
  p_punctuality_rating int DEFAULT NULL,
  p_payment_rating int DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_review_id uuid;
  v_blind_deadline timestamptz;
  v_other_review_exists boolean;
  v_should_publish boolean := false;
  v_job_finalized_at timestamptz;
  v_job_completed_at timestamptz;
BEGIN
  -- Get job finalized timestamp from job_progress
  SELECT jp.finalized_at INTO v_job_finalized_at
  FROM public.job_progress jp
  WHERE jp.job_id = p_job_id;
  
  -- If no finalized_at, try to get completed_at from jobs or job_contracts
  IF v_job_finalized_at IS NULL THEN
    SELECT COALESCE(j.completed_at, jc.completed_at) INTO v_job_completed_at
    FROM public.jobs j
    LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
    WHERE j.id = p_job_id;
    
    v_job_finalized_at := v_job_completed_at;
  END IF;
  
  -- If still no completion date, check if job status is completed
  IF v_job_finalized_at IS NULL THEN
    SELECT 
      CASE WHEN j.status::text = 'completed' THEN COALESCE(j.updated_at, now()) ELSE NULL END
    INTO v_job_finalized_at
    FROM public.jobs j
    WHERE j.id = p_job_id;
  END IF;
  
  IF v_job_finalized_at IS NULL THEN
    RAISE EXCEPTION 'Job not completed yet';
  END IF;
  
  -- Set blind deadline to 7 days after job finalization
  v_blind_deadline := v_job_finalized_at + interval '7 days';
  
  -- Check if other party has already reviewed
  SELECT EXISTS(
    SELECT 1 FROM public.reviews
    WHERE job_id = p_job_id
      AND reviewer_id = p_reviewee_id
      AND reviewee_id = p_reviewer_id
  ) INTO v_other_review_exists;
  
  -- If both reviews exist, publish both immediately
  v_should_publish := v_other_review_exists;
  
  -- Insert or update review
  INSERT INTO public.reviews (
    job_id,
    reviewer_id,
    reviewee_id,
    overall_rating,
    comment,
    professionalism_rating,
    communication_rating,
    would_recommend,
    performance_rating,
    timing_rating,
    cost_rating,
    punctuality_rating,
    payment_rating,
    visibility,
    blind_deadline,
    created_at,
    updated_at
  ) VALUES (
    p_job_id,
    p_reviewer_id,
    p_reviewee_id,
    p_rating,
    p_comment,
    p_professionalism_rating,
    p_communication_rating,
    p_would_recommend,
    p_performance_rating,
    p_timing_rating,
    p_cost_rating,
    p_punctuality_rating,
    p_payment_rating,
    CASE WHEN v_should_publish THEN 'visible'::review_visibility ELSE 'hidden'::review_visibility END,
    v_blind_deadline,
    now(),
    now()
  )
  ON CONFLICT (job_id, reviewer_id) 
  DO UPDATE SET
    overall_rating = EXCLUDED.overall_rating,
    comment = EXCLUDED.comment,
    professionalism_rating = EXCLUDED.professionalism_rating,
    communication_rating = EXCLUDED.communication_rating,
    would_recommend = EXCLUDED.would_recommend,
    performance_rating = EXCLUDED.performance_rating,
    timing_rating = EXCLUDED.timing_rating,
    cost_rating = EXCLUDED.cost_rating,
    punctuality_rating = EXCLUDED.punctuality_rating,
    payment_rating = EXCLUDED.payment_rating,
    updated_at = now()
  RETURNING id INTO v_review_id;
  
  -- If both reviews exist, publish both
  IF v_should_publish THEN
    UPDATE public.reviews
    SET 
      visibility = 'visible',
      made_visible_at = now(),
      visibility_reason = 'both_submitted'
    WHERE job_id = p_job_id
      AND visibility = 'hidden';
  END IF;
  
  RETURN jsonb_build_object(
    'review_id', v_review_id,
    'published', v_should_publish,
    'blind_deadline', v_blind_deadline
  );
END;
$$;

COMMIT;\n-- ===================================================================
-- END: 20260127000013_fix_submit_review_finalized.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000014_safe_review_trigger.sql
-- ===================================================================\n
-- Temporarily disable review triggers to debug submit_review issue
-- Also wrap trust score recalculation in exception handler to prevent blocking

BEGIN;

-- Make the review trigger function safe - catch any errors
CREATE OR REPLACE FUNCTION public.trigger_recalc_trust_on_review()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Wrap in exception handler to prevent blocking review inserts
  BEGIN
    IF TG_OP = 'INSERT' THEN
      PERFORM public.recalculate_trust_score(NEW.reviewee_id, 'review_added', NEW.job_id);
    END IF;

    IF TG_OP = 'UPDATE' AND NEW.visibility::text = 'visible' AND (OLD.visibility IS NULL OR OLD.visibility::text != 'visible') THEN
      PERFORM public.recalculate_trust_score(NEW.reviewee_id, 'review_visible', NEW.job_id);
    END IF;
  EXCEPTION WHEN OTHERS THEN
    RAISE WARNING 'Trust score recalculation failed for user %: %', NEW.reviewee_id, SQLERRM;
  END;

  RETURN NEW;
END;
$$;

COMMIT;\n-- ===================================================================
-- END: 20260127000014_safe_review_trigger.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000015_add_reviews_unique_constraint.sql
-- ===================================================================\n
-- Add unique constraint on reviews for ON CONFLICT to work
BEGIN;

-- Add unique constraint if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint 
    WHERE conname = 'reviews_job_id_reviewer_id_key'
  ) THEN
    ALTER TABLE public.reviews 
    ADD CONSTRAINT reviews_job_id_reviewer_id_key 
    UNIQUE (job_id, reviewer_id);
  END IF;
END $$;

COMMIT;\n-- ===================================================================
-- END: 20260127000015_add_reviews_unique_constraint.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000016_fix_review_prompts_completion.sql
-- ===================================================================\n
-- Update review_prompts.completed_at when a review is submitted

BEGIN;

CREATE OR REPLACE FUNCTION public.submit_review(
  p_job_id uuid,
  p_reviewer_id uuid,
  p_reviewee_id uuid,
  p_rating int,
  p_comment text DEFAULT NULL,
  p_professionalism_rating int DEFAULT NULL,
  p_communication_rating int DEFAULT NULL,
  p_would_recommend boolean DEFAULT NULL,
  p_performance_rating int DEFAULT NULL,
  p_timing_rating int DEFAULT NULL,
  p_cost_rating int DEFAULT NULL,
  p_punctuality_rating int DEFAULT NULL,
  p_payment_rating int DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_review_id uuid;
  v_blind_deadline timestamptz;
  v_other_review_exists boolean;
  v_should_publish boolean := false;
  v_job_finalized_at timestamptz;
  v_job_completed_at timestamptz;
BEGIN
  -- Get job finalized timestamp from job_progress
  SELECT jp.finalized_at INTO v_job_finalized_at
  FROM public.job_progress jp
  WHERE jp.job_id = p_job_id;
  
  -- If no finalized_at, try to get completed_at from jobs or job_contracts
  IF v_job_finalized_at IS NULL THEN
    SELECT COALESCE(j.completed_at, jc.completed_at) INTO v_job_completed_at
    FROM public.jobs j
    LEFT JOIN public.job_contracts jc ON jc.job_id = j.id
    WHERE j.id = p_job_id;
    
    v_job_finalized_at := v_job_completed_at;
  END IF;
  
  -- If still no completion date, check if job status is completed
  IF v_job_finalized_at IS NULL THEN
    SELECT 
      CASE WHEN j.status::text = 'completed' THEN COALESCE(j.updated_at, now()) ELSE NULL END
    INTO v_job_finalized_at
    FROM public.jobs j
    WHERE j.id = p_job_id;
  END IF;
  
  IF v_job_finalized_at IS NULL THEN
    RAISE EXCEPTION 'Job not completed yet';
  END IF;
  
  -- Set blind deadline to 7 days after job finalization
  v_blind_deadline := v_job_finalized_at + interval '7 days';
  
  -- Check if other party has already reviewed
  SELECT EXISTS(
    SELECT 1 FROM public.reviews
    WHERE job_id = p_job_id
      AND reviewer_id = p_reviewee_id
      AND reviewee_id = p_reviewer_id
  ) INTO v_other_review_exists;
  
  -- If both reviews exist, publish both immediately
  v_should_publish := v_other_review_exists;
  
  -- Insert or update review
  INSERT INTO public.reviews (
    job_id,
    reviewer_id,
    reviewee_id,
    overall_rating,
    comment,
    professionalism_rating,
    communication_rating,
    would_recommend,
    performance_rating,
    timing_rating,
    cost_rating,
    punctuality_rating,
    payment_rating,
    visibility,
    blind_deadline,
    created_at,
    updated_at
  ) VALUES (
    p_job_id,
    p_reviewer_id,
    p_reviewee_id,
    p_rating,
    p_comment,
    p_professionalism_rating,
    p_communication_rating,
    p_would_recommend,
    p_performance_rating,
    p_timing_rating,
    p_cost_rating,
    p_punctuality_rating,
    p_payment_rating,
    CASE WHEN v_should_publish THEN 'visible'::review_visibility ELSE 'hidden'::review_visibility END,
    v_blind_deadline,
    now(),
    now()
  )
  ON CONFLICT (job_id, reviewer_id) 
  DO UPDATE SET
    overall_rating = EXCLUDED.overall_rating,
    comment = EXCLUDED.comment,
    professionalism_rating = EXCLUDED.professionalism_rating,
    communication_rating = EXCLUDED.communication_rating,
    would_recommend = EXCLUDED.would_recommend,
    performance_rating = EXCLUDED.performance_rating,
    timing_rating = EXCLUDED.timing_rating,
    cost_rating = EXCLUDED.cost_rating,
    punctuality_rating = EXCLUDED.punctuality_rating,
    payment_rating = EXCLUDED.payment_rating,
    updated_at = now()
  RETURNING id INTO v_review_id;
  
  -- Mark the review prompt as completed
  UPDATE public.review_prompts
  SET completed_at = now()
  WHERE job_id = p_job_id
    AND user_id = p_reviewer_id
    AND target_user_id = p_reviewee_id;
  
  -- If both reviews exist, publish both
  IF v_should_publish THEN
    UPDATE public.reviews
    SET 
      visibility = 'visible',
      made_visible_at = now(),
      visibility_reason = 'both_submitted'
    WHERE job_id = p_job_id
      AND visibility = 'hidden';
  END IF;
  
  RETURN jsonb_build_object(
    'review_id', v_review_id,
    'published', v_should_publish,
    'blind_deadline', v_blind_deadline
  );
END;
$$;

COMMIT;\n-- ===================================================================
-- END: 20260127000016_fix_review_prompts_completion.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260127000017_mechanic_skills_rollup.sql
-- ===================================================================\n
-- =====================================================
-- Migration: Mechanic Skills Rollup from skill_verifications
-- Purpose: Keep mechanic_skills as canonical source for verified skills display
-- =====================================================

-- =====================================================
-- A) RPC Function: recalculate_mechanic_skills
-- SECURITY DEFINER for manual/repair usage
-- =====================================================
CREATE OR REPLACE FUNCTION public.recalculate_mechanic_skills(p_mechanic_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Upsert mechanic_skills for all skill_keys found in skill_verifications
  INSERT INTO mechanic_skills (mechanic_id, skill_key, verified_job_count, avg_job_rating, last_verified_at, is_verified, updated_at)
  SELECT 
    sv.mechanic_id,
    sv.skill_key,
    COUNT(*)::int AS verified_job_count,
    AVG(sv.customer_rating)::numeric(3,2) AS avg_job_rating,
    MAX(sv.verified_at) AS last_verified_at,
    true AS is_verified,
    now() AS updated_at
  FROM skill_verifications sv
  WHERE sv.mechanic_id = p_mechanic_id
  GROUP BY sv.mechanic_id, sv.skill_key
  ON CONFLICT (mechanic_id, skill_key) DO UPDATE SET
    verified_job_count = EXCLUDED.verified_job_count,
    avg_job_rating = EXCLUDED.avg_job_rating,
    last_verified_at = EXCLUDED.last_verified_at,
    is_verified = EXCLUDED.is_verified,
    updated_at = now();
END;
$$;

COMMENT ON FUNCTION public.recalculate_mechanic_skills(uuid) IS 'Recalculate all verified skill aggregates for a mechanic from skill_verifications';

-- =====================================================
-- B) Trigger Function: on_skill_verification_insert_update_mechanic_skills
-- Efficient: only updates the affected mechanic_id + skill_key
-- =====================================================
CREATE OR REPLACE FUNCTION public.on_skill_verification_insert_update_mechanic_skills()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_count int;
  v_avg numeric(3,2);
  v_last timestamptz;
BEGIN
  -- Compute aggregates for the specific mechanic_id + skill_key
  SELECT 
    COUNT(*)::int,
    AVG(customer_rating)::numeric(3,2),
    MAX(verified_at)
  INTO v_count, v_avg, v_last
  FROM skill_verifications
  WHERE mechanic_id = NEW.mechanic_id
    AND skill_key = NEW.skill_key;

  -- Upsert into mechanic_skills
  INSERT INTO mechanic_skills (mechanic_id, skill_key, verified_job_count, avg_job_rating, last_verified_at, is_verified, updated_at)
  VALUES (NEW.mechanic_id, NEW.skill_key, v_count, v_avg, v_last, v_count >= 1, now())
  ON CONFLICT (mechanic_id, skill_key) DO UPDATE SET
    verified_job_count = v_count,
    avg_job_rating = v_avg,
    last_verified_at = v_last,
    is_verified = v_count >= 1,
    updated_at = now();

  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.on_skill_verification_insert_update_mechanic_skills() IS 'Trigger function to update mechanic_skills when skill_verifications changes';

-- =====================================================
-- Create Trigger: AFTER INSERT on skill_verifications
-- =====================================================
DROP TRIGGER IF EXISTS trg_skill_verification_update_mechanic_skills ON skill_verifications;

CREATE TRIGGER trg_skill_verification_update_mechanic_skills
  AFTER INSERT ON skill_verifications
  FOR EACH ROW
  EXECUTE FUNCTION on_skill_verification_insert_update_mechanic_skills();

-- =====================================================
-- C) Backfill: Recalculate for all existing mechanics with verifications
-- =====================================================
DO $$
DECLARE
  r RECORD;
BEGIN
  FOR r IN SELECT DISTINCT mechanic_id FROM skill_verifications
  LOOP
    PERFORM recalculate_mechanic_skills(r.mechanic_id);
  END LOOP;
END;
$$;

-- =====================================================
-- Diagnostic Queries (for verification - run manually)
-- =====================================================
-- 1) Check that mechanic_skills now has verified_job_count > 0:
-- SELECT * FROM mechanic_skills WHERE mechanic_id = :id AND verified_job_count > 0;

-- 2) Verify verifications exist:
-- SELECT mechanic_id, skill_key, COUNT(*) FROM skill_verifications WHERE mechanic_id = :id GROUP BY 1,2;
\n-- ===================================================================
-- END: 20260127000017_mechanic_skills_rollup.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260128000001_fix_admin_message_audit.sql
-- ===================================================================\n
-- =====================================================
-- Fix admin_send_message to handle message_audit_logs constraints
-- =====================================================

-- Create table with all needed columns if it doesn't exist
CREATE TABLE IF NOT EXISTS public.message_audit_logs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  message_id uuid NOT NULL,
  conversation_id uuid,
  sender_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
  recipient_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
  original_content text,
  displayed_content text,
  patterns_detected text[],
  risk_score numeric(5,2),
  action_taken text,
  action text,
  actor_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
  metadata jsonb,
  job_id uuid REFERENCES public.jobs(id) ON DELETE SET NULL,
  job_stage text,
  sender_account_age_days int,
  sender_completed_jobs int,
  sender_previous_violations int,
  flagged_for_review boolean DEFAULT false,
  reviewed_by uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
  reviewed_at timestamptz,
  review_decision text,
  review_notes text,
  created_at timestamptz DEFAULT now() NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_message_audit_sender ON public.message_audit_logs(sender_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_message_audit_conversation ON public.message_audit_logs(conversation_id);
CREATE INDEX IF NOT EXISTS idx_message_audit_flagged ON public.message_audit_logs(flagged_for_review) WHERE flagged_for_review = true;
CREATE INDEX IF NOT EXISTS idx_message_audit_job ON public.message_audit_logs(job_id) WHERE job_id IS NOT NULL;

-- Make conversation_id nullable (it's not needed for admin messages)
ALTER TABLE public.message_audit_logs ALTER COLUMN conversation_id DROP NOT NULL;

-- Make sender_id nullable (admin messages use actor_id instead)
ALTER TABLE public.message_audit_logs ALTER COLUMN sender_id DROP NOT NULL;

-- Make recipient_id nullable
ALTER TABLE public.message_audit_logs ALTER COLUMN recipient_id DROP NOT NULL;

-- Make original_content nullable (admin audit uses metadata instead)
ALTER TABLE public.message_audit_logs ALTER COLUMN original_content DROP NOT NULL;

-- Make action_taken nullable (admin audit uses action instead)
ALTER TABLE public.message_audit_logs ALTER COLUMN action_taken DROP NOT NULL;

-- Add optional columns for admin messages if they don't exist
ALTER TABLE public.message_audit_logs ADD COLUMN IF NOT EXISTS action text;
ALTER TABLE public.message_audit_logs ADD COLUMN IF NOT EXISTS actor_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL;
ALTER TABLE public.message_audit_logs ADD COLUMN IF NOT EXISTS metadata jsonb;

-- Create index on actor_id AFTER the column is added
CREATE INDEX IF NOT EXISTS idx_message_audit_actor ON public.message_audit_logs(actor_id) WHERE actor_id IS NOT NULL;

-- Update admin_send_message to gracefully handle missing audit table
CREATE OR REPLACE FUNCTION public.admin_send_message(
  p_recipient_id uuid,
  p_body text,
  p_related_job_id uuid DEFAULT NULL,
  p_support_request_id uuid DEFAULT NULL,
  p_dispute_id uuid DEFAULT NULL,
  p_attachment_url text DEFAULT NULL,
  p_attachment_type text DEFAULT NULL
)
RETURNS public.admin_messages
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id uuid;
  v_new_message public.admin_messages;
  v_recipient_exists boolean;
  v_job_participant boolean := true;
BEGIN
  v_admin_id := auth.uid();
  
  -- Check admin permission
  IF NOT public.is_admin(v_admin_id) THEN
    RAISE EXCEPTION 'Permission denied: admin role required';
  END IF;
  
  -- Validate recipient exists
  SELECT EXISTS(SELECT 1 FROM public.profiles WHERE id = p_recipient_id)
  INTO v_recipient_exists;
  
  IF NOT v_recipient_exists THEN
    RAISE EXCEPTION 'Recipient not found';
  END IF;
  
  -- Validate body length
  IF p_body IS NULL OR char_length(trim(p_body)) < 1 THEN
    RAISE EXCEPTION 'Message body is required';
  END IF;
  
  IF char_length(p_body) > 4000 THEN
    RAISE EXCEPTION 'Message body exceeds 4000 characters';
  END IF;
  
  -- Validate attachment_type if provided
  IF p_attachment_type IS NOT NULL AND p_attachment_type NOT IN ('image', 'file') THEN
    RAISE EXCEPTION 'Invalid attachment type';
  END IF;

  -- If job is linked, check if recipient is part of job (log warning but allow)
  IF p_related_job_id IS NOT NULL THEN
    BEGIN
      SELECT EXISTS(
        SELECT 1 FROM public.jobs j
        LEFT JOIN public.job_contracts c ON c.job_id = j.id
        WHERE j.id = p_related_job_id
          AND (j.customer_id = p_recipient_id OR c.mechanic_id = p_recipient_id)
      ) INTO v_job_participant;
    EXCEPTION WHEN undefined_table THEN
      v_job_participant := true;
    END;
  END IF;
  
  -- Insert the message
  INSERT INTO public.admin_messages (
    sender_admin_id,
    recipient_id,
    body,
    related_job_id,
    related_support_request_id,
    related_dispute_id,
    attachment_url,
    attachment_type
  ) VALUES (
    v_admin_id,
    p_recipient_id,
    trim(p_body),
    p_related_job_id,
    p_support_request_id,
    p_dispute_id,
    p_attachment_url,
    p_attachment_type
  )
  RETURNING * INTO v_new_message;
  
  -- Write audit log (gracefully handle if table doesn't exist or has different schema)
  BEGIN
    INSERT INTO public.message_audit_logs (
      message_id,
      action,
      actor_id,
      metadata
    ) VALUES (
      v_new_message.id,
      'ADMIN_SEND_MESSAGE',
      v_admin_id,
      jsonb_build_object(
        'recipient_id', p_recipient_id,
        'related_job_id', p_related_job_id,
        'related_support_request_id', p_support_request_id,
        'related_dispute_id', p_dispute_id,
        'job_participant', v_job_participant
      )
    );
  EXCEPTION WHEN undefined_table OR undefined_column THEN
    -- Audit table doesn't exist or has different schema, skip logging
    NULL;
  END;
  
  -- If job linked, write job_event
  IF p_related_job_id IS NOT NULL THEN
    BEGIN
      INSERT INTO public.job_events (
        job_id,
        event_type,
        actor_id,
        actor_role,
        visible_to_customer,
        visible_to_mechanic,
        metadata
      ) VALUES (
        p_related_job_id,
        'admin_message_sent',
        v_admin_id,
        'admin',
        true,
        true,
        jsonb_build_object(
          'admin_message_id', v_new_message.id,
          'recipient_id', p_recipient_id
        )
      );
    EXCEPTION WHEN undefined_table OR undefined_column THEN
      -- job_events table doesn't exist, skip
      NULL;
    END;
  END IF;
  
  RETURN v_new_message;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_send_message TO authenticated;\n-- ===================================================================
-- END: 20260128000001_fix_admin_message_audit.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260129000001_add_admin_message_event_type.sql
-- ===================================================================\n
-- =====================================================
-- Add admin_message_sent to job_event_type enum
-- =====================================================

-- Add the new enum value if it doesn't exist
DO $$
BEGIN
  -- Check if the enum type exists and add the value
  IF EXISTS (SELECT 1 FROM pg_type WHERE typname = 'job_event_type') THEN
    BEGIN
      ALTER TYPE public.job_event_type ADD VALUE IF NOT EXISTS 'admin_message_sent';
    EXCEPTION WHEN duplicate_object THEN
      -- Value already exists, ignore
      NULL;
    END;
  END IF;
END $$;

-- Update admin_send_message to handle all possible exceptions for job_events insert
CREATE OR REPLACE FUNCTION public.admin_send_message(
  p_recipient_id uuid,
  p_body text,
  p_related_job_id uuid DEFAULT NULL,
  p_support_request_id uuid DEFAULT NULL,
  p_dispute_id uuid DEFAULT NULL,
  p_attachment_url text DEFAULT NULL,
  p_attachment_type text DEFAULT NULL
)
RETURNS public.admin_messages
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id uuid;
  v_new_message public.admin_messages;
  v_recipient_exists boolean;
  v_job_participant boolean := true;
BEGIN
  v_admin_id := auth.uid();
  
  -- Check admin permission
  IF NOT public.is_admin(v_admin_id) THEN
    RAISE EXCEPTION 'Permission denied: admin role required';
  END IF;
  
  -- Validate recipient exists
  SELECT EXISTS(SELECT 1 FROM public.profiles WHERE id = p_recipient_id)
  INTO v_recipient_exists;
  
  IF NOT v_recipient_exists THEN
    RAISE EXCEPTION 'Recipient not found';
  END IF;
  
  -- Validate body length
  IF p_body IS NULL OR char_length(trim(p_body)) < 1 THEN
    RAISE EXCEPTION 'Message body is required';
  END IF;
  
  IF char_length(p_body) > 4000 THEN
    RAISE EXCEPTION 'Message body exceeds 4000 characters';
  END IF;
  
  -- Validate attachment_type if provided
  IF p_attachment_type IS NOT NULL AND p_attachment_type NOT IN ('image', 'file') THEN
    RAISE EXCEPTION 'Invalid attachment type';
  END IF;

  -- If job is linked, check if recipient is part of job (log warning but allow)
  IF p_related_job_id IS NOT NULL THEN
    BEGIN
      SELECT EXISTS(
        SELECT 1 FROM public.jobs j
        LEFT JOIN public.job_contracts c ON c.job_id = j.id
        WHERE j.id = p_related_job_id
          AND (j.customer_id = p_recipient_id OR c.mechanic_id = p_recipient_id)
      ) INTO v_job_participant;
    EXCEPTION WHEN undefined_table THEN
      v_job_participant := true;
    END;
  END IF;
  
  -- Insert the message
  INSERT INTO public.admin_messages (
    sender_admin_id,
    recipient_id,
    body,
    related_job_id,
    related_support_request_id,
    related_dispute_id,
    attachment_url,
    attachment_type
  ) VALUES (
    v_admin_id,
    p_recipient_id,
    trim(p_body),
    p_related_job_id,
    p_support_request_id,
    p_dispute_id,
    p_attachment_url,
    p_attachment_type
  )
  RETURNING * INTO v_new_message;
  
  -- Write audit log (gracefully handle if table doesn't exist or has different schema)
  BEGIN
    INSERT INTO public.message_audit_logs (
      message_id,
      action,
      actor_id,
      metadata
    ) VALUES (
      v_new_message.id,
      'ADMIN_SEND_MESSAGE',
      v_admin_id,
      jsonb_build_object(
        'recipient_id', p_recipient_id,
        'related_job_id', p_related_job_id,
        'related_support_request_id', p_support_request_id,
        'related_dispute_id', p_dispute_id,
        'job_participant', v_job_participant
      )
    );
  EXCEPTION WHEN OTHERS THEN
    -- Audit table doesn't exist or has different schema, skip logging
    NULL;
  END;
  
  -- If job linked, write job_event (skip if enum value doesn't exist)
  IF p_related_job_id IS NOT NULL THEN
    BEGIN
      INSERT INTO public.job_events (
        job_id,
        event_type,
        actor_id,
        actor_role,
        visible_to_customer,
        visible_to_mechanic,
        metadata
      ) VALUES (
        p_related_job_id,
        'admin_message_sent',
        v_admin_id,
        'admin',
        true,
        true,
        jsonb_build_object(
          'admin_message_id', v_new_message.id,
          'recipient_id', p_recipient_id
        )
      );
    EXCEPTION WHEN OTHERS THEN
      -- job_events table doesn't exist or enum value not available, skip
      NULL;
    END;
  END IF;
  
  RETURN v_new_message;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_send_message TO authenticated;\n-- ===================================================================
-- END: 20260129000001_add_admin_message_event_type.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260130000001_no_double_booking.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: No Double Booking System
-- =====================================================
-- Purpose: Prevent mechanics from being double-booked for overlapping time windows
-- When a quote is accepted, all overlapping pending quotes from that mechanic are expired
-- =====================================================

BEGIN;

-- =====================================================
-- A) Add estimated_duration_minutes to jobs
-- =====================================================
ALTER TABLE public.jobs 
ADD COLUMN IF NOT EXISTS estimated_duration_minutes int NOT NULL DEFAULT 90;

COMMENT ON COLUMN public.jobs.estimated_duration_minutes IS 'Estimated job duration in minutes, used for scheduling conflict detection';

-- =====================================================
-- B) Add time window columns to quotes
-- =====================================================
ALTER TABLE public.quotes 
ADD COLUMN IF NOT EXISTS proposed_start_at timestamptz,
ADD COLUMN IF NOT EXISTS proposed_end_at timestamptz,
ADD COLUMN IF NOT EXISTS conflict_status_reason text;

COMMENT ON COLUMN public.quotes.proposed_start_at IS 'Start time of the proposed service window (copied from job.scheduled_at)';
COMMENT ON COLUMN public.quotes.proposed_end_at IS 'End time of the proposed service window (scheduled_at + duration)';
COMMENT ON COLUMN public.quotes.conflict_status_reason IS 'Reason for conflict-based status change (e.g., time_conflict)';

-- =====================================================
-- C) Update quotes status CHECK constraint to include expired_conflict
-- =====================================================
ALTER TABLE public.quotes DROP CONSTRAINT IF EXISTS quotes_status_check;
ALTER TABLE public.quotes ADD CONSTRAINT quotes_status_check 
  CHECK (status IN ('pending', 'accepted', 'declined', 'expired', 'withdrawn', 'expired_conflict'));

-- =====================================================
-- D) Add booking window columns to job_contracts
-- =====================================================
ALTER TABLE public.job_contracts 
ADD COLUMN IF NOT EXISTS scheduled_start_at timestamptz,
ADD COLUMN IF NOT EXISTS scheduled_end_at timestamptz;

COMMENT ON COLUMN public.job_contracts.scheduled_start_at IS 'Booked start time for conflict detection';
COMMENT ON COLUMN public.job_contracts.scheduled_end_at IS 'Booked end time for conflict detection';

-- =====================================================
-- E) Create indexes for performance
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_quotes_mechanic_conflict_check
  ON public.quotes (mechanic_id, status, proposed_start_at, proposed_end_at)
  WHERE status = 'pending';

CREATE INDEX IF NOT EXISTS idx_job_contracts_mechanic_schedule
  ON public.job_contracts (mechanic_id, scheduled_start_at, scheduled_end_at, status)
  WHERE status IN ('pending_payment', 'active');

CREATE INDEX IF NOT EXISTS idx_jobs_scheduled_at
  ON public.jobs (scheduled_at)
  WHERE scheduled_at IS NOT NULL;

-- =====================================================
-- F) Add event types for conflict handling
-- =====================================================
DO $$ BEGIN
  ALTER TYPE public.job_event_type ADD VALUE IF NOT EXISTS 'quote_expired_conflict';
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- =====================================================
-- G) Backfill existing quotes with time windows
-- =====================================================
UPDATE public.quotes q
SET 
  proposed_start_at = j.scheduled_at,
  proposed_end_at = j.scheduled_at + (COALESCE(j.estimated_duration_minutes, 90) * interval '1 minute')
FROM public.jobs j
WHERE q.job_id = j.id
  AND q.proposed_start_at IS NULL
  AND j.scheduled_at IS NOT NULL;

-- =====================================================
-- H) Backfill existing contracts with booking windows
-- =====================================================
UPDATE public.job_contracts jc
SET 
  scheduled_start_at = j.scheduled_at,
  scheduled_end_at = j.scheduled_at + (COALESCE(j.estimated_duration_minutes, 90) * interval '1 minute')
FROM public.jobs j
WHERE jc.job_id = j.id
  AND jc.scheduled_start_at IS NULL
  AND j.scheduled_at IS NOT NULL;

-- =====================================================
-- I) Trigger to auto-populate quote time windows on insert
-- =====================================================
CREATE OR REPLACE FUNCTION public.set_quote_time_window()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
  v_job RECORD;
BEGIN
  SELECT scheduled_at, estimated_duration_minutes
  INTO v_job
  FROM public.jobs
  WHERE id = NEW.job_id;
  
  IF v_job.scheduled_at IS NOT NULL THEN
    NEW.proposed_start_at := v_job.scheduled_at;
    NEW.proposed_end_at := v_job.scheduled_at + (COALESCE(v_job.estimated_duration_minutes, 90) * interval '1 minute');
  END IF;
  
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_set_quote_time_window ON public.quotes;
CREATE TRIGGER trg_set_quote_time_window
  BEFORE INSERT ON public.quotes
  FOR EACH ROW
  WHEN (NEW.proposed_start_at IS NULL)
  EXECUTE FUNCTION public.set_quote_time_window();

-- =====================================================
-- J) CORE RPC: accept_quote_and_resolve_conflicts
-- =====================================================
-- This replaces accept_quote_and_create_contract with conflict detection
-- Uses SELECT FOR UPDATE for concurrency safety

CREATE OR REPLACE FUNCTION public.accept_quote_and_resolve_conflicts(
  p_quote_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_quote RECORD;
  v_job RECORD;
  v_contract_id uuid;
  v_progress_id uuid;
  v_platform_fee_cents int := 1500;
  v_commission_cents int;
  v_total_customer_cents int;
  v_mechanic_payout_cents int;
  v_line_item_id uuid;
  v_terms_check jsonb;
  v_mechanic_promo_result jsonb;
  v_booking_start timestamptz;
  v_booking_end timestamptz;
  v_conflict_contract_id uuid;
  v_expired_quote_ids uuid[];
  v_expired_count int := 0;
  v_mechanic_name text;
  v_job_title text;
BEGIN
  -- ENFORCEMENT: Check platform terms accepted
  v_terms_check := public.check_terms_accepted('customer');
  IF NOT (v_terms_check->>'accepted')::boolean THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Please accept platform terms first',
      'requires_terms', true,
      'terms_version', v_terms_check->>'version'
    );
  END IF;

  -- Get quote with lock (FOR UPDATE prevents concurrent acceptance)
  SELECT 
    q.*, 
    j.customer_id as job_customer_id, 
    j.status as job_status, 
    j.id as actual_job_id,
    j.scheduled_at,
    j.estimated_duration_minutes,
    j.title as job_title
  INTO v_quote
  FROM public.quotes q
  JOIN public.jobs j ON j.id = q.job_id
  WHERE q.id = p_quote_id
  FOR UPDATE OF q, j;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote not found');
  END IF;
  
  IF v_quote.job_customer_id != p_customer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  IF v_quote.status NOT IN ('pending', 'accepted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote is no longer available');
  END IF;
  
  IF v_quote.job_status NOT IN ('searching', 'quoted', 'accepted') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job is no longer accepting quotes');
  END IF;
  
  -- ENFORCEMENT: Check job acknowledgement exists
  IF NOT EXISTS (
    SELECT 1 FROM public.job_acknowledgements
    WHERE job_id = v_quote.actual_job_id 
    AND user_id = p_customer_id 
    AND role = 'customer'
  ) THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Please acknowledge job terms first',
      'requires_acknowledgement', true,
      'job_id', v_quote.actual_job_id
    );
  END IF;
  
  -- Calculate booking window
  v_booking_start := COALESCE(v_quote.proposed_start_at, v_quote.scheduled_at);
  v_booking_end := COALESCE(
    v_quote.proposed_end_at, 
    v_quote.scheduled_at + (COALESCE(v_quote.estimated_duration_minutes, 90) * interval '1 minute')
  );
  
  -- If no scheduled time, we can't do conflict checking
  IF v_booking_start IS NULL THEN
    v_booking_start := now();
    v_booking_end := now() + interval '90 minutes';
  END IF;
  
  -- =====================================================
  -- CONFLICT CHECK: Ensure mechanic isn't already booked
  -- =====================================================
  SELECT jc.id INTO v_conflict_contract_id
  FROM public.job_contracts jc
  WHERE jc.mechanic_id = v_quote.mechanic_id
    AND jc.status IN ('pending_payment', 'active')
    AND jc.scheduled_start_at < v_booking_end
    AND jc.scheduled_end_at > v_booking_start
  LIMIT 1
  FOR UPDATE;
  
  IF v_conflict_contract_id IS NOT NULL THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Mechanic is no longer available at that time.',
      'error_code', 'MECHANIC_UNAVAILABLE',
      'conflict_contract_id', v_conflict_contract_id
    );
  END IF;
  
  -- Check if contract already exists for this job (retry scenario)
  SELECT id INTO v_contract_id
  FROM public.job_contracts
  WHERE job_id = v_quote.job_id;
  
  IF v_contract_id IS NOT NULL THEN
    -- Contract exists, return it
    RETURN jsonb_build_object(
      'success', true,
      'contract_id', v_contract_id,
      'already_exists', true,
      'expired_quote_ids', ARRAY[]::uuid[],
      'expired_count', 0,
      'scheduled_start_at', v_booking_start,
      'scheduled_end_at', v_booking_end
    );
  END IF;
  
  -- Calculate fees
  v_commission_cents := calculate_mechanic_commission(v_quote.price_cents);
  v_total_customer_cents := v_quote.price_cents + v_platform_fee_cents;
  v_mechanic_payout_cents := v_quote.price_cents - v_commission_cents;
  
  -- Create contract with booking window
  INSERT INTO public.job_contracts (
    job_id, quote_id, customer_id, mechanic_id,
    status, quoted_price_cents, platform_fee_cents, estimated_hours,
    subtotal_cents, total_customer_cents, mechanic_commission_cents, mechanic_payout_cents,
    customer_acknowledged_at, scheduled_start_at, scheduled_end_at
  ) VALUES (
    v_quote.job_id, p_quote_id, p_customer_id, v_quote.mechanic_id,
    'active', v_quote.price_cents, v_platform_fee_cents, v_quote.estimated_hours,
    v_quote.price_cents, v_total_customer_cents, v_commission_cents, v_mechanic_payout_cents,
    now(), v_booking_start, v_booking_end
  )
  RETURNING id INTO v_contract_id;
  
  -- Auto-apply mechanic promo credit
  v_mechanic_promo_result := public.apply_mechanic_promo_to_contract(
    v_contract_id,
    v_quote.mechanic_id,
    v_commission_cents
  );
  
  -- Update job_acknowledgements with contract_id
  UPDATE public.job_acknowledgements
  SET contract_id = v_contract_id
  WHERE job_id = v_quote.job_id AND user_id = p_customer_id AND role = 'customer';
  
  -- Create initial line item for base labor
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'base_labor', 'Service as quoted', 1, v_quote.price_cents, v_quote.price_cents,
    'approved', false, v_quote.mechanic_id, 'mechanic', 0
  )
  RETURNING id INTO v_line_item_id;
  
  -- Create platform fee line item
  INSERT INTO public.invoice_line_items (
    contract_id, item_type, description, quantity, unit_price_cents, total_cents,
    approval_status, requires_approval, added_by, added_by_role, sort_order
  ) VALUES (
    v_contract_id, 'platform_fee', 'WrenchGo platform fee', 1, v_platform_fee_cents, v_platform_fee_cents,
    'approved', false, p_customer_id, 'customer', 100
  );
  
  -- Create job progress record
  INSERT INTO public.job_progress (job_id, contract_id)
  VALUES (v_quote.job_id, v_contract_id)
  RETURNING id INTO v_progress_id;
  
  -- Update quote status
  UPDATE public.quotes
  SET status = 'accepted', updated_at = now()
  WHERE id = p_quote_id;
  
  -- Decline all other quotes for this job
  UPDATE public.quotes
  SET status = 'declined', updated_at = now()
  WHERE job_id = v_quote.job_id AND id != p_quote_id AND status = 'pending';
  
  -- Update job status
  UPDATE public.jobs
  SET 
    status = 'accepted',
    accepted_mechanic_id = v_quote.mechanic_id,
    updated_at = now()
  WHERE id = v_quote.job_id;
  
  -- =====================================================
  -- EXPIRE OVERLAPPING PENDING QUOTES FROM SAME MECHANIC
  -- =====================================================
  WITH expired AS (
    UPDATE public.quotes
    SET 
      status = 'expired_conflict', 
      conflict_status_reason = 'time_conflict',
      updated_at = now()
    WHERE mechanic_id = v_quote.mechanic_id
      AND id != p_quote_id
      AND status = 'pending'
      AND proposed_start_at IS NOT NULL
      AND proposed_end_at IS NOT NULL
      AND proposed_start_at < v_booking_end
      AND proposed_end_at > v_booking_start
    RETURNING id, job_id
  )
  SELECT array_agg(id), count(*) INTO v_expired_quote_ids, v_expired_count FROM expired;
  
  -- Default to empty array if null
  v_expired_quote_ids := COALESCE(v_expired_quote_ids, ARRAY[]::uuid[]);
  v_expired_count := COALESCE(v_expired_count, 0);
  
  -- Log event for accepted quote
  PERFORM log_job_event(
    v_quote.job_id, v_contract_id, 'contract_created',
    p_customer_id, 'customer',
    'Contract created',
    'Quote accepted and contract created',
    jsonb_build_object(
      'quoted_price_cents', v_quote.price_cents,
      'platform_fee_cents', v_platform_fee_cents,
      'total_cents', v_total_customer_cents,
      'mechanic_promo_applied', COALESCE((v_mechanic_promo_result->>'has_credit')::boolean, false),
      'mechanic_promo_discount_cents', COALESCE((v_mechanic_promo_result->>'discount_cents')::int, 0),
      'expired_conflict_count', v_expired_count,
      'scheduled_start_at', v_booking_start,
      'scheduled_end_at', v_booking_end
    ),
    v_total_customer_cents
  );
  
  -- Log events for expired quotes
  IF v_expired_count > 0 THEN
    PERFORM log_job_event(
      v_quote.job_id, v_contract_id, 'quote_expired_conflict',
      v_quote.mechanic_id, 'mechanic',
      'Overlapping quotes expired',
      format('%s pending quote(s) expired due to time conflict', v_expired_count),
      jsonb_build_object(
        'expired_quote_ids', v_expired_quote_ids,
        'expired_count', v_expired_count,
        'booking_start', v_booking_start,
        'booking_end', v_booking_end
      ),
      NULL
    );
  END IF;
  
  -- =====================================================
  -- NOTIFICATION: Notify mechanic of acceptance + conflicts
  -- =====================================================
  SELECT p.full_name INTO v_mechanic_name
  FROM public.profiles p
  WHERE p.id = v_quote.mechanic_id;
  
  v_job_title := v_quote.job_title;
  
  INSERT INTO public.notifications (
    user_id, title, body, type, entity_type, entity_id, data
  ) VALUES (
    v_quote.mechanic_id,
    'Quote accepted  booking confirmed',
    CASE 
      WHEN v_expired_count > 0 THEN
        format('%s booked for %s. %s overlapping quote(s) expired.', 
          v_job_title, 
          to_char(v_booking_start AT TIME ZONE 'UTC', 'Mon DD, HH12:MI AM'),
          v_expired_count)
      ELSE
        format('%s booked for %s', 
          v_job_title, 
          to_char(v_booking_start AT TIME ZONE 'UTC', 'Mon DD, HH12:MI AM'))
    END,
    'quote_accepted',
    'job',
    v_quote.job_id,
    jsonb_build_object(
      'accepted_job_id', v_quote.job_id,
      'accepted_quote_id', p_quote_id,
      'contract_id', v_contract_id,
      'expired_quote_ids', v_expired_quote_ids,
      'expired_count', v_expired_count,
      'scheduled_start_at', v_booking_start,
      'scheduled_end_at', v_booking_end
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'contract_id', v_contract_id,
    'total_cents', v_total_customer_cents,
    'mechanic_id', v_quote.mechanic_id,
    'mechanic_promo_applied', COALESCE((v_mechanic_promo_result->>'has_credit')::boolean, false),
    'mechanic_promo_discount_cents', COALESCE((v_mechanic_promo_result->>'discount_cents')::int, 0),
    'expired_quote_ids', v_expired_quote_ids,
    'expired_count', v_expired_count,
    'scheduled_start_at', v_booking_start,
    'scheduled_end_at', v_booking_end
  );
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION public.accept_quote_and_resolve_conflicts(uuid, uuid) TO authenticated;

-- =====================================================
-- K) Update accept_quote_and_create_contract to call new function
-- =====================================================
-- Keep backward compatibility by making old function call new one
CREATE OR REPLACE FUNCTION public.accept_quote_and_create_contract(
  p_quote_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN public.accept_quote_and_resolve_conflicts(p_quote_id, p_customer_id);
END;
$$;

COMMIT;
\n-- ===================================================================
-- END: 20260130000001_no_double_booking.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260130000002_fix_mark_admin_message_read.sql
-- ===================================================================\n
-- Fix mark_admin_message_read RPC: v_updated should be integer, not boolean
-- Error: "operator does not exist: boolean > integer" (code 42883)

CREATE OR REPLACE FUNCTION public.mark_admin_message_read(p_message_id uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_row_count int;
BEGIN
  UPDATE public.admin_messages
  SET read_at = now()
  WHERE id = p_message_id
    AND recipient_id = auth.uid()
    AND read_at IS NULL
    AND deleted_at IS NULL;
  
  GET DIAGNOSTICS v_row_count = ROW_COUNT;
  RETURN v_row_count > 0;
END;
$$;
\n-- ===================================================================
-- END: 20260130000002_fix_mark_admin_message_read.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260131000001_support_thread_replies.sql
-- ===================================================================\n
-- =====================================================
-- Support Thread Replies
-- Allow users to reply to admin messages (two-way support chat)
-- =====================================================

-- 1. Add sender_type column to distinguish admin vs user messages
ALTER TABLE public.admin_messages 
ADD COLUMN IF NOT EXISTS sender_type text NOT NULL DEFAULT 'admin' 
CHECK (sender_type IN ('admin', 'user'));

-- 2. Add thread_id to group related messages
ALTER TABLE public.admin_messages 
ADD COLUMN IF NOT EXISTS thread_id uuid;

-- 3. Create index for thread queries
CREATE INDEX IF NOT EXISTS idx_admin_messages_thread 
  ON public.admin_messages(thread_id, created_at ASC) 
  WHERE thread_id IS NOT NULL;

-- 4. Update RLS to allow users to insert their own replies
DROP POLICY IF EXISTS admin_messages_user_reply ON public.admin_messages;
CREATE POLICY admin_messages_user_reply ON public.admin_messages
  FOR INSERT TO authenticated
  WITH CHECK (
    sender_type = 'user' 
    AND sender_admin_id = auth.uid()
    AND recipient_id = auth.uid()
  );

-- 5. RPC: User sends reply to support thread
CREATE OR REPLACE FUNCTION public.user_reply_to_support(
  p_body text,
  p_thread_id uuid DEFAULT NULL,
  p_related_job_id uuid DEFAULT NULL,
  p_related_support_request_id uuid DEFAULT NULL,
  p_attachment_url text DEFAULT NULL,
  p_attachment_type text DEFAULT NULL
)
RETURNS public.admin_messages
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_new_message public.admin_messages;
  v_thread_id uuid;
BEGIN
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Authentication required';
  END IF;
  
  -- Validate body
  IF p_body IS NULL OR char_length(trim(p_body)) < 1 THEN
    RAISE EXCEPTION 'Message body is required';
  END IF;
  
  IF char_length(p_body) > 4000 THEN
    RAISE EXCEPTION 'Message body exceeds 4000 characters';
  END IF;
  
  -- Validate attachment_type if provided
  IF p_attachment_type IS NOT NULL AND p_attachment_type NOT IN ('image', 'file') THEN
    RAISE EXCEPTION 'Invalid attachment type';
  END IF;
  
  -- Determine thread_id
  IF p_thread_id IS NOT NULL THEN
    -- Verify user owns this thread
    IF NOT EXISTS (
      SELECT 1 FROM public.admin_messages 
      WHERE (thread_id = p_thread_id OR id = p_thread_id)
        AND recipient_id = v_user_id
        AND deleted_at IS NULL
    ) THEN
      RAISE EXCEPTION 'Thread not found or access denied';
    END IF;
    v_thread_id := p_thread_id;
  ELSE
    -- Create new thread (use the message id as thread_id)
    v_thread_id := gen_random_uuid();
  END IF;
  
  -- Insert the user reply
  INSERT INTO public.admin_messages (
    sender_admin_id,
    recipient_id,
    body,
    sender_type,
    thread_id,
    related_job_id,
    related_support_request_id,
    attachment_url,
    attachment_type,
    read_at
  ) VALUES (
    v_user_id,
    v_user_id,
    trim(p_body),
    'user',
    v_thread_id,
    p_related_job_id,
    p_related_support_request_id,
    p_attachment_url,
    p_attachment_type,
    now()
  )
  RETURNING * INTO v_new_message;
  
  RETURN v_new_message;
END;
$$;

-- 6. RPC: Get support thread messages
CREATE OR REPLACE FUNCTION public.get_support_thread(
  p_thread_id uuid,
  p_limit int DEFAULT 100
)
RETURNS TABLE (
  id uuid,
  sender_id uuid,
  sender_name text,
  sender_type text,
  body text,
  related_job_id uuid,
  related_job_title text,
  attachment_url text,
  attachment_type text,
  read_at timestamptz,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    am.id,
    am.sender_admin_id as sender_id,
    CASE 
      WHEN am.sender_type = 'admin' THEN COALESCE(p.full_name, 'Support Team')
      ELSE 'You'
    END as sender_name,
    am.sender_type,
    am.body,
    am.related_job_id,
    j.title as related_job_title,
    am.attachment_url,
    am.attachment_type,
    am.read_at,
    am.created_at
  FROM public.admin_messages am
  LEFT JOIN public.profiles p ON p.id = am.sender_admin_id AND am.sender_type = 'admin'
  LEFT JOIN public.jobs j ON j.id = am.related_job_id
  WHERE (am.thread_id = p_thread_id OR am.id = p_thread_id)
    AND am.recipient_id = auth.uid()
    AND am.deleted_at IS NULL
  ORDER BY am.created_at ASC
  LIMIT p_limit;
END;
$$;

-- 7. RPC: Get or create user's support thread
CREATE OR REPLACE FUNCTION public.get_or_create_support_thread()
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_thread_id uuid;
BEGIN
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Authentication required';
  END IF;
  
  -- Find existing thread (most recent)
  SELECT COALESCE(thread_id, id) INTO v_thread_id
  FROM public.admin_messages
  WHERE recipient_id = v_user_id
    AND deleted_at IS NULL
  ORDER BY created_at DESC
  LIMIT 1;
  
  -- If no thread exists, create a placeholder
  IF v_thread_id IS NULL THEN
    v_thread_id := gen_random_uuid();
  END IF;
  
  RETURN v_thread_id;
END;
$$;

-- 8. Update list_my_admin_messages to include thread_id
DROP FUNCTION IF EXISTS public.list_my_admin_messages(int, int);
CREATE OR REPLACE FUNCTION public.list_my_admin_messages(
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  sender_admin_id uuid,
  sender_name text,
  sender_type text,
  body text,
  related_job_id uuid,
  related_job_title text,
  related_support_request_id uuid,
  related_dispute_id uuid,
  attachment_url text,
  attachment_type text,
  read_at timestamptz,
  created_at timestamptz,
  thread_id uuid
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    am.id,
    am.sender_admin_id,
    CASE 
      WHEN am.sender_type = 'admin' THEN COALESCE(p.full_name, 'Support Team')
      ELSE 'You'
    END as sender_name,
    am.sender_type,
    am.body,
    am.related_job_id,
    j.title as related_job_title,
    am.related_support_request_id,
    am.related_dispute_id,
    am.attachment_url,
    am.attachment_type,
    am.read_at,
    am.created_at,
    COALESCE(am.thread_id, am.id) as thread_id
  FROM public.admin_messages am
  LEFT JOIN public.profiles p ON p.id = am.sender_admin_id AND am.sender_type = 'admin'
  LEFT JOIN public.jobs j ON j.id = am.related_job_id
  WHERE am.recipient_id = auth.uid()
    AND am.deleted_at IS NULL
  ORDER BY am.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

-- 9. Grant permissions
GRANT EXECUTE ON FUNCTION public.user_reply_to_support TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_support_thread TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_or_create_support_thread TO authenticated;
\n-- ===================================================================
-- END: 20260131000001_support_thread_replies.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260131000002_support_threads_list.sql
-- ===================================================================\n
-- Migration: List support threads (conversations) instead of individual messages
-- This groups messages by thread_id and returns one row per conversation

-- Create RPC to list support threads for the current user
CREATE OR REPLACE FUNCTION public.list_my_support_threads(
  p_limit integer DEFAULT 50,
  p_offset integer DEFAULT 0
)
RETURNS TABLE (
  thread_id uuid,
  subject text,
  last_message_body text,
  last_message_at timestamptz,
  last_message_sender_type text,
  unread_count bigint,
  total_messages bigint,
  related_job_id uuid,
  related_job_title text,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  WITH thread_stats AS (
    SELECT
      am.thread_id,
      COUNT(*) AS total_messages,
      COUNT(*) FILTER (WHERE am.read_at IS NULL AND am.sender_type = 'admin') AS unread_count,
      MAX(am.created_at) AS last_message_at,
      MIN(am.created_at) AS first_message_at
    FROM admin_messages am
    WHERE am.recipient_id = auth.uid()
      AND am.thread_id IS NOT NULL
    GROUP BY am.thread_id
  ),
  latest_messages AS (
    SELECT DISTINCT ON (am.thread_id)
      am.thread_id,
      am.body AS last_message_body,
      am.sender_type AS last_message_sender_type,
      am.related_job_id,
      am.created_at
    FROM admin_messages am
    WHERE am.recipient_id = auth.uid()
      AND am.thread_id IS NOT NULL
    ORDER BY am.thread_id, am.created_at DESC
  )
  SELECT
    ts.thread_id,
    COALESCE(j.title, 'Support Conversation')::text AS subject,
    lm.last_message_body,
    ts.last_message_at,
    lm.last_message_sender_type,
    ts.unread_count,
    ts.total_messages,
    lm.related_job_id,
    j.title AS related_job_title,
    ts.first_message_at AS created_at
  FROM thread_stats ts
  JOIN latest_messages lm ON lm.thread_id = ts.thread_id
  LEFT JOIN jobs j ON j.id = lm.related_job_id
  ORDER BY ts.last_message_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION public.list_my_support_threads(integer, integer) TO authenticated;

-- Create RPC to get unread thread count (number of threads with unread messages)
CREATE OR REPLACE FUNCTION public.get_unread_support_thread_count()
RETURNS bigint
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_count bigint;
BEGIN
  SELECT COUNT(DISTINCT thread_id) INTO v_count
  FROM admin_messages
  WHERE recipient_id = auth.uid()
    AND thread_id IS NOT NULL
    AND read_at IS NULL
    AND sender_type = 'admin';
  
  RETURN COALESCE(v_count, 0);
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION public.get_unread_support_thread_count() TO authenticated;

-- Create RPC to mark all messages in a thread as read
CREATE OR REPLACE FUNCTION public.mark_support_thread_read(
  p_thread_id uuid
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE admin_messages
  SET read_at = NOW()
  WHERE thread_id = p_thread_id
    AND recipient_id = auth.uid()
    AND read_at IS NULL
    AND sender_type = 'admin';
  
  RETURN TRUE;
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION public.mark_support_thread_read(uuid) TO authenticated;\n-- ===================================================================
-- END: 20260131000002_support_threads_list.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260201000001_admin_hub_scoping.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: ADMIN HUB SCOPING
-- =====================================================
-- Adds hub_id to admin_users for hub-admin scoping
-- Updates all admin RPCs to respect hub scope
-- =====================================================

BEGIN;

-- =====================================================
-- A) ADD HUB SCOPING TO ADMIN_USERS
-- =====================================================
ALTER TABLE public.admin_users
  ADD COLUMN IF NOT EXISTS hub_id uuid REFERENCES public.service_hubs(id) ON DELETE SET NULL;

COMMENT ON COLUMN public.admin_users.hub_id IS 'Hub ID for hub-admin scoping. NULL = super admin sees all.';

-- =====================================================
-- B) HELPER FUNCTIONS FOR ADMIN SCOPE
-- =====================================================

-- Get admin hub_id (NULL for super admins)
CREATE OR REPLACE FUNCTION public.get_admin_hub_id(uid uuid DEFAULT auth.uid())
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_hub_id uuid;
BEGIN
  SELECT hub_id INTO v_hub_id
  FROM public.admin_users
  WHERE user_id = uid;
  RETURN v_hub_id;
END;
$$;

-- Check if admin can access a specific hub
CREATE OR REPLACE FUNCTION public.admin_can_access_hub(target_hub_id uuid, uid uuid DEFAULT auth.uid())
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_is_super boolean;
  v_admin_hub_id uuid;
BEGIN
  SELECT is_super, hub_id INTO v_is_super, v_admin_hub_id
  FROM public.admin_users
  WHERE user_id = uid;
  
  IF v_is_super THEN
    RETURN true;
  END IF;
  
  IF v_admin_hub_id IS NULL THEN
    RETURN false;
  END IF;
  
  RETURN v_admin_hub_id = target_hub_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_admin_hub_id(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_can_access_hub(uuid, uuid) TO authenticated;

-- =====================================================
-- C) UPDATED ADMIN RPCs WITH HUB SCOPING
-- =====================================================

-- C.1) admin_get_jobs - with hub scoping, search, date range, pagination
DROP FUNCTION IF EXISTS public.admin_get_jobs(text, uuid, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_jobs(
  p_status text DEFAULT NULL,
  p_hub_id uuid DEFAULT NULL,
  p_search text DEFAULT NULL,
  p_date_from timestamptz DEFAULT NULL,
  p_date_to timestamptz DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  title text,
  status text,
  customer_id uuid,
  customer_name text,
  mechanic_id uuid,
  mechanic_name text,
  hub_id uuid,
  hub_name text,
  created_at timestamptz,
  completed_at timestamptz,
  quote_count bigint,
  has_dispute boolean,
  has_support_ticket boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_hub_id uuid;
  v_is_super boolean;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  SELECT is_super, au.hub_id INTO v_is_super, v_admin_hub_id
  FROM public.admin_users au
  WHERE au.user_id = auth.uid();

  RETURN QUERY
  SELECT 
    j.id,
    j.title::text,
    j.status::text,
    j.customer_id,
    cp.full_name::text as customer_name,
    j.accepted_mechanic_id as mechanic_id,
    mp.full_name::text as mechanic_name,
    j.hub_id,
    h.name::text as hub_name,
    j.created_at,
    j.completed_at,
    (SELECT COUNT(*) FROM public.quotes q WHERE q.job_id = j.id) as quote_count,
    EXISTS(SELECT 1 FROM public.disputes d WHERE d.job_id = j.id) as has_dispute,
    EXISTS(SELECT 1 FROM public.support_requests sr WHERE sr.job_id = j.id) as has_support_ticket
  FROM public.jobs j
  LEFT JOIN public.profiles cp ON cp.id = j.customer_id
  LEFT JOIN public.profiles mp ON mp.id = j.accepted_mechanic_id
  LEFT JOIN public.service_hubs h ON h.id = j.hub_id
  WHERE 
    (v_is_super OR j.hub_id = v_admin_hub_id)
    AND (p_status IS NULL OR j.status = p_status)
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id)
    AND (p_date_from IS NULL OR j.created_at >= p_date_from)
    AND (p_date_to IS NULL OR j.created_at <= p_date_to)
    AND (p_search IS NULL OR p_search = '' OR 
         j.title ILIKE '%' || p_search || '%' OR
         j.id::text ILIKE '%' || p_search || '%' OR
         cp.full_name ILIKE '%' || p_search || '%' OR
         mp.full_name ILIKE '%' || p_search || '%')
  ORDER BY j.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_jobs(text, uuid, text, timestamptz, timestamptz, int, int) TO authenticated;

-- C.2) admin_get_mechanics - with hub scoping, search, date range, pagination
DROP FUNCTION IF EXISTS public.admin_get_mechanics(text, uuid, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_mechanics(
  p_status text DEFAULT NULL,
  p_hub_id uuid DEFAULT NULL,
  p_tier text DEFAULT NULL,
  p_search text DEFAULT NULL,
  p_date_from timestamptz DEFAULT NULL,
  p_date_to timestamptz DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  full_name text,
  email text,
  phone text,
  verification_status text,
  tier text,
  hub_id uuid,
  hub_name text,
  rating_avg numeric,
  rating_count bigint,
  jobs_completed bigint,
  is_available boolean,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_hub_id uuid;
  v_is_super boolean;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  SELECT is_super, au.hub_id INTO v_is_super, v_admin_hub_id
  FROM public.admin_users au
  WHERE au.user_id = auth.uid();

  RETURN QUERY
  SELECT 
    p.id,
    p.full_name::text,
    p.email::text,
    p.phone::text,
    mp.verification_status::text,
    mp.tier::text,
    p.hub_id,
    h.name::text as hub_name,
    mp.rating_avg,
    mp.rating_count,
    mp.jobs_completed,
    mp.is_available,
    p.created_at
  FROM public.profiles p
  JOIN public.mechanic_profiles mp ON mp.id = p.id
  LEFT JOIN public.service_hubs h ON h.id = p.hub_id
  WHERE 
    p.role = 'mechanic'
    AND (v_is_super OR p.hub_id = v_admin_hub_id)
    AND (p_status IS NULL OR mp.verification_status = p_status)
    AND (p_hub_id IS NULL OR p.hub_id = p_hub_id)
    AND (p_tier IS NULL OR mp.tier = p_tier)
    AND (p_date_from IS NULL OR p.created_at >= p_date_from)
    AND (p_date_to IS NULL OR p.created_at <= p_date_to)
    AND (p_search IS NULL OR p_search = '' OR 
         p.full_name ILIKE '%' || p_search || '%' OR
         p.email ILIKE '%' || p_search || '%' OR
         p.phone ILIKE '%' || p_search || '%')
  ORDER BY p.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_mechanics(text, uuid, text, text, timestamptz, timestamptz, int, int) TO authenticated;

-- C.3) admin_list_customers - with hub scoping, search, date range, pagination
DROP FUNCTION IF EXISTS public.admin_list_customers(int, int, text);

CREATE OR REPLACE FUNCTION public.admin_list_customers(
  p_hub_id uuid DEFAULT NULL,
  p_search text DEFAULT NULL,
  p_date_from timestamptz DEFAULT NULL,
  p_date_to timestamptz DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  customer_id uuid,
  full_name text,
  email text,
  phone text,
  city text,
  state text,
  hub_id uuid,
  hub_name text,
  created_at timestamptz,
  total_jobs bigint,
  completed_jobs bigint,
  total_spent_cents bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_hub_id uuid;
  v_is_super boolean;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  SELECT is_super, au.hub_id INTO v_is_super, v_admin_hub_id
  FROM public.admin_users au
  WHERE au.user_id = auth.uid();

  RETURN QUERY
  SELECT 
    p.id as customer_id,
    p.full_name::text,
    p.email::text,
    p.phone::text,
    p.city::text,
    p.state::text,
    p.hub_id,
    h.name::text as hub_name,
    p.created_at,
    (SELECT COUNT(*) FROM public.jobs j WHERE j.customer_id = p.id) as total_jobs,
    (SELECT COUNT(*) FROM public.jobs j WHERE j.customer_id = p.id AND j.status = 'completed') as completed_jobs,
    COALESCE((SELECT SUM(c.total_customer_cents) FROM public.contracts c 
              JOIN public.jobs j ON j.id = c.job_id 
              WHERE j.customer_id = p.id AND c.status = 'completed'), 0)::bigint as total_spent_cents
  FROM public.profiles p
  LEFT JOIN public.service_hubs h ON h.id = p.hub_id
  WHERE 
    p.role = 'customer'
    AND (v_is_super OR p.hub_id = v_admin_hub_id)
    AND (p_hub_id IS NULL OR p.hub_id = p_hub_id)
    AND (p_date_from IS NULL OR p.created_at >= p_date_from)
    AND (p_date_to IS NULL OR p.created_at <= p_date_to)
    AND (p_search IS NULL OR p_search = '' OR 
         p.full_name ILIKE '%' || p_search || '%' OR
         p.email ILIKE '%' || p_search || '%' OR
         p.phone ILIKE '%' || p_search || '%')
  ORDER BY p.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_list_customers(uuid, text, timestamptz, timestamptz, int, int) TO authenticated;

-- C.4) admin_list_support_requests - with hub scoping, search, date range
DROP FUNCTION IF EXISTS public.admin_list_support_requests(text, text, int, int);

CREATE OR REPLACE FUNCTION public.admin_list_support_threads(
  p_hub_id uuid DEFAULT NULL,
  p_status text DEFAULT NULL,
  p_search text DEFAULT NULL,
  p_date_from timestamptz DEFAULT NULL,
  p_date_to timestamptz DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  thread_id uuid,
  user_id uuid,
  user_name text,
  user_role text,
  user_email text,
  hub_id uuid,
  hub_name text,
  job_id uuid,
  job_title text,
  status text,
  last_message text,
  last_message_at timestamptz,
  unread_count bigint,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_hub_id uuid;
  v_is_super boolean;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  SELECT is_super, au.hub_id INTO v_is_super, v_admin_hub_id
  FROM public.admin_users au
  WHERE au.user_id = auth.uid();

  RETURN QUERY
  WITH thread_data AS (
    SELECT DISTINCT ON (am.thread_id)
      am.thread_id,
      am.user_id,
      am.related_job_id,
      am.body as last_message,
      am.created_at as last_message_at,
      FIRST_VALUE(am.created_at) OVER (PARTITION BY am.thread_id ORDER BY am.created_at ASC) as thread_created_at
    FROM public.admin_messages am
    WHERE am.thread_id IS NOT NULL
    ORDER BY am.thread_id, am.created_at DESC
  )
  SELECT 
    td.thread_id,
    td.user_id,
    p.full_name::text as user_name,
    p.role::text as user_role,
    p.email::text as user_email,
    p.hub_id,
    h.name::text as hub_name,
    td.related_job_id as job_id,
    j.title::text as job_title,
    CASE WHEN EXISTS(SELECT 1 FROM public.admin_messages am2 WHERE am2.thread_id = td.thread_id AND am2.read_at IS NULL AND am2.sender_type = 'user') 
         THEN 'open'::text ELSE 'closed'::text END as status,
    td.last_message::text,
    td.last_message_at,
    (SELECT COUNT(*) FROM public.admin_messages am3 WHERE am3.thread_id = td.thread_id AND am3.read_at IS NULL AND am3.sender_type = 'user') as unread_count,
    td.thread_created_at as created_at
  FROM thread_data td
  JOIN public.profiles p ON p.id = td.user_id
  LEFT JOIN public.service_hubs h ON h.id = p.hub_id
  LEFT JOIN public.jobs j ON j.id = td.related_job_id
  WHERE 
    (v_is_super OR p.hub_id = v_admin_hub_id)
    AND (p_hub_id IS NULL OR p.hub_id = p_hub_id)
    AND (p_status IS NULL OR 
         (p_status = 'open' AND EXISTS(SELECT 1 FROM public.admin_messages am2 WHERE am2.thread_id = td.thread_id AND am2.read_at IS NULL AND am2.sender_type = 'user')) OR
         (p_status = 'closed' AND NOT EXISTS(SELECT 1 FROM public.admin_messages am2 WHERE am2.thread_id = td.thread_id AND am2.read_at IS NULL AND am2.sender_type = 'user')))
    AND (p_date_from IS NULL OR td.thread_created_at >= p_date_from)
    AND (p_date_to IS NULL OR td.thread_created_at <= p_date_to)
    AND (p_search IS NULL OR p_search = '' OR 
         p.full_name ILIKE '%' || p_search || '%' OR
         td.thread_id::text ILIKE '%' || p_search || '%' OR
         td.related_job_id::text ILIKE '%' || p_search || '%')
  ORDER BY td.last_message_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_list_support_threads(uuid, text, text, timestamptz, timestamptz, int, int) TO authenticated;

-- C.5) admin_get_payments - with hub scoping, search, date range
DROP FUNCTION IF EXISTS public.admin_get_payments(text, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_payments(
  p_hub_id uuid DEFAULT NULL,
  p_status text DEFAULT NULL,
  p_search text DEFAULT NULL,
  p_date_from timestamptz DEFAULT NULL,
  p_date_to timestamptz DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  job_id uuid,
  job_title text,
  customer_id uuid,
  customer_name text,
  mechanic_id uuid,
  mechanic_name text,
  hub_id uuid,
  hub_name text,
  amount_cents int,
  status text,
  created_at timestamptz,
  paid_at timestamptz,
  refunded_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_hub_id uuid;
  v_is_super boolean;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  SELECT is_super, au.hub_id INTO v_is_super, v_admin_hub_id
  FROM public.admin_users au
  WHERE au.user_id = auth.uid();

  RETURN QUERY
  SELECT 
    pay.id,
    pay.job_id,
    j.title::text as job_title,
    j.customer_id,
    cp.full_name::text as customer_name,
    c.mechanic_id,
    mp.full_name::text as mechanic_name,
    j.hub_id,
    h.name::text as hub_name,
    pay.amount_cents::int,
    pay.status::text,
    pay.created_at,
    pay.paid_at,
    pay.refunded_at
  FROM public.payments pay
  JOIN public.jobs j ON j.id = pay.job_id
  LEFT JOIN public.contracts c ON c.job_id = j.id
  LEFT JOIN public.profiles cp ON cp.id = j.customer_id
  LEFT JOIN public.profiles mp ON mp.id = c.mechanic_id
  LEFT JOIN public.service_hubs h ON h.id = j.hub_id
  WHERE 
    (v_is_super OR j.hub_id = v_admin_hub_id)
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id)
    AND (p_status IS NULL OR pay.status = p_status)
    AND (p_date_from IS NULL OR pay.created_at >= p_date_from)
    AND (p_date_to IS NULL OR pay.created_at <= p_date_to)
    AND (p_search IS NULL OR p_search = '' OR 
         pay.id::text ILIKE '%' || p_search || '%' OR
         j.id::text ILIKE '%' || p_search || '%' OR
         cp.full_name ILIKE '%' || p_search || '%')
  ORDER BY pay.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_payments(uuid, text, text, timestamptz, timestamptz, int, int) TO authenticated;

-- C.6) admin_get_payouts - with hub scoping, search, date range
DROP FUNCTION IF EXISTS public.admin_get_payouts(text, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_payouts(
  p_hub_id uuid DEFAULT NULL,
  p_status text DEFAULT NULL,
  p_search text DEFAULT NULL,
  p_date_from timestamptz DEFAULT NULL,
  p_date_to timestamptz DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  mechanic_id uuid,
  mechanic_name text,
  hub_id uuid,
  hub_name text,
  gross_amount_cents int,
  net_amount_cents int,
  commission_cents int,
  status text,
  created_at timestamptz,
  processed_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_hub_id uuid;
  v_is_super boolean;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  SELECT is_super, au.hub_id INTO v_is_super, v_admin_hub_id
  FROM public.admin_users au
  WHERE au.user_id = auth.uid();

  RETURN QUERY
  SELECT 
    po.id,
    po.mechanic_id,
    p.full_name::text as mechanic_name,
    p.hub_id,
    h.name::text as hub_name,
    po.gross_amount_cents::int,
    po.net_amount_cents::int,
    po.commission_cents::int,
    po.status::text,
    po.created_at,
    po.processed_at
  FROM public.payouts po
  JOIN public.profiles p ON p.id = po.mechanic_id
  LEFT JOIN public.service_hubs h ON h.id = p.hub_id
  WHERE 
    (v_is_super OR p.hub_id = v_admin_hub_id)
    AND (p_hub_id IS NULL OR p.hub_id = p_hub_id)
    AND (p_status IS NULL OR po.status = p_status)
    AND (p_date_from IS NULL OR po.created_at >= p_date_from)
    AND (p_date_to IS NULL OR po.created_at <= p_date_to)
    AND (p_search IS NULL OR p_search = '' OR 
         po.id::text ILIKE '%' || p_search || '%' OR
         p.full_name ILIKE '%' || p_search || '%')
  ORDER BY po.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_payouts(uuid, text, text, timestamptz, timestamptz, int, int) TO authenticated;

-- C.7) admin_list_disputes - with hub scoping, search, date range
DROP FUNCTION IF EXISTS public.admin_list_disputes(text, int, int);

CREATE OR REPLACE FUNCTION public.admin_list_disputes(
  p_hub_id uuid DEFAULT NULL,
  p_status text DEFAULT NULL,
  p_search text DEFAULT NULL,
  p_date_from timestamptz DEFAULT NULL,
  p_date_to timestamptz DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  job_id uuid,
  job_title text,
  customer_id uuid,
  customer_name text,
  mechanic_id uuid,
  mechanic_name text,
  hub_id uuid,
  hub_name text,
  category text,
  status text,
  priority text,
  created_at timestamptz,
  resolved_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_hub_id uuid;
  v_is_super boolean;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  SELECT is_super, au.hub_id INTO v_is_super, v_admin_hub_id
  FROM public.admin_users au
  WHERE au.user_id = auth.uid();

  RETURN QUERY
  SELECT 
    d.id,
    d.job_id,
    j.title::text as job_title,
    j.customer_id,
    cp.full_name::text as customer_name,
    j.accepted_mechanic_id as mechanic_id,
    mp.full_name::text as mechanic_name,
    j.hub_id,
    h.name::text as hub_name,
    d.category::text,
    d.status::text,
    d.priority::text,
    d.created_at,
    d.resolved_at
  FROM public.disputes d
  JOIN public.jobs j ON j.id = d.job_id
  LEFT JOIN public.profiles cp ON cp.id = j.customer_id
  LEFT JOIN public.profiles mp ON mp.id = j.accepted_mechanic_id
  LEFT JOIN public.service_hubs h ON h.id = j.hub_id
  WHERE 
    (v_is_super OR j.hub_id = v_admin_hub_id)
    AND (p_hub_id IS NULL OR j.hub_id = p_hub_id)
    AND (p_status IS NULL OR d.status = p_status)
    AND (p_date_from IS NULL OR d.created_at >= p_date_from)
    AND (p_date_to IS NULL OR d.created_at <= p_date_to)
    AND (p_search IS NULL OR p_search = '' OR 
         d.id::text ILIKE '%' || p_search || '%' OR
         j.id::text ILIKE '%' || p_search || '%' OR
         cp.full_name ILIKE '%' || p_search || '%' OR
         mp.full_name ILIKE '%' || p_search || '%')
  ORDER BY d.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_list_disputes(uuid, text, text, timestamptz, timestamptz, int, int) TO authenticated;

-- C.8) admin_get_verification_queue - with hub scoping
DROP FUNCTION IF EXISTS public.admin_get_verification_queue(text, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_verification_queue(
  p_hub_id uuid DEFAULT NULL,
  p_status text DEFAULT NULL,
  p_search text DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  full_name text,
  email text,
  phone text,
  hub_id uuid,
  hub_name text,
  verification_status text,
  verification_reason text,
  created_at timestamptz,
  verification_updated_at timestamptz,
  documents_count bigint,
  pending_documents bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_hub_id uuid;
  v_is_super boolean;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  SELECT is_super, au.hub_id INTO v_is_super, v_admin_hub_id
  FROM public.admin_users au
  WHERE au.user_id = auth.uid();

  RETURN QUERY
  SELECT 
    p.id,
    p.full_name::text,
    p.email::text,
    p.phone::text,
    p.hub_id,
    h.name::text as hub_name,
    mp.verification_status::text,
    mp.verification_reason::text,
    p.created_at,
    mp.verification_updated_at,
    (SELECT COUNT(*) FROM public.mechanic_documents md WHERE md.mechanic_id = p.id) as documents_count,
    (SELECT COUNT(*) FROM public.mechanic_documents md WHERE md.mechanic_id = p.id AND md.status = 'pending') as pending_documents
  FROM public.profiles p
  JOIN public.mechanic_profiles mp ON mp.id = p.id
  LEFT JOIN public.service_hubs h ON h.id = p.hub_id
  WHERE 
    p.role = 'mechanic'
    AND (v_is_super OR p.hub_id = v_admin_hub_id)
    AND (p_hub_id IS NULL OR p.hub_id = p_hub_id)
    AND (p_status IS NULL OR mp.verification_status = p_status)
    AND (p_search IS NULL OR p_search = '' OR 
         p.full_name ILIKE '%' || p_search || '%' OR
         p.email ILIKE '%' || p_search || '%')
  ORDER BY 
    CASE WHEN mp.verification_status = 'pending_verification' THEN 0 ELSE 1 END,
    p.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_verification_queue(uuid, text, text, int, int) TO authenticated;

-- C.9) admin_get_waitlist - with hub scoping
DROP FUNCTION IF EXISTS public.admin_get_waitlist(uuid, int, int);

CREATE OR REPLACE FUNCTION public.admin_get_waitlist(
  p_hub_id uuid DEFAULT NULL,
  p_status text DEFAULT NULL,
  p_search text DEFAULT NULL,
  p_date_from timestamptz DEFAULT NULL,
  p_date_to timestamptz DEFAULT NULL,
  p_limit int DEFAULT 50,
  p_offset int DEFAULT 0
)
RETURNS TABLE (
  id uuid,
  email text,
  phone text,
  full_name text,
  zip text,
  city text,
  state text,
  user_type text,
  hub_id uuid,
  hub_name text,
  status text,
  created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_hub_id uuid;
  v_is_super boolean;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  SELECT is_super, au.hub_id INTO v_is_super, v_admin_hub_id
  FROM public.admin_users au
  WHERE au.user_id = auth.uid();

  RETURN QUERY
  SELECT 
    w.id,
    w.email::text,
    w.phone::text,
    w.full_name::text,
    w.zip::text,
    zc.city::text,
    zc.state::text,
    w.user_type::text,
    w.hub_id,
    h.name::text as hub_name,
    COALESCE(w.status, 'new')::text as status,
    w.created_at
  FROM public.waitlist w
  LEFT JOIN public.zip_codes zc ON zc.zip = w.zip
  LEFT JOIN public.service_hubs h ON h.id = w.hub_id
  WHERE 
    (v_is_super OR w.hub_id = v_admin_hub_id OR v_admin_hub_id IS NULL)
    AND (p_hub_id IS NULL OR w.hub_id = p_hub_id)
    AND (p_status IS NULL OR COALESCE(w.status, 'new') = p_status)
    AND (p_date_from IS NULL OR w.created_at >= p_date_from)
    AND (p_date_to IS NULL OR w.created_at <= p_date_to)
    AND (p_search IS NULL OR p_search = '' OR 
         w.full_name ILIKE '%' || p_search || '%' OR
         w.email ILIKE '%' || p_search || '%' OR
         w.phone ILIKE '%' || p_search || '%')
  ORDER BY w.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_waitlist(uuid, text, text, timestamptz, timestamptz, int, int) TO authenticated;

-- C.10) admin_get_hubs - updated with hub scoping for hub admins
DROP FUNCTION IF EXISTS public.admin_get_hubs();

CREATE OR REPLACE FUNCTION public.admin_get_hubs()
RETURNS TABLE (
  id uuid,
  name text,
  slug text,
  zip text,
  city text,
  state text,
  lat numeric,
  lng numeric,
  active_radius_miles int,
  max_radius_miles int,
  invite_only boolean,
  auto_expand_enabled boolean,
  is_active boolean,
  launch_date date,
  created_at timestamptz,
  active_mechanics bigint,
  jobs_last_14d bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_hub_id uuid;
  v_is_super boolean;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN;
  END IF;

  SELECT is_super, au.hub_id INTO v_is_super, v_admin_hub_id
  FROM public.admin_users au
  WHERE au.user_id = auth.uid();

  RETURN QUERY
  SELECT 
    h.id,
    h.name::text,
    h.slug::text,
    h.zip::text,
    zc.city::text,
    zc.state::text,
    h.lat::numeric,
    h.lng::numeric,
    h.active_radius_miles::int,
    h.max_radius_miles::int,
    h.invite_only,
    h.auto_expand_enabled,
    h.is_active,
    h.launch_date,
    h.created_at,
    (SELECT COUNT(DISTINCT p.id) 
     FROM public.profiles p
     JOIN public.mechanic_profiles mp ON mp.id = p.id
     WHERE p.hub_id = h.id AND mp.verification_status = 'active') as active_mechanics,
    (SELECT COUNT(*) 
     FROM public.jobs j 
     WHERE j.hub_id = h.id AND j.created_at >= CURRENT_DATE - 14) as jobs_last_14d
  FROM public.service_hubs h
  LEFT JOIN public.zip_codes zc ON zc.zip = h.zip
  WHERE v_is_super OR h.id = v_admin_hub_id
  ORDER BY h.name;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_hubs() TO authenticated;

-- C.11) admin_get_metrics - with hub scoping
DROP FUNCTION IF EXISTS public.admin_get_metrics(uuid, int);

CREATE OR REPLACE FUNCTION public.admin_get_metrics(
  p_hub_id uuid DEFAULT NULL,
  p_days int DEFAULT 14
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_hub_id uuid;
  v_is_super boolean;
  v_effective_hub_id uuid;
  v_start_date timestamptz;
  v_result jsonb;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT is_super, au.hub_id INTO v_is_super, v_admin_hub_id
  FROM public.admin_users au
  WHERE au.user_id = auth.uid();

  -- Hub admins can only see their hub
  IF NOT v_is_super AND v_admin_hub_id IS NOT NULL THEN
    v_effective_hub_id := v_admin_hub_id;
  ELSE
    v_effective_hub_id := p_hub_id;
  END IF;

  v_start_date := CURRENT_DATE - p_days;

  SELECT jsonb_build_object(
    'period_days', p_days,
    'hub_id', v_effective_hub_id,
    'daily_jobs_created', (
      SELECT COALESCE(jsonb_agg(row_to_json(d)), '[]'::jsonb)
      FROM (
        SELECT DATE(created_at) as date, COUNT(*) as count
        FROM public.jobs
        WHERE created_at >= v_start_date
          AND (v_effective_hub_id IS NULL OR hub_id = v_effective_hub_id)
        GROUP BY DATE(created_at)
        ORDER BY date
      ) d
    ),
    'daily_jobs_completed', (
      SELECT COALESCE(jsonb_agg(row_to_json(d)), '[]'::jsonb)
      FROM (
        SELECT DATE(completed_at) as date, COUNT(*) as count
        FROM public.jobs
        WHERE completed_at >= v_start_date
          AND (v_effective_hub_id IS NULL OR hub_id = v_effective_hub_id)
        GROUP BY DATE(completed_at)
        ORDER BY date
      ) d
    ),
    'totals', jsonb_build_object(
      'jobs_created', (SELECT COUNT(*) FROM public.jobs WHERE created_at >= v_start_date AND (v_effective_hub_id IS NULL OR hub_id = v_effective_hub_id)),
      'jobs_completed', (SELECT COUNT(*) FROM public.jobs WHERE completed_at >= v_start_date AND (v_effective_hub_id IS NULL OR hub_id = v_effective_hub_id)),
      'quotes', (SELECT COUNT(*) FROM public.quotes q JOIN public.jobs j ON j.id = q.job_id WHERE q.created_at >= v_start_date AND (v_effective_hub_id IS NULL OR j.hub_id = v_effective_hub_id)),
      'accepted', (SELECT COUNT(*) FROM public.quotes q JOIN public.jobs j ON j.id = q.job_id WHERE q.status = 'accepted' AND q.created_at >= v_start_date AND (v_effective_hub_id IS NULL OR j.hub_id = v_effective_hub_id)),
      'disputes', (SELECT COUNT(*) FROM public.disputes d JOIN public.jobs j ON j.id = d.job_id WHERE d.created_at >= v_start_date AND (v_effective_hub_id IS NULL OR j.hub_id = v_effective_hub_id)),
      'refunds', (SELECT COUNT(*) FROM public.payments p JOIN public.jobs j ON j.id = p.job_id WHERE p.refunded_at >= v_start_date AND (v_effective_hub_id IS NULL OR j.hub_id = v_effective_hub_id)),
      'support_tickets', (SELECT COUNT(*) FROM public.support_requests sr LEFT JOIN public.jobs j ON j.id = sr.job_id WHERE sr.created_at >= v_start_date AND (v_effective_hub_id IS NULL OR j.hub_id = v_effective_hub_id OR sr.job_id IS NULL))
    )
  ) INTO v_result;

  RETURN v_result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_metrics(uuid, int) TO authenticated;

-- C.12) admin_get_scope - returns current admin's scope info
CREATE OR REPLACE FUNCTION public.admin_get_scope()
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_is_super boolean;
  v_hub_id uuid;
  v_hub_name text;
BEGIN
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('error', 'Admin access required');
  END IF;

  SELECT au.is_super, au.hub_id, h.name
  INTO v_is_super, v_hub_id, v_hub_name
  FROM public.admin_users au
  LEFT JOIN public.service_hubs h ON h.id = au.hub_id
  WHERE au.user_id = auth.uid();

  RETURN jsonb_build_object(
    'is_super', v_is_super,
    'hub_id', v_hub_id,
    'hub_name', v_hub_name
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_scope() TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260201000001_admin_hub_scoping.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260201000002_admin_messaging_rpcs.sql
-- ===================================================================\n
-- Admin Messaging RPCs
-- Allows admins to send messages and view conversation history with users

-- Note: Uses existing is_admin(uuid) function from prior migrations

-- Drop existing functions if they exist (handles signature changes)
DROP FUNCTION IF EXISTS admin_send_message(uuid, text, uuid, uuid, uuid, text, text);
DROP FUNCTION IF EXISTS admin_list_user_messages(uuid, integer);
DROP FUNCTION IF EXISTS admin_list_job_messages(uuid, integer);
DROP FUNCTION IF EXISTS admin_get_user_jobs(uuid, integer);

-- RPC: Admin sends a message to a user
-- Uses SECURITY DEFINER to bypass RLS
CREATE OR REPLACE FUNCTION admin_send_message(
  p_recipient_id uuid,
  p_body text,
  p_related_job_id uuid DEFAULT NULL,
  p_support_request_id uuid DEFAULT NULL,
  p_dispute_id uuid DEFAULT NULL,
  p_attachment_url text DEFAULT NULL,
  p_attachment_type text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id uuid := auth.uid();
  v_job_id uuid;
  v_message_id uuid;
BEGIN
  -- Verify caller is admin
  IF NOT is_admin(v_admin_id) THEN
    RAISE EXCEPTION 'Unauthorized: admin access required';
  END IF;
  
  -- Determine job_id context
  v_job_id := p_related_job_id;
  
  -- If no job specified, try to find most recent job for this user
  IF v_job_id IS NULL THEN
    SELECT id INTO v_job_id
    FROM jobs
    WHERE (customer_id = p_recipient_id OR accepted_mechanic_id = p_recipient_id)
      AND deleted_at IS NULL
    ORDER BY created_at DESC
    LIMIT 1;
  END IF;
  
  -- If still no job, create a system context job or use a placeholder
  -- For now, job_id can be null for direct admin messages
  
  -- Insert the message
  INSERT INTO messages (
    job_id,
    sender_id,
    recipient_id,
    body
  ) VALUES (
    v_job_id,
    v_admin_id,
    p_recipient_id,
    p_body
  )
  RETURNING id INTO v_message_id;
  
  RETURN jsonb_build_object(
    'success', true,
    'message_id', v_message_id,
    'job_id', v_job_id
  );
EXCEPTION
  WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$$;

-- RPC: Admin lists messages with a specific user
-- Returns conversation history between admin and user
CREATE OR REPLACE FUNCTION admin_list_user_messages(
  p_user_id uuid,
  p_limit integer DEFAULT 100
)
RETURNS TABLE (
  id uuid,
  sender_admin_id uuid,
  sender_name text,
  sender_type text,
  body text,
  related_job_id uuid,
  related_job_title text,
  related_support_request_id uuid,
  related_dispute_id uuid,
  attachment_url text,
  attachment_type text,
  read_at timestamptz,
  created_at timestamptz,
  thread_id uuid
)
LANGUAGE plpgsql SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id uuid := auth.uid();
BEGIN
  -- Verify caller is admin
  IF NOT is_admin(v_admin_id) THEN
    RAISE EXCEPTION 'Unauthorized: admin access required';
  END IF;
  
  RETURN QUERY
  SELECT
    m.id,
    CASE 
      WHEN is_admin(m.sender_id) THEN m.sender_id 
      ELSE NULL::uuid 
    END as sender_admin_id,
    COALESCE(p.full_name, p.email, 'Unknown') as sender_name,
    CASE 
      WHEN is_admin(m.sender_id) THEN 'admin'::text 
      ELSE 'user'::text 
    END as sender_type,
    m.body,
    m.job_id as related_job_id,
    j.title as related_job_title,
    NULL::uuid as related_support_request_id,
    NULL::uuid as related_dispute_id,
    NULL::text as attachment_url,
    NULL::text as attachment_type,
    m.read_at,
    m.created_at,
    NULL::uuid as thread_id
  FROM messages m
  JOIN profiles p ON p.id = m.sender_id
  LEFT JOIN jobs j ON j.id = m.job_id
  WHERE (
    (m.sender_id = p_user_id AND is_admin(m.recipient_id))
    OR
    (m.recipient_id = p_user_id AND is_admin(m.sender_id))
  )
  AND m.deleted_at IS NULL
  ORDER BY m.created_at DESC
  LIMIT p_limit;
END;
$$;

-- RPC: Admin lists messages for a specific job
CREATE OR REPLACE FUNCTION admin_list_job_messages(
  p_job_id uuid,
  p_limit integer DEFAULT 100
)
RETURNS TABLE (
  id uuid,
  sender_id uuid,
  sender_name text,
  sender_role text,
  recipient_id uuid,
  recipient_name text,
  body text,
  read_at timestamptz,
  created_at timestamptz
)
LANGUAGE plpgsql SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id uuid := auth.uid();
BEGIN
  -- Verify caller is admin
  IF NOT is_admin(v_admin_id) THEN
    RAISE EXCEPTION 'Unauthorized: admin access required';
  END IF;
  
  RETURN QUERY
  SELECT
    m.id,
    m.sender_id,
    COALESCE(ps.full_name, ps.email, 'Unknown') as sender_name,
    ps.role::text as sender_role,
    m.recipient_id,
    COALESCE(pr.full_name, pr.email, 'Unknown') as recipient_name,
    m.body,
    m.read_at,
    m.created_at
  FROM messages m
  JOIN profiles ps ON ps.id = m.sender_id
  JOIN profiles pr ON pr.id = m.recipient_id
  WHERE m.job_id = p_job_id
    AND m.deleted_at IS NULL
  ORDER BY m.created_at ASC
  LIMIT p_limit;
END;
$$;

-- RPC: Get user's jobs for job context selection
CREATE OR REPLACE FUNCTION admin_get_user_jobs(
  p_user_id uuid,
  p_limit integer DEFAULT 20
)
RETURNS TABLE (
  id uuid,
  title text,
  status text,
  created_at timestamptz
)
LANGUAGE plpgsql SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id uuid := auth.uid();
BEGIN
  IF NOT is_admin(v_admin_id) THEN
    RAISE EXCEPTION 'Unauthorized: admin access required';
  END IF;
  
  RETURN QUERY
  SELECT
    j.id,
    j.title,
    j.status::text,
    j.created_at
  FROM jobs j
  WHERE (j.customer_id = p_user_id OR j.accepted_mechanic_id = p_user_id)
    AND j.deleted_at IS NULL
  ORDER BY j.created_at DESC
  LIMIT p_limit;
END;
$$;

-- Grant execute permissions
GRANT EXECUTE ON FUNCTION is_admin(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION admin_send_message(uuid, text, uuid, uuid, uuid, text, text) TO authenticated;
GRANT EXECUTE ON FUNCTION admin_list_user_messages(uuid, integer) TO authenticated;
GRANT EXECUTE ON FUNCTION admin_list_job_messages(uuid, integer) TO authenticated;
GRANT EXECUTE ON FUNCTION admin_get_user_jobs(uuid, integer) TO authenticated;
\n-- ===================================================================
-- END: 20260201000002_admin_messaging_rpcs.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260202000001_fix_commission_calculation.sql
-- ===================================================================\n
-- =====================================================
-- MIGRATION: Fix Commission Calculation
-- =====================================================
-- Problem: Commission was being calculated from subtotal (labor + parts)
--          instead of labor only. This caused incorrect commission amounts.
-- 
-- Fix: Commission = 12% of LABOR ONLY (capped at $50)
-- 
-- Example:
--   Labor: $130, Parts: $300, Gross: $430
--   WRONG: Commission = 12% of $430 = $51.60 (capped to $50)
--   RIGHT: Commission = 12% of $130 = $15.60
-- =====================================================

BEGIN;

-- =====================================================
-- HELPER: Calculate labor total from line items
-- =====================================================
CREATE OR REPLACE FUNCTION get_labor_total_cents(p_contract_id uuid)
RETURNS int
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v_labor_cents int;
BEGIN
  SELECT COALESCE(SUM(total_cents), 0)
  INTO v_labor_cents
  FROM public.invoice_line_items
  WHERE contract_id = p_contract_id
    AND approval_status = 'approved'
    AND item_type IN ('base_labor', 'additional_labor');
  
  RETURN v_labor_cents;
END;
$$;

-- =====================================================
-- FIX: Update calculate_mechanic_commission to be clearer
-- (The function itself is correct - 12% capped at $50)
-- The bug was in HOW it was called (with subtotal instead of labor)
-- =====================================================
CREATE OR REPLACE FUNCTION calculate_mechanic_commission(price_cents int)
RETURNS int
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
  -- 12% of LABOR ONLY, capped at $50 (5000 cents)
  -- NEVER pass subtotal or gross to this function!
  RETURN LEAST(ROUND(price_cents * 0.12)::int, 5000);
END;
$$;

COMMENT ON FUNCTION calculate_mechanic_commission(int) IS 
  'Calculate 12% commission on LABOR ONLY (not parts/gross). Capped at $50.';

-- =====================================================
-- FIX: Update recalculate_contract_totals to use labor only
-- =====================================================
CREATE OR REPLACE FUNCTION recalculate_contract_totals(p_contract_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_labor_cents int;
  v_subtotal_cents int;
  v_platform_fee_cents int;
  v_commission_cents int;
  v_total_customer_cents int;
  v_mechanic_payout_cents int;
BEGIN
  -- Get labor total (base_labor + additional_labor only)
  SELECT COALESCE(SUM(total_cents), 0)
  INTO v_labor_cents
  FROM public.invoice_line_items
  WHERE contract_id = p_contract_id
    AND approval_status = 'approved'
    AND item_type IN ('base_labor', 'additional_labor');

  -- Get subtotal (all approved items except platform_fee)
  SELECT COALESCE(SUM(total_cents), 0)
  INTO v_subtotal_cents
  FROM public.invoice_line_items
  WHERE contract_id = p_contract_id
    AND approval_status = 'approved'
    AND item_type != 'platform_fee';

  -- Get platform fee
  SELECT platform_fee_cents INTO v_platform_fee_cents
  FROM public.job_contracts
  WHERE id = p_contract_id;

  -- Calculate commission from LABOR ONLY
  v_commission_cents := calculate_mechanic_commission(v_labor_cents);
  
  -- Calculate totals
  v_total_customer_cents := v_subtotal_cents + v_platform_fee_cents;
  v_mechanic_payout_cents := v_subtotal_cents - v_commission_cents;

  -- Update contract
  UPDATE public.job_contracts
  SET 
    subtotal_cents = v_subtotal_cents,
    total_customer_cents = v_total_customer_cents,
    mechanic_commission_cents = v_commission_cents,
    mechanic_payout_cents = v_mechanic_payout_cents,
    updated_at = now()
  WHERE id = p_contract_id;
END;
$$;

-- =====================================================
-- FIX: Update approve_line_item to use new recalculation
-- =====================================================
CREATE OR REPLACE FUNCTION approve_line_item(
  p_line_item_id uuid,
  p_customer_id uuid,
  p_approved boolean,
  p_rejection_reason text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_item RECORD;
BEGIN
  -- Get line item with contract info
  SELECT 
    li.*,
    c.customer_id,
    c.job_id,
    c.platform_fee_cents
  INTO v_item
  FROM public.invoice_line_items li
  JOIN public.job_contracts c ON c.id = li.contract_id
  WHERE li.id = p_line_item_id
  FOR UPDATE OF li;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Line item not found');
  END IF;
  
  IF v_item.customer_id != p_customer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;
  
  IF v_item.approval_status != 'pending' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Item already processed');
  END IF;
  
  IF p_approved THEN
    UPDATE public.invoice_line_items
    SET 
      approval_status = 'approved',
      approved_at = now(),
      approved_by = p_customer_id,
      updated_at = now()
    WHERE id = p_line_item_id;
    
    -- Recalculate contract totals (now uses labor only for commission)
    PERFORM recalculate_contract_totals(v_item.contract_id);
    
    -- Log event
    PERFORM log_job_event(
      v_item.job_id, v_item.contract_id, 'line_item_approved',
      p_customer_id, 'customer',
      'Additional item approved',
      v_item.description,
      jsonb_build_object('line_item_id', p_line_item_id, 'amount_cents', v_item.total_cents),
      v_item.total_cents
    );
  ELSE
    UPDATE public.invoice_line_items
    SET 
      approval_status = 'rejected',
      rejected_at = now(),
      rejected_by = p_customer_id,
      rejection_reason = p_rejection_reason,
      updated_at = now()
    WHERE id = p_line_item_id;
    
    -- Log event
    PERFORM log_job_event(
      v_item.job_id, v_item.contract_id, 'line_item_rejected',
      p_customer_id, 'customer',
      'Additional item rejected',
      v_item.description || COALESCE(' - Reason: ' || p_rejection_reason, ''),
      jsonb_build_object('line_item_id', p_line_item_id, 'reason', p_rejection_reason)
    );
  END IF;
  
  RETURN jsonb_build_object('success', true, 'approved', p_approved);
END;
$$;

-- =====================================================
-- RECOMPUTE: Fix all existing contracts with wrong commission
-- =====================================================
CREATE OR REPLACE FUNCTION recompute_all_commissions()
RETURNS TABLE(
  contract_id uuid,
  old_commission int,
  new_commission int,
  labor_cents int,
  fixed boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_contract RECORD;
  v_labor_cents int;
  v_correct_commission int;
BEGIN
  FOR v_contract IN 
    SELECT c.id, c.mechanic_commission_cents, c.subtotal_cents
    FROM public.job_contracts c
    WHERE c.status IN ('active', 'completed')
  LOOP
    -- Get labor total
    SELECT COALESCE(SUM(total_cents), 0)
    INTO v_labor_cents
    FROM public.invoice_line_items
    WHERE invoice_line_items.contract_id = v_contract.id
      AND approval_status = 'approved'
      AND item_type IN ('base_labor', 'additional_labor');
    
    -- Calculate correct commission
    v_correct_commission := calculate_mechanic_commission(v_labor_cents);
    
    -- Check if needs fixing
    IF v_contract.mechanic_commission_cents != v_correct_commission THEN
      -- Fix the contract
      PERFORM recalculate_contract_totals(v_contract.id);
      
      -- Fix the payout if exists
      UPDATE public.payouts
      SET 
        commission_cents = v_correct_commission,
        net_amount_cents = gross_amount_cents - v_correct_commission,
        updated_at = now()
      WHERE payouts.contract_id = v_contract.id;
      
      contract_id := v_contract.id;
      old_commission := v_contract.mechanic_commission_cents;
      new_commission := v_correct_commission;
      labor_cents := v_labor_cents;
      fixed := true;
      RETURN NEXT;
    END IF;
  END LOOP;
END;
$$;

-- Run the recomputation
DO $$
DECLARE
  v_fixed_count int;
BEGIN
  SELECT COUNT(*) INTO v_fixed_count
  FROM recompute_all_commissions();
  
  RAISE NOTICE 'Fixed % contracts with incorrect commission', v_fixed_count;
END;
$$;

-- =====================================================
-- VALIDATION: Check that all commissions are now correct
-- =====================================================
CREATE OR REPLACE FUNCTION validate_commissions()
RETURNS TABLE(
  contract_id uuid,
  labor_cents int,
  stored_commission int,
  expected_commission int,
  is_valid boolean
)
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v_contract RECORD;
  v_labor_cents int;
  v_expected int;
BEGIN
  FOR v_contract IN 
    SELECT c.id, c.mechanic_commission_cents
    FROM public.job_contracts c
    WHERE c.status IN ('active', 'completed')
  LOOP
    SELECT COALESCE(SUM(total_cents), 0)
    INTO v_labor_cents
    FROM public.invoice_line_items
    WHERE invoice_line_items.contract_id = v_contract.id
      AND approval_status = 'approved'
      AND item_type IN ('base_labor', 'additional_labor');
    
    v_expected := calculate_mechanic_commission(v_labor_cents);
    
    contract_id := v_contract.id;
    labor_cents := v_labor_cents;
    stored_commission := v_contract.mechanic_commission_cents;
    expected_commission := v_expected;
    is_valid := (v_contract.mechanic_commission_cents = v_expected);
    RETURN NEXT;
  END LOOP;
END;
$$;

COMMIT;


\n-- ===================================================================
-- END: 20260202000001_fix_commission_calculation.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260202000002_admin_hub_update_permission.sql
-- ===================================================================\n
-- Migration: 20260202000002_admin_hub_update_permission.sql
-- Description: Grant UPDATE permission on service_hubs for admin users
-- Dependencies: 0081_service_hubs.sql

-- Grant UPDATE permission to authenticated users (RLS will restrict to admins)
GRANT UPDATE ON public.service_hubs TO authenticated;

-- Enable RLS if not already enabled
ALTER TABLE public.service_hubs ENABLE ROW LEVEL SECURITY;

-- Create policy for admin updates (uses existing is_admin(uuid) function)
DROP POLICY IF EXISTS "Admins can update service_hubs" ON public.service_hubs;
CREATE POLICY "Admins can update service_hubs"
  ON public.service_hubs
  FOR UPDATE
  TO authenticated
  USING (public.is_admin(auth.uid()))
  WITH CHECK (public.is_admin(auth.uid()));\n-- ===================================================================
-- END: 20260202000002_admin_hub_update_permission.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260203000001_mandatory_review_system.sql
-- ===================================================================\n
-- Mandatory Review System Migration
-- Adds helper functions and columns for enforcing mandatory post-job reviews

BEGIN;

-- Add reviewed_at columns to jobs table if they don't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'jobs' 
    AND column_name = 'customer_reviewed_at'
  ) THEN
    ALTER TABLE public.jobs ADD COLUMN customer_reviewed_at timestamptz;
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'jobs' 
    AND column_name = 'mechanic_reviewed_at'
  ) THEN
    ALTER TABLE public.jobs ADD COLUMN mechanic_reviewed_at timestamptz;
  END IF;
END $$;

-- Create function to check if user has submitted review for a job
CREATE OR REPLACE FUNCTION public.has_submitted_review(p_job_id uuid, p_reviewer_id uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.reviews
    WHERE job_id = p_job_id
    AND reviewer_id = p_reviewer_id
    AND deleted_at IS NULL
  );
END;
$$;

-- Create function to get pending review job for a user
-- Returns the oldest completed job that the user hasn't reviewed yet
CREATE OR REPLACE FUNCTION public.get_pending_review_job(p_user_id uuid)
RETURNS TABLE (
  job_id uuid,
  job_title text,
  other_party_id uuid,
  other_party_name text,
  reviewer_role text,
  completed_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_pending_job RECORD;
BEGIN
  -- Check for jobs where user is customer and hasn't reviewed
  SELECT 
    j.id as job_id,
    j.title as job_title,
    jc.mechanic_id as other_party_id,
    COALESCE(p.full_name, 'Mechanic') as other_party_name,
    'customer'::text as reviewer_role,
    COALESCE(jp.finalized_at, jp.customer_completed_at, j.updated_at) as completed_at
  INTO v_pending_job
  FROM public.jobs j
  INNER JOIN public.job_contracts jc ON jc.job_id = j.id
  LEFT JOIN public.job_progress jp ON jp.job_id = j.id
  LEFT JOIN public.profiles p ON p.id = jc.mechanic_id
  WHERE j.customer_id = p_user_id
  AND j.status = 'completed'
  AND j.deleted_at IS NULL
  AND NOT EXISTS (
    SELECT 1 FROM public.reviews r
    WHERE r.job_id = j.id
    AND r.reviewer_id = p_user_id
    AND r.deleted_at IS NULL
  )
  ORDER BY COALESCE(jp.finalized_at, jp.customer_completed_at, j.updated_at) ASC
  LIMIT 1;
  
  IF v_pending_job.job_id IS NOT NULL THEN
    RETURN QUERY SELECT 
      v_pending_job.job_id,
      v_pending_job.job_title,
      v_pending_job.other_party_id,
      v_pending_job.other_party_name,
      v_pending_job.reviewer_role,
      v_pending_job.completed_at;
    RETURN;
  END IF;
  
  -- Check for jobs where user is mechanic and hasn't reviewed
  SELECT 
    j.id as job_id,
    j.title as job_title,
    j.customer_id as other_party_id,
    COALESCE(p.full_name, 'Customer') as other_party_name,
    'mechanic'::text as reviewer_role,
    COALESCE(jp.finalized_at, jp.mechanic_completed_at, j.updated_at) as completed_at
  INTO v_pending_job
  FROM public.jobs j
  INNER JOIN public.job_contracts jc ON jc.job_id = j.id
  LEFT JOIN public.job_progress jp ON jp.job_id = j.id
  LEFT JOIN public.profiles p ON p.id = j.customer_id
  WHERE jc.mechanic_id = p_user_id
  AND j.status = 'completed'
  AND j.deleted_at IS NULL
  AND NOT EXISTS (
    SELECT 1 FROM public.reviews r
    WHERE r.job_id = j.id
    AND r.reviewer_id = p_user_id
    AND r.deleted_at IS NULL
  )
  ORDER BY COALESCE(jp.finalized_at, jp.mechanic_completed_at, j.updated_at) ASC
  LIMIT 1;
  
  IF v_pending_job.job_id IS NOT NULL THEN
    RETURN QUERY SELECT 
      v_pending_job.job_id,
      v_pending_job.job_title,
      v_pending_job.other_party_id,
      v_pending_job.other_party_name,
      v_pending_job.reviewer_role,
      v_pending_job.completed_at;
    RETURN;
  END IF;
  
  -- No pending reviews
  RETURN;
END;
$$;

-- Create trigger to update reviewed_at columns when review is inserted
CREATE OR REPLACE FUNCTION public.update_job_reviewed_at()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_job RECORD;
BEGIN
  -- Get job info
  SELECT customer_id INTO v_job
  FROM public.jobs
  WHERE id = NEW.job_id;
  
  -- Update the appropriate column based on reviewer role
  IF NEW.reviewer_id = v_job.customer_id THEN
    UPDATE public.jobs
    SET customer_reviewed_at = NEW.created_at
    WHERE id = NEW.job_id;
  ELSE
    UPDATE public.jobs
    SET mechanic_reviewed_at = NEW.created_at
    WHERE id = NEW.job_id;
  END IF;
  
  RETURN NEW;
END;
$$;

-- Create trigger if it doesn't exist
DROP TRIGGER IF EXISTS trigger_update_job_reviewed_at ON public.reviews;
CREATE TRIGGER trigger_update_job_reviewed_at
  AFTER INSERT ON public.reviews
  FOR EACH ROW
  EXECUTE FUNCTION public.update_job_reviewed_at();

-- Grant execute permissions
GRANT EXECUTE ON FUNCTION public.has_submitted_review(uuid, uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_pending_review_job(uuid) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260203000001_mandatory_review_system.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260203000002_hub_recommendations_rpc.sql
-- ===================================================================\n
-- Create RPC function for hub recommendations
-- Aggregates waitlist data by ZIP prefix to suggest new hub locations

CREATE OR REPLACE FUNCTION public.get_hub_recommendations()
RETURNS TABLE (
  zip_prefix TEXT,
  city TEXT,
  state TEXT,
  country TEXT,
  lat DOUBLE PRECISION,
  lng DOUBLE PRECISION,
  customer_count BIGINT,
  mechanic_count BIGINT,
  avg_distance DOUBLE PRECISION,
  demand_score DOUBLE PRECISION,
  supply_score DOUBLE PRECISION,
  readiness_score DOUBLE PRECISION
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    LEFT(w.zip, 3) AS zip_prefix,
    MODE() WITHIN GROUP (ORDER BY w.city) AS city,
    MODE() WITHIN GROUP (ORDER BY w.state) AS state,
    MODE() WITHIN GROUP (ORDER BY w.country) AS country,
    AVG(w.lat)::DOUBLE PRECISION AS lat,
    AVG(w.lng)::DOUBLE PRECISION AS lng,
    COUNT(*) FILTER (WHERE w.user_type = 'customer') AS customer_count,
    COUNT(*) FILTER (WHERE w.user_type = 'mechanic') AS mechanic_count,
    AVG(w.distance_miles)::DOUBLE PRECISION AS avg_distance,
    -- Demand score: more customers = higher demand
    LEAST(100, COUNT(*) FILTER (WHERE w.user_type = 'customer') * 10)::DOUBLE PRECISION AS demand_score,
    -- Supply score: more mechanics = higher supply readiness
    LEAST(100, COUNT(*) FILTER (WHERE w.user_type = 'mechanic') * 20)::DOUBLE PRECISION AS supply_score,
    -- Readiness: combination of demand and supply
    LEAST(100, (
      COUNT(*) FILTER (WHERE w.user_type = 'customer') * 5 +
      COUNT(*) FILTER (WHERE w.user_type = 'mechanic') * 15
    ))::DOUBLE PRECISION AS readiness_score
  FROM public.waitlist w
  WHERE w.zip IS NOT NULL
    AND w.lat IS NOT NULL
    AND w.lng IS NOT NULL
    AND w.nearest_hub_id IS NULL
  GROUP BY LEFT(w.zip, 3)
  HAVING COUNT(*) >= 3
  ORDER BY readiness_score DESC, demand_score DESC
  LIMIT 20;
END;
$$;

-- Grant execute permission to authenticated users (admins will use this)
GRANT EXECUTE ON FUNCTION public.get_hub_recommendations() TO authenticated;\n-- ===================================================================
-- END: 20260203000002_hub_recommendations_rpc.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260203000003_fix_hub_recommendations_rpc.sql
-- ===================================================================\n
-- Fix get_hub_recommendations RPC to not use columns that don't exist in waitlist table

CREATE OR REPLACE FUNCTION public.get_hub_recommendations()
RETURNS TABLE (
  zip_prefix TEXT,
  city TEXT,
  state TEXT,
  country TEXT,
  lat DOUBLE PRECISION,
  lng DOUBLE PRECISION,
  customer_count BIGINT,
  mechanic_count BIGINT,
  avg_distance DOUBLE PRECISION,
  demand_score DOUBLE PRECISION,
  supply_score DOUBLE PRECISION,
  readiness_score DOUBLE PRECISION
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    LEFT(w.zip, 3) AS zip_prefix,
    CONCAT('ZIP ', LEFT(w.zip, 3), 'xxx')::TEXT AS city,
    ''::TEXT AS state,
    'US'::TEXT AS country,
    AVG(w.lat)::DOUBLE PRECISION AS lat,
    AVG(w.lng)::DOUBLE PRECISION AS lng,
    COUNT(*) FILTER (WHERE w.user_type = 'customer') AS customer_count,
    COUNT(*) FILTER (WHERE w.user_type = 'mechanic') AS mechanic_count,
    AVG(w.distance_miles)::DOUBLE PRECISION AS avg_distance,
    LEAST(100, COUNT(*) FILTER (WHERE w.user_type = 'customer') * 10)::DOUBLE PRECISION AS demand_score,
    LEAST(100, COUNT(*) FILTER (WHERE w.user_type = 'mechanic') * 20)::DOUBLE PRECISION AS supply_score,
    LEAST(100, (
      COUNT(*) FILTER (WHERE w.user_type = 'customer') * 6 +
      COUNT(*) FILTER (WHERE w.user_type = 'mechanic') * 8
    ))::DOUBLE PRECISION AS readiness_score
  FROM public.waitlist w
  WHERE w.zip IS NOT NULL
    AND w.lat IS NOT NULL
    AND w.lng IS NOT NULL
    AND w.nearest_hub_id IS NULL
    AND w.converted_at IS NULL
    AND w.invited_at IS NULL
  GROUP BY LEFT(w.zip, 3)
  HAVING COUNT(*) >= 5
  ORDER BY readiness_score DESC, demand_score DESC
  LIMIT 20;
END;
$$;\n-- ===================================================================
-- END: 20260203000003_fix_hub_recommendations_rpc.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260203000004_service_hubs_insert_policy.sql
-- ===================================================================\n
-- Migration: 20260203000004_service_hubs_insert_policy.sql
-- Description: Add INSERT policy for service_hubs (admin only) and SELECT policy for all authenticated users
-- Dependencies: 20260202000002_admin_hub_update_permission.sql

-- Grant INSERT permission to authenticated users (RLS will restrict to admins)
GRANT INSERT ON public.service_hubs TO authenticated;

-- Create SELECT policy for all authenticated users
DROP POLICY IF EXISTS "Authenticated users can view service_hubs" ON public.service_hubs;
CREATE POLICY "Authenticated users can view service_hubs"
  ON public.service_hubs
  FOR SELECT
  TO authenticated
  USING (true);

-- Create INSERT policy for admin users only
DROP POLICY IF EXISTS "Admins can insert service_hubs" ON public.service_hubs;
CREATE POLICY "Admins can insert service_hubs"
  ON public.service_hubs
  FOR INSERT
  TO authenticated
  WITH CHECK (public.is_admin(auth.uid()));

-- Create DELETE policy for admin users only
DROP POLICY IF EXISTS "Admins can delete service_hubs" ON public.service_hubs;
CREATE POLICY "Admins can delete service_hubs"
  ON public.service_hubs
  FOR DELETE
  TO authenticated
  USING (public.is_admin(auth.uid()));
\n-- ===================================================================
-- END: 20260203000004_service_hubs_insert_policy.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260204000001_user_location_and_hub_assignment.sql
-- ===================================================================\n
-- User location + hub assignment + waitlist upsert
--
-- Problem this addresses:
-- - Users can sign up but never get linked to a hub.
-- - Out-of-range users never get placed on the waitlist.
--
-- This RPC is intended to be called immediately after role selection / onboarding.

begin;

-- Create / replace a single RPC that:
-- 1) stores the user's home location
-- 2) assigns nearest hub if within max radius
-- 3) otherwise upserts a waitlist entry
create or replace function public.set_user_location_and_assign_hub(
  p_lat double precision,
  p_lng double precision,
  p_zip text default null,
  p_city text default null,
  p_state text default null,
  p_user_type text default null,
  p_phone text default null
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid;
  v_email text;
  v_hub record;
  v_in_range boolean;
  v_waitlist_id uuid;
  v_role text;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    return jsonb_build_object('success', false, 'code', 'NOT_AUTHENTICATED', 'message', 'Not authenticated');
  end if;

  select email, role::text into v_email, v_role
  from public.profiles
  where id = v_user_id;

  if v_email is null then
    return jsonb_build_object('success', false, 'code', 'PROFILE_MISSING', 'message', 'Profile not found');
  end if;

  -- Persist location on profile
  update public.profiles
  set
    home_lat = p_lat,
    home_lng = p_lng,
    city = coalesce(p_city, city),
    state = coalesce(p_state, state),
    phone = coalesce(p_phone, phone),
    updated_at = now()
  where id = v_user_id;

  -- Find nearest hub
  select * into v_hub
  from public.get_nearest_hub(p_lat, p_lng);

  if v_hub is null then
    -- No hubs at all
    update public.profiles set hub_id = null, updated_at = now() where id = v_user_id;

    insert into public.waitlist(email, phone, zip, city, state, lat, lng, user_type, nearest_hub_id, distance_miles, status)
    values (v_email, p_phone, coalesce(p_zip, ''), p_city, p_state, p_lat, p_lng, coalesce(p_user_type, v_role, 'customer'), null, null, 'waiting')
    on conflict (email, zip)
    do update set
      phone = excluded.phone,
      city = excluded.city,
      state = excluded.state,
      lat = excluded.lat,
      lng = excluded.lng,
      user_type = excluded.user_type,
      nearest_hub_id = excluded.nearest_hub_id,
      distance_miles = excluded.distance_miles,
      status = excluded.status,
      updated_at = now()
    returning id into v_waitlist_id;

    return jsonb_build_object(
      'success', false,
      'code', 'NO_HUBS_CONFIGURED',
      'message', 'No service hubs configured',
      'waitlist_id', v_waitlist_id
    );
  end if;

  v_in_range := (v_hub.distance_miles is not null and v_hub.max_radius_miles is not null and v_hub.distance_miles <= v_hub.max_radius_miles);

  if v_in_range then
    update public.profiles
    set hub_id = v_hub.id, updated_at = now()
    where id = v_user_id;

    -- If they previously had a waitlist entry at this zip, mark it accepted/converted
    if p_zip is not null then
      update public.waitlist
      set status = 'accepted', accepted_at = now(), nearest_hub_id = v_hub.id, distance_miles = v_hub.distance_miles, updated_at = now()
      where email = v_email and zip = p_zip;
    end if;

    return jsonb_build_object(
      'success', true,
      'code', 'IN_RANGE',
      'message', 'Location saved and hub assigned',
      'hub_id', v_hub.id,
      'hub_name', v_hub.name,
      'distance_miles', v_hub.distance_miles,
      'max_radius_miles', v_hub.max_radius_miles
    );
  end if;

  -- Out of range -> null hub + upsert waitlist
  update public.profiles
  set hub_id = null, updated_at = now()
  where id = v_user_id;

  insert into public.waitlist(email, phone, zip, city, state, lat, lng, user_type, nearest_hub_id, distance_miles, status)
  values (
    v_email,
    p_phone,
    coalesce(p_zip, ''),
    p_city,
    p_state,
    p_lat,
    p_lng,
    coalesce(p_user_type, v_role, 'customer'),
    v_hub.id,
    v_hub.distance_miles,
    'waiting'
  )
  on conflict (email, zip)
  do update set
    phone = excluded.phone,
    city = excluded.city,
    state = excluded.state,
    lat = excluded.lat,
    lng = excluded.lng,
    user_type = excluded.user_type,
    nearest_hub_id = excluded.nearest_hub_id,
    distance_miles = excluded.distance_miles,
    status = excluded.status,
    updated_at = now()
  returning id into v_waitlist_id;

  return jsonb_build_object(
    'success', false,
    'code', 'OUT_OF_RANGE',
    'message', 'Outside the service area. Added to waitlist.',
    'waitlist_id', v_waitlist_id,
    'nearest_hub_id', v_hub.id,
    'nearest_hub_name', v_hub.name,
    'distance_miles', v_hub.distance_miles,
    'max_radius_miles', v_hub.max_radius_miles
  );
end;
$$;

grant execute on function public.set_user_location_and_assign_hub(double precision, double precision, text, text, text, text, text) to authenticated;

commit;
\n-- ===================================================================
-- END: 20260204000001_user_location_and_hub_assignment.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260204000002_set_my_service_area.sql
-- ===================================================================\n
-- =====================================================
-- RPC: set_my_service_area
-- =====================================================
-- Purpose
-- - Link a signed-in user to the nearest hub (profiles.hub_id)
-- - Persist the user's service location (profiles.service_*)
-- - Add/update a waitlist entry when the user is outside the *active* radius
--
-- This addresses the app-level issue where users were never linked to a hub
-- (and therefore couldn't be properly scoped) and users out of range were
-- not placed onto the waitlist.
--
-- Notes
-- - Uses public.get_nearest_hub(lat, lng) which already encapsulates ring / radius logic.
-- - We keep profiles.hub_id set to the nearest hub even when outside active radius so:
--   * admin scoping still works
--   * the app can show "nearest hub" context
--

BEGIN;

CREATE OR REPLACE FUNCTION public.set_my_service_area(
  p_zip text DEFAULT NULL,
  p_lat double precision DEFAULT NULL,
  p_lng double precision DEFAULT NULL,
  p_user_type text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_email text;
  v_phone text;
  v_role text;
  v_user_type text;
  v_hub_id uuid;
  v_hub_name text;
  v_distance_miles numeric;
  v_within_active boolean;
  v_within_max boolean;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'code', 'NOT_AUTHENTICATED');
  END IF;

  IF p_lat IS NULL OR p_lng IS NULL THEN
    RETURN jsonb_build_object('success', false, 'code', 'MISSING_COORDS');
  END IF;

  SELECT email, phone, role::text
    INTO v_email, v_phone, v_role
  FROM public.profiles
  WHERE id = v_user_id;

  -- Determine user_type
  v_user_type := COALESCE(NULLIF(p_user_type, ''), v_role);
  IF v_user_type NOT IN ('customer', 'mechanic') THEN
    -- Default to customer if role not set yet
    v_user_type := 'customer';
  END IF;

  -- Nearest hub + distance
  SELECT hub_id, hub_name, distance_miles::numeric, within_active_radius, within_max_radius
    INTO v_hub_id, v_hub_name, v_distance_miles, v_within_active, v_within_max
  FROM public.get_nearest_hub(p_lat, p_lng)
  LIMIT 1;

  -- Persist onto profile
  UPDATE public.profiles
  SET
    home_lat = p_lat,
    home_lng = p_lng,
    service_lat = p_lat::numeric,
    service_lng = p_lng::numeric,
    service_zip = COALESCE(NULLIF(p_zip, ''), service_zip),
    hub_id = v_hub_id,
    updated_at = now()
  WHERE id = v_user_id;

  -- Waitlist bookkeeping
  IF v_within_active THEN
    -- User is in the active radius  mark waitlist as converted/active if it exists
    IF v_email IS NOT NULL AND (p_zip IS NOT NULL AND p_zip <> '') THEN
      INSERT INTO public.waitlist (
        email,
        phone,
        zip,
        lat,
        lng,
        nearest_hub_id,
        distance_miles,
        user_type,
        status,
        converted_at
      )
      VALUES (
        v_email,
        v_phone,
        p_zip,
        p_lat::numeric,
        p_lng::numeric,
        v_hub_id,
        v_distance_miles,
        v_user_type,
        'active',
        now()
      )
      ON CONFLICT (email, zip)
      DO UPDATE SET
        phone = EXCLUDED.phone,
        lat = EXCLUDED.lat,
        lng = EXCLUDED.lng,
        nearest_hub_id = EXCLUDED.nearest_hub_id,
        distance_miles = EXCLUDED.distance_miles,
        user_type = EXCLUDED.user_type,
        status = 'active',
        converted_at = COALESCE(public.waitlist.converted_at, now());
    END IF;
  ELSE
    -- User is outside active radius  ensure they are on the waitlist (waiting)
    IF v_email IS NULL THEN
      RETURN jsonb_build_object(
        'success', false,
        'code', 'MISSING_EMAIL',
        'message', 'Profile email is required to join the waitlist'
      );
    END IF;

    IF p_zip IS NULL OR p_zip = '' THEN
      RETURN jsonb_build_object(
        'success', false,
        'code', 'MISSING_ZIP',
        'message', 'ZIP is required to join the waitlist'
      );
    END IF;

    INSERT INTO public.waitlist (
      email,
      phone,
      zip,
      lat,
      lng,
      nearest_hub_id,
      distance_miles,
      user_type,
      status
    )
    VALUES (
      v_email,
      v_phone,
      p_zip,
      p_lat::numeric,
      p_lng::numeric,
      v_hub_id,
      v_distance_miles,
      v_user_type,
      'waiting'
    )
    ON CONFLICT (email, zip)
    DO UPDATE SET
      phone = EXCLUDED.phone,
      lat = EXCLUDED.lat,
      lng = EXCLUDED.lng,
      nearest_hub_id = EXCLUDED.nearest_hub_id,
      distance_miles = EXCLUDED.distance_miles,
      user_type = EXCLUDED.user_type,
      status = 'waiting';
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'user_type', v_user_type,
    'hub_id', v_hub_id,
    'hub_name', v_hub_name,
    'distance_miles', v_distance_miles,
    'within_active_radius', v_within_active,
    'within_max_radius', v_within_max
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.set_my_service_area(text, double precision, double precision, text) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260204000002_set_my_service_area.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260204000003_align_payments_for_edge_functions.sql
-- ===================================================================\n
-- =====================================================
-- ALIGN: payments schema + payment_status enum
-- =====================================================
--
-- The edge function supabase/functions/create-booking-payment expects:
-- - payments.status to include 'requires_action'
-- - payments.client_secret
-- - payments.metadata (jsonb)
-- - payments.error_message
--
-- This migration brings the DB schema in sync.

BEGIN;

-- 1) Add enum value if missing (Postgres doesn't support IF NOT EXISTS reliably across versions)
DO $$
BEGIN
  -- Add any missing enum values expected by the edge payment flow
  IF NOT EXISTS (
    SELECT 1
    FROM pg_type t
    JOIN pg_enum e ON t.oid = e.enumtypid
    WHERE t.typname = 'payment_status' AND e.enumlabel = 'requires_action'
  ) THEN
    ALTER TYPE public.payment_status ADD VALUE 'requires_action';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM pg_type t
    JOIN pg_enum e ON t.oid = e.enumtypid
    WHERE t.typname = 'payment_status' AND e.enumlabel = 'authorized'
  ) THEN
    ALTER TYPE public.payment_status ADD VALUE 'authorized';
  END IF;
END
$$;

-- 2) Add columns expected by edge functions
ALTER TABLE public.payments
  ADD COLUMN IF NOT EXISTS client_secret text,
  ADD COLUMN IF NOT EXISTS metadata jsonb DEFAULT '{}'::jsonb,
  ADD COLUMN IF NOT EXISTS error_message text;


-- Backfill metadata for older rows
UPDATE public.payments SET metadata = '{}'::jsonb WHERE metadata IS NULL;

COMMIT;\n-- ===================================================================
-- END: 20260204000003_align_payments_for_edge_functions.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260204000004_contract_pending_payment_on_quote_accept.sql
-- ===================================================================\n
-- =====================================================
-- PAYMENT GATING + SCHEDULING
-- =====================================================
--
-- Goal
-- - Keep the robust scheduling/conflict-resolution logic from
--   20260130000001_no_double_booking.sql
-- - BUT create job_contracts in status = 'pending_payment' so the mechanic
--   cannot depart/start work until the customer authorizes the payment.
--
-- This dovetails with public.authorize_contract_payment(...), which flips
-- the contract to 'active' once the Stripe PaymentIntent has been authorized.

BEGIN;

-- Replace accept_quote_and_resolve_conflicts with the no-double-booking version,
-- but set contract.status = 'pending_payment'.

CREATE OR REPLACE FUNCTION public.accept_quote_and_resolve_conflicts(
  p_quote_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_quote record;
  v_job record;
  v_contract_id uuid;
  v_now timestamptz := now();
  v_conflicts jsonb := '[]'::jsonb;
  v_platform_fee_cents integer;
  v_total_cents integer;
  v_terms_ok boolean;
  v_ack_ok boolean;
BEGIN
  -- Ensure caller is the customer
  IF auth.uid() IS DISTINCT FROM p_customer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Unauthorized');
  END IF;

  -- Fetch quote (lock row)
  SELECT q.* INTO v_quote
  FROM public.quotes q
  WHERE q.id = p_quote_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote not found');
  END IF;

  -- Fetch job (lock row)
  SELECT j.* INTO v_job
  FROM public.jobs j
  WHERE j.id = v_quote.job_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job not found');
  END IF;

  IF v_job.customer_id IS DISTINCT FROM p_customer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job does not belong to customer');
  END IF;

  IF v_quote.status <> 'submitted' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote is not available');
  END IF;

  -- Terms + acknowledgement gates (kept from no-double-booking migration)
  SELECT (public.check_terms_accepted('customer'))->>'accepted' = 'true' INTO v_terms_ok;
  IF NOT coalesce(v_terms_ok, false) THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Platform terms not accepted',
      'code', 'TERMS_NOT_ACCEPTED'
    );
  END IF;

  SELECT (public.check_terms_accepted('customer'))->>'job_acknowledged' = 'true' INTO v_ack_ok;
  IF NOT coalesce(v_ack_ok, false) THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Job acknowledgement required',
      'code', 'JOB_ACK_REQUIRED'
    );
  END IF;

  -- Ensure quote has a proposed time window
  IF v_quote.proposed_start_at IS NULL OR v_quote.proposed_end_at IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Quote missing proposed schedule',
      'code', 'MISSING_SCHEDULE'
    );
  END IF;

  -- Resolve scheduling conflicts (decline overlapping active contracts)
  WITH conflicting_contracts AS (
    SELECT c.id
    FROM public.job_contracts c
    WHERE c.mechanic_id = v_quote.mechanic_id
      AND c.status IN ('active', 'in_progress')
      AND tstzrange(c.scheduled_start_at, c.scheduled_end_at, '[)') &&
          tstzrange(v_quote.proposed_start_at, v_quote.proposed_end_at, '[)')
  )
  UPDATE public.job_contracts c
  SET status = 'cancelled',
      cancelled_at = v_now,
      cancellation_reason = 'schedule_conflict'
  FROM conflicting_contracts cc
  WHERE c.id = cc.id
  RETURNING jsonb_build_object(
    'contract_id', c.id,
    'job_id', c.job_id,
    'scheduled_start_at', c.scheduled_start_at,
    'scheduled_end_at', c.scheduled_end_at
  ) INTO v_conflicts;

  -- Accept selected quote
  UPDATE public.quotes
  SET status = 'accepted',
      accepted_at = v_now
  WHERE id = p_quote_id;

  -- Decline other quotes
  UPDATE public.quotes
  SET status = 'declined',
      declined_at = v_now
  WHERE job_id = v_quote.job_id
    AND id <> p_quote_id
    AND status IN ('submitted');

  -- Update job status
  UPDATE public.jobs
  SET status = 'accepted',
      updated_at = v_now
  WHERE id = v_quote.job_id;

  -- Platform fee and total
  v_platform_fee_cents := 1500;
  v_total_cents := v_quote.price_cents + v_platform_fee_cents;

  -- Create contract (PENDING PAYMENT)
  INSERT INTO public.job_contracts (
    job_id,
    quote_id,
    customer_id,
    mechanic_id,
    status,
    scheduled_start_at,
    scheduled_end_at,
    quoted_price_cents,
    platform_fee_cents,
    mechanic_payout_cents,
    total_customer_cents,
    created_at,
    updated_at,
    payment_authorized_at,
    payment_captured_at
  ) VALUES (
    v_job.id,
    v_quote.id,
    p_customer_id,
    v_quote.mechanic_id,
    'pending_payment',
    v_quote.proposed_start_at,
    v_quote.proposed_end_at,
    v_quote.price_cents,
    v_platform_fee_cents,
    v_quote.price_cents,
    v_total_cents,
    v_now,
    v_now,
    NULL,
    NULL
  )
  RETURNING id INTO v_contract_id;

  -- Create invoice with base line items (kept from no-double-booking)
  INSERT INTO public.invoices (
    contract_id,
    job_id,
    customer_id,
    mechanic_id,
    status,
    subtotal_cents,
    platform_fee_cents,
    total_cents,
    created_at,
    updated_at
  ) VALUES (
    v_contract_id,
    v_job.id,
    p_customer_id,
    v_quote.mechanic_id,
    'draft',
    v_quote.price_cents,
    v_platform_fee_cents,
    v_total_cents,
    v_now,
    v_now
  );

  -- Add base labor line item
  INSERT INTO public.invoice_line_items (
    invoice_id,
    job_id,
    mechanic_id,
    item_type,
    description,
    quantity,
    unit_price_cents,
    total_price_cents,
    status,
    approved_at,
    created_at,
    updated_at
  )
  SELECT
    i.id,
    v_job.id,
    v_quote.mechanic_id,
    'labor'::public.line_item_type,
    coalesce(v_quote.notes, 'Labor'),
    1,
    v_quote.price_cents,
    v_quote.price_cents,
    'approved'::public.approval_status,
    v_now,
    v_now,
    v_now
  FROM public.invoices i
  WHERE i.contract_id = v_contract_id
  LIMIT 1;

  -- Add platform fee line item
  INSERT INTO public.invoice_line_items (
    invoice_id,
    job_id,
    mechanic_id,
    item_type,
    description,
    quantity,
    unit_price_cents,
    total_price_cents,
    status,
    approved_at,
    created_at,
    updated_at
  )
  SELECT
    i.id,
    v_job.id,
    v_quote.mechanic_id,
    'platform_fee'::public.line_item_type,
    'Platform fee',
    1,
    v_platform_fee_cents,
    v_platform_fee_cents,
    'approved'::public.approval_status,
    v_now,
    v_now,
    v_now
  FROM public.invoices i
  WHERE i.contract_id = v_contract_id
  LIMIT 1;

  -- Create job_progress row for tracking
  INSERT INTO public.job_progress (
    job_id,
    contract_id,
    stage,
    created_at,
    updated_at
  ) VALUES (
    v_job.id,
    v_contract_id,
    'accepted',
    v_now,
    v_now
  );

  -- Events
  PERFORM public.log_job_event(v_job.id, 'quote_accepted', jsonb_build_object(
    'quote_id', v_quote.id,
    'mechanic_id', v_quote.mechanic_id,
    'contract_id', v_contract_id
  ));

  PERFORM public.log_job_event(v_job.id, 'contract_created', jsonb_build_object(
    'contract_id', v_contract_id,
    'scheduled_start_at', v_quote.proposed_start_at,
    'scheduled_end_at', v_quote.proposed_end_at,
    'status', 'pending_payment'
  ));

  -- Notify mechanic (optional - kept)
  INSERT INTO public.notifications (
    user_id,
    title,
    body,
    data,
    created_at
  ) VALUES (
    v_quote.mechanic_id,
    'Job booked (payment pending)',
    'A customer booked your quote. Waiting for payment authorization.',
    jsonb_build_object(
      'job_id', v_job.id,
      'contract_id', v_contract_id
    ),
    v_now
  );

  RETURN jsonb_build_object(
    'success', true,
    'contract_id', v_contract_id,
    'job_id', v_job.id,
    'total_cents', v_total_cents,
    'platform_fee_cents', v_platform_fee_cents,
    'conflicts_resolved', coalesce(v_conflicts, '[]'::jsonb)
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.accept_quote_and_resolve_conflicts(uuid, uuid) TO authenticated;

-- Wrapper kept so existing app calls continue to work
CREATE OR REPLACE FUNCTION public.accept_quote_and_create_contract(
  p_quote_id uuid,
  p_customer_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN public.accept_quote_and_resolve_conflicts(p_quote_id, p_customer_id);
END;
$$;

GRANT EXECUTE ON FUNCTION public.accept_quote_and_create_contract(uuid, uuid) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260204000004_contract_pending_payment_on_quote_accept.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260204000004_payment_escrow_and_webhook_hardening.sql
-- ===================================================================\n
-- Payment escrow + webhook hardening
--
-- Goals:
-- 1) Make quote acceptance create a contract in `pending_payment`.
-- 2) Allow the customer (or an admin) to mark the contract payment as authorized once Stripe
--    returns an authorized PaymentIntent.
-- 3) Add a lightweight `stripe_webhook_events` table for idempotent webhook processing.

-- -----------------------------------------------------------------------------
-- Stripe webhook idempotency table
-- -----------------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS public.stripe_webhook_events (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  processed_at TIMESTAMPTZ,
  payload JSONB,
  error TEXT
);

ALTER TABLE public.stripe_webhook_events ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'stripe_webhook_events'
      AND policyname = 'Admins can read stripe webhook events'
  ) THEN
    CREATE POLICY "Admins can read stripe webhook events"
      ON public.stripe_webhook_events
      FOR SELECT
      TO authenticated
      USING (public.is_admin());
  END IF;
END$$;

-- -----------------------------------------------------------------------------
-- Quote acceptance should create `pending_payment` contracts
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION public.accept_quote_and_resolve_conflicts(
  p_quote_id uuid,
  p_customer_id uuid
) RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_quote record;
  v_job record;
  v_existing_contract record;
  v_contract_id uuid;
  v_platform_fee_cents integer;
  v_mechanic_commission_cents integer;
  v_mechanic_promo_discount_cents integer := 0;
  v_mechanic_promo record;
BEGIN
  -- Get quote with job info
  SELECT q.*, j.customer_id, j.status as job_status
  INTO v_quote
  FROM public.quotes q
  JOIN public.jobs j ON q.job_id = j.id
  WHERE q.id = p_quote_id
    AND j.customer_id = p_customer_id
    AND q.status = 'pending';

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote not found or not available');
  END IF;

  -- Check job is still open
  IF v_quote.job_status != 'open' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job is no longer open');
  END IF;

  -- Check for scheduling conflicts if quote has proposed times
  IF v_quote.proposed_start_at IS NOT NULL AND v_quote.proposed_end_at IS NOT NULL THEN
    IF public.check_mechanic_double_booking(
      v_quote.mechanic_id,
      v_quote.proposed_start_at,
      v_quote.proposed_end_at,
      NULL
    ) THEN
      RETURN jsonb_build_object('success', false, 'error', 'scheduled_conflict', 'message', 'Mechanic has a scheduling conflict');
    END IF;
  END IF;

  -- Resolve any existing contracts for this job
  SELECT * INTO v_existing_contract
  FROM public.job_contracts
  WHERE job_id = v_quote.job_id
    AND status IN ('pending_payment', 'active')
  LIMIT 1;

  IF FOUND THEN
    -- Cancel existing contract
    UPDATE public.job_contracts
    SET status = 'cancelled',
        cancellation_reason = 'customer_cancelled',
        cancelled_at = now(),
        cancelled_by = p_customer_id
    WHERE id = v_existing_contract.id;

    -- Cancel associated quote
    UPDATE public.quotes
    SET status = 'cancelled',
        cancelled_at = now()
    WHERE id = v_existing_contract.quote_id;
  END IF;

  -- Calculate fees
  v_platform_fee_cents := public.calculate_platform_fee(v_quote.price_cents);
  v_mechanic_commission_cents := public.calculate_mechanic_commission(v_quote.price_cents);

  -- Check for active mechanic promo and apply discount
  SELECT * INTO v_mechanic_promo
  FROM public.promotions
  WHERE mechanic_id = v_quote.mechanic_id
    AND status = 'active'
    AND promotion_type = 'mechanic_commission_discount'
    AND (expires_at IS NULL OR expires_at > now())
  ORDER BY created_at DESC
  LIMIT 1;

  IF FOUND AND v_mechanic_promo.discount_percentage IS NOT NULL THEN
    v_mechanic_promo_discount_cents := (v_mechanic_commission_cents * v_mechanic_promo.discount_percentage / 100);
    v_mechanic_commission_cents := GREATEST(0, v_mechanic_commission_cents - v_mechanic_promo_discount_cents);
  END IF;

  -- Create contract (PENDING PAYMENT)
  INSERT INTO public.job_contracts (
    job_id,
    quote_id,
    customer_id,
    mechanic_id,
    status,
    quoted_price_cents,
    platform_fee_cents,
    mechanic_commission_cents,
    mechanic_promo_discount_cents,
    mechanic_promo_id,
    subtotal_cents,
    total_customer_cents,
    mechanic_payout_cents,
    scheduled_start_at,
    scheduled_end_at
  ) VALUES (
    v_quote.job_id,
    v_quote.id,
    p_customer_id,
    v_quote.mechanic_id,
    'pending_payment',
    v_quote.price_cents,
    v_platform_fee_cents,
    v_mechanic_commission_cents,
    v_mechanic_promo_discount_cents,
    v_mechanic_promo.id,
    v_quote.price_cents,
    v_quote.price_cents + v_platform_fee_cents,
    v_quote.price_cents - v_mechanic_commission_cents,
    v_quote.proposed_start_at,
    v_quote.proposed_end_at
  ) RETURNING id INTO v_contract_id;

  -- Create initial invoice line item
  INSERT INTO public.invoice_line_items (
    contract_id,
    job_id,
    mechanic_id,
    item_type,
    description,
    quantity,
    unit_price_cents,
    total_cents,
    status
  ) VALUES (
    v_contract_id,
    v_quote.job_id,
    v_quote.mechanic_id,
    'labor',
    v_quote.description,
    1,
    v_quote.price_cents,
    v_quote.price_cents,
    'approved'
  );

  -- Update quote status
  UPDATE public.quotes
  SET status = 'accepted',
      accepted_at = now()
  WHERE id = v_quote.id;

  -- Update job status
  UPDATE public.jobs
  SET status = 'accepted',
      accepted_quote_id = v_quote.id,
      mechanic_id = v_quote.mechanic_id,
      updated_at = now()
  WHERE id = v_quote.job_id;

  -- Create job event
  INSERT INTO public.job_events (
    job_id,
    contract_id,
    event_type,
    actor_id,
    actor_role,
    metadata
  ) VALUES (
    v_quote.job_id,
    v_contract_id,
    'quote_accepted',
    p_customer_id,
    'customer',
    jsonb_build_object(
      'quote_id', v_quote.id,
      'price_cents', v_quote.price_cents,
      'scheduled_start_at', v_quote.proposed_start_at,
      'scheduled_end_at', v_quote.proposed_end_at
    )
  );

  RETURN jsonb_build_object(
    'success', true,
    'contract_id', v_contract_id,
    'message', 'Quote accepted and contract created (pending payment)'
  );

EXCEPTION
  WHEN OTHERS THEN
    RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;

-- -----------------------------------------------------------------------------
-- Payment authorization marker (customer-owned)
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION public.authorize_contract_payment(
  p_contract_id uuid,
  p_stripe_payment_intent_id text
) RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_contract public.job_contracts%ROWTYPE;
  v_user_id uuid;
BEGIN
  v_user_id := auth.uid();

  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT * INTO v_contract
  FROM public.job_contracts
  WHERE id = p_contract_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN false;
  END IF;

  -- Only the owning customer (or an admin) can authorize
  IF v_contract.customer_id <> v_user_id AND NOT public.is_admin() THEN
    RAISE EXCEPTION 'Not authorized';
  END IF;

  -- Contract must be awaiting payment or already active but not yet authorized
  IF v_contract.status NOT IN ('pending_payment', 'active') THEN
    RAISE EXCEPTION 'Contract not eligible for payment authorization';
  END IF;

  -- Idempotency / safety: if already authorized, treat as success
  IF v_contract.payment_authorized_at IS NOT NULL THEN
    RETURN true;
  END IF;

  -- If stripe PI already set, ensure it matches
  IF v_contract.stripe_payment_intent_id IS NOT NULL AND v_contract.stripe_payment_intent_id <> p_stripe_payment_intent_id THEN
    RAISE EXCEPTION 'Stripe payment intent mismatch';
  END IF;

  UPDATE public.job_contracts
  SET stripe_payment_intent_id = COALESCE(stripe_payment_intent_id, p_stripe_payment_intent_id),
      payment_authorized_at = now(),
      status = 'active',
      updated_at = now()
  WHERE id = p_contract_id;

  RETURN true;
END;
$$;

GRANT EXECUTE ON FUNCTION public.authorize_contract_payment(uuid, text) TO authenticated;

\n-- ===================================================================
-- END: 20260204000004_payment_escrow_and_webhook_hardening.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260204000005_fix_jobs_location_and_hub_assignment.sql
-- ===================================================================\n
-- =====================================================
-- Fix: jobs location columns vs. service area enforcement
-- =====================================================
--
-- Why
-- - The app writes jobs.location_lat/location_lng.
-- - Service-area enforcement + hub assignment were using jobs.job_lat/job_lng.
-- - If job_lat/job_lng are NULL, the INSERT policy allowed the row (bypassing service area)
--   and the hub assignment trigger never set jobs.hub_id.
--
-- This migration makes the system resilient by:
-- - Keeping jobs.job_lat/job_lng in sync with location_lat/location_lng
-- - Assigning hub_id using whichever coordinate set is present
-- - Enforcing service area using whichever coordinate set is present

BEGIN;

-- -----------------------------------------------------
-- 1) Make hub assignment robust to either coordinate set
-- -----------------------------------------------------
CREATE OR REPLACE FUNCTION public.assign_job_to_hub()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_lat double precision;
  v_lng double precision;
  v_hub_id uuid;
BEGIN
  -- Prefer explicit job_lat/job_lng, but fall back to location_lat/location_lng.
  v_lat := COALESCE(NEW.job_lat::double precision, NEW.location_lat);
  v_lng := COALESCE(NEW.job_lng::double precision, NEW.location_lng);

  -- Keep the columns in sync for downstream policies/functions.
  IF v_lat IS NOT NULL THEN
    NEW.job_lat := v_lat;
  END IF;
  IF v_lng IS NOT NULL THEN
    NEW.job_lng := v_lng;
  END IF;

  -- If we still don't have coords, don't assign.
  IF v_lat IS NULL OR v_lng IS NULL THEN
    RETURN NEW;
  END IF;

  SELECT h.id
    INTO v_hub_id
  FROM public.service_hubs h
  WHERE h.is_active = true
  ORDER BY ST_Distance(
    h.location,
    ST_SetSRID(ST_MakePoint(v_lng, v_lat), 4326)::extensions.geography
  )
  LIMIT 1;

  NEW.hub_id := v_hub_id;
  RETURN NEW;
END;
$$;

-- Ensure the trigger runs when the app-updated columns change.
DROP TRIGGER IF EXISTS trg_assign_job_hub ON public.jobs;
CREATE TRIGGER trg_assign_job_hub
  BEFORE INSERT OR UPDATE OF job_lat, job_lng, location_lat, location_lng
  ON public.jobs
  FOR EACH ROW
  EXECUTE FUNCTION public.assign_job_to_hub();

-- -----------------------------------------------------
-- 2) Tighten INSERT policy to use either coordinate set
-- -----------------------------------------------------
DROP POLICY IF EXISTS "Jobs must be in service area" ON public.jobs;
CREATE POLICY "Jobs must be in service area" ON public.jobs
  FOR INSERT
  WITH CHECK (
    COALESCE(job_lat::double precision, location_lat) IS NULL OR
    COALESCE(job_lng::double precision, location_lng) IS NULL OR
    EXISTS (
      SELECT 1
      FROM public.service_hubs h
      WHERE h.is_active = true
        AND ST_DWithin(
          ST_SetSRID(
            ST_MakePoint(
              COALESCE(job_lng::double precision, location_lng),
              COALESCE(job_lat::double precision, location_lat)
            ),
            4326
          )::extensions.geography,
          h.location,
          h.active_radius_miles * 1609.34
        )
    )
  );

-- -----------------------------------------------------
-- 3) Backfill existing data (safe, idempotent)
-- -----------------------------------------------------
UPDATE public.jobs
SET
  job_lat = COALESCE(job_lat, location_lat),
  job_lng = COALESCE(job_lng, location_lng)
WHERE
  (job_lat IS NULL AND location_lat IS NOT NULL)
  OR (job_lng IS NULL AND location_lng IS NOT NULL);

UPDATE public.jobs j
SET hub_id = sub.hub_id
FROM (
  SELECT
    j2.id AS job_id,
    (
      SELECT h.id
      FROM public.service_hubs h
      WHERE h.is_active = true
      ORDER BY ST_Distance(
        h.location,
        ST_SetSRID(
          ST_MakePoint(
            COALESCE(j2.job_lng::double precision, j2.location_lng),
            COALESCE(j2.job_lat::double precision, j2.location_lat)
          ),
          4326
        )::extensions.geography
      )
      LIMIT 1
    ) AS hub_id
  FROM public.jobs j2
  WHERE j2.hub_id IS NULL
    AND COALESCE(j2.job_lat::double precision, j2.location_lat) IS NOT NULL
    AND COALESCE(j2.job_lng::double precision, j2.location_lng) IS NOT NULL
) sub
WHERE j.id = sub.job_id;

COMMIT;
\n-- ===================================================================
-- END: 20260204000005_fix_jobs_location_and_hub_assignment.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260204000015_public_hub_stats.sql
-- ===================================================================\n
-- Public hub stats (counts) for customer/mechanic UX.
--
-- Goal:
-- - Let authenticated users see *aggregated* demand/supply per hub without exposing mechanic locations.
-- - Keep it fast and RLS-safe (security definer + aggregation only).

BEGIN;

CREATE OR REPLACE FUNCTION public.get_hub_public_stats(p_only_active boolean DEFAULT true)
RETURNS TABLE(
  id uuid,
  name text,
  slug text,
  zip text,
  city text,
  state text,
  lat numeric,
  lng numeric,
  active_radius_miles integer,
  max_radius_miles integer,
  invite_only boolean,
  auto_expand_enabled boolean,
  is_active boolean,
  mechanic_count bigint,
  customer_count bigint
)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT
    h.id,
    h.name,
    h.slug,
    h.zip,
    h.city,
    h.state,
    h.lat,
    h.lng,
    h.active_radius_miles,
    h.max_radius_miles,
    h.invite_only,
    h.auto_expand_enabled,
    h.is_active,
    COUNT(p.id) FILTER (WHERE p.role::text = 'mechanic' AND p.deleted_at IS NULL) AS mechanic_count,
    COUNT(p.id) FILTER (WHERE p.role::text = 'customer' AND p.deleted_at IS NULL) AS customer_count
  FROM public.service_hubs h
  LEFT JOIN public.profiles p
    ON p.hub_id = h.id
   AND p.role IS NOT NULL
   AND p.deleted_at IS NULL
  WHERE (NOT p_only_active) OR (h.is_active = true)
  GROUP BY h.id
  ORDER BY h.name;
$$;

-- Allow normal app clients to call this.
GRANT EXECUTE ON FUNCTION public.get_hub_public_stats(boolean) TO authenticated;

COMMIT;
\n-- ===================================================================
-- END: 20260204000015_public_hub_stats.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260205000001_public_hubs_rpc.sql
-- ===================================================================\n
-- Public hub map/feed (safe for customers & mechanics)
-- Returns hub center + radii + aggregated counts (no mechanic locations)

create or replace function public.get_hubs_public()
returns table(
  id uuid,
  name text,
  slug text,
  zip character varying,
  lat numeric,
  lng numeric,
  active_radius_miles integer,
  max_radius_miles integer,
  invite_only boolean,
  auto_expand_enabled boolean,
  is_active boolean,
  launch_date date,
  active_mechanics bigint,
  active_customers bigint,
  jobs_last_14d bigint
)
language sql
stable
security definer
set search_path = public
as $$
  select
    h.id,
    h.name,
    h.slug,
    h.zip,
    h.lat,
    h.lng,
    h.active_radius_miles,
    h.max_radius_miles,
    h.invite_only,
    h.auto_expand_enabled,
    h.is_active,
    h.launch_date,
    (
      select count(*)
      from public.mechanic_profiles mp
      join public.profiles p on p.id = mp.id
      where p.hub_id = h.id
        and p.deleted_at is null
        and mp.deleted_at is null
        and mp.is_available = true
        and mp.verification_status = 'active'
    ) as active_mechanics,
    (
      select count(*)
      from public.profiles p
      where p.hub_id = h.id
        and p.deleted_at is null
        and p.role = 'customer'
    ) as active_customers,
    (
      select count(*)
      from public.jobs j
      where j.hub_id = h.id
        and j.created_at >= (now() - interval '14 days')
    ) as jobs_last_14d
  from public.service_hubs h
  where h.is_active = true
  order by h.name asc;
$$;

grant execute on function public.get_hubs_public() to authenticated;
\n-- ===================================================================
-- END: 20260205000001_public_hubs_rpc.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260205000002_waitlist_rls_hardening.sql
-- ===================================================================\n
-- Waitlist contains personal data (email/phone). Lock it down.

alter table public.waitlist enable row level security;

-- Anyone can join the waitlist (anonymous or authenticated)
drop policy if exists waitlist_insert_any on public.waitlist;
create policy waitlist_insert_any
on public.waitlist
for insert
to anon, authenticated
with check (true);

-- Only the owning user (by email) or admins can view their waitlist row.
drop policy if exists waitlist_select_own on public.waitlist;
create policy waitlist_select_own
on public.waitlist
for select
to authenticated
using (
  public.is_admin()
  or (auth.email() is not null and auth.email() = email)
);

-- Admins can update/close waitlist rows.
drop policy if exists waitlist_admin_update on public.waitlist;
create policy waitlist_admin_update
on public.waitlist
for update
to authenticated
using (public.is_admin())
with check (public.is_admin());

drop policy if exists waitlist_admin_delete on public.waitlist;
create policy waitlist_admin_delete
on public.waitlist
for delete
to authenticated
using (public.is_admin());

-- Tighten grants (RLS still applies)
revoke all on table public.waitlist from anon, authenticated;
grant insert on table public.waitlist to anon, authenticated;
grant select, update, delete on table public.waitlist to authenticated;
\n-- ===================================================================
-- END: 20260205000002_waitlist_rls_hardening.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260205000003_vehicle_rls_mechanic_admin_select.sql
-- ===================================================================\n
-- Allow mechanics to read vehicle details for leads / jobs they can see.
-- This enables quoting and job execution without exposing the entire vehicles table to customers.

-- Admins can see all vehicles.
drop policy if exists vehicles_admin_select on public.vehicles;
create policy vehicles_admin_select
on public.vehicles
for select
to authenticated
using (public.is_admin());

-- Mechanics can see vehicles for:
--  - open leads (jobs in searching/quoted) so they can quote accurately, and
--  - any job they are the accepted mechanic on.
drop policy if exists vehicles_mechanic_select_for_job on public.vehicles;
create policy vehicles_mechanic_select_for_job
on public.vehicles
for select
to authenticated
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'mechanic'
  )
  and exists (
    select 1
    from public.jobs j
    where j.vehicle_id = vehicles.id
      and (
        j.accepted_mechanic_id = auth.uid()
        or j.status in ('searching', 'quoted')
      )
  )
);
\n-- ===================================================================
-- END: 20260205000003_vehicle_rls_mechanic_admin_select.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260205000004_mechanic_customer_notes.sql
-- ===================================================================\n
-- Mechanic-only notes about customers/vehicles (CRM-style)

create table if not exists public.mechanic_customer_notes (
  id uuid primary key default gen_random_uuid(),
  mechanic_id uuid not null references public.profiles(id) on delete cascade,
  customer_id uuid not null references public.profiles(id) on delete cascade,
  vehicle_id uuid null references public.vehicles(id) on delete set null,
  note text not null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  deleted_at timestamp with time zone null
);

create index if not exists mechanic_customer_notes_mech_customer_idx
  on public.mechanic_customer_notes (mechanic_id, customer_id, created_at desc);

-- Keep updated_at current
drop trigger if exists set_updated_at on public.mechanic_customer_notes;
create trigger set_updated_at
before update on public.mechanic_customer_notes
for each row execute function public.update_updated_at_column();

alter table public.mechanic_customer_notes enable row level security;

drop policy if exists mechanic_customer_notes_mechanic_crud on public.mechanic_customer_notes;
create policy mechanic_customer_notes_mechanic_crud
on public.mechanic_customer_notes
for all
to authenticated
using (mechanic_id = auth.uid())
with check (mechanic_id = auth.uid());

drop policy if exists mechanic_customer_notes_admin_select on public.mechanic_customer_notes;
create policy mechanic_customer_notes_admin_select
on public.mechanic_customer_notes
for select
to authenticated
using (public.is_admin());

grant select, insert, update, delete on public.mechanic_customer_notes to authenticated;
\n-- ===================================================================
-- END: 20260205000004_mechanic_customer_notes.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260301000001_fix_set_my_service_area_home_lat.sql
-- ===================================================================\n
-- Fix: keep legacy home_lat/home_lng columns in sync with service_lat/service_lng.
-- Many policies/functions (incl. check_user_service_area) still reference home_*.
-- Also: align the RPC signature with the client (optional p_user_type).

DO $$ BEGIN
  -- Drop older overload to avoid PostgREST ambiguity.
  IF EXISTS (
    SELECT 1
    FROM pg_proc p
    JOIN pg_namespace n ON n.oid = p.pronamespace
    WHERE n.nspname = 'public'
      AND p.proname = 'set_my_service_area'
      AND pg_get_function_identity_arguments(p.oid) = 'p_zip text, p_lat double precision, p_lng double precision'
  ) THEN
    EXECUTE 'DROP FUNCTION public.set_my_service_area(text, double precision, double precision)';
  END IF;
END $$;

CREATE OR REPLACE FUNCTION public.set_my_service_area(
  p_zip text,
  p_lat double precision,
  p_lng double precision,
  p_user_type text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_user_role user_role;
  v_email text;
  v_hub_id uuid;
  v_hub_name text;
  v_hub_location geography;
  v_active_radius_miles integer;
  v_max_radius_miles integer;
  v_distance_miles numeric;
  v_in_range boolean;
  v_waitlist_id uuid;
  v_effective_user_type text;
BEGIN
  v_user_id := auth.uid();

  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  -- Get user's role and email
  SELECT role, email INTO v_user_role, v_email
  FROM public.profiles
  WHERE id = v_user_id;

  IF v_user_role IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User role not set');
  END IF;

  -- Find nearest hub (even if out of active radius)
  SELECT id, name, location, active_radius_miles, max_radius_miles
  INTO v_hub_id, v_hub_name, v_hub_location, v_active_radius_miles, v_max_radius_miles
  FROM public.service_hubs
  WHERE is_active = true
  ORDER BY location <-> ST_SetSRID(ST_MakePoint(p_lng, p_lat), 4326)::extensions.geography
  LIMIT 1;

  IF v_hub_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'No active service hubs found');
  END IF;

  -- Calculate distance in miles
  v_distance_miles := ST_Distance(
    v_hub_location,
    ST_SetSRID(ST_MakePoint(p_lng, p_lat), 4326)::extensions.geography
  ) / 1609.34;

  -- Consider in-range if within active radius
  v_in_range := v_distance_miles <= v_active_radius_miles;

  -- Normalize user_type used by waitlist rows
  v_effective_user_type := COALESCE(NULLIF(trim(p_user_type), ''), CASE WHEN v_user_role = 'mechanic' THEN 'mechanic' ELSE 'customer' END);

  -- Update profile with BOTH home_* and service_* coordinates.
  UPDATE public.profiles
  SET
    service_zip = p_zip,
    hub_id = v_hub_id,
    home_lat = p_lat,
    home_lng = p_lng,
    service_lat = p_lat,
    service_lng = p_lng,
    service_location = ST_SetSRID(ST_MakePoint(p_lng, p_lat), 4326)::extensions.geography,
    updated_at = now()
  WHERE id = v_user_id;

  -- If out of range, create/update waitlist entry
  IF NOT v_in_range THEN
    INSERT INTO public.waitlist (
      email,
      user_type,
      zip,
      status,
      hub_id,
      created_at,
      updated_at
    ) VALUES (
      v_email,
      v_effective_user_type,
      p_zip,
      'waiting',
      v_hub_id,
      now(),
      now()
    )
    ON CONFLICT (email)
    DO UPDATE SET
      user_type = EXCLUDED.user_type,
      zip = EXCLUDED.zip,
      status = 'waiting',
      hub_id = EXCLUDED.hub_id,
      updated_at = now()
    RETURNING id INTO v_waitlist_id;
  ELSE
    -- If in range, mark any waitlist entry as converted/active
    UPDATE public.waitlist
    SET
      status = 'active',
      converted_at = COALESCE(converted_at, now()),
      updated_at = now()
    WHERE email = v_email;
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'hub_id', v_hub_id,
    'hub_name', v_hub_name,
    'distance_miles', v_distance_miles,
    'in_range', v_in_range,
    'waitlist_id', v_waitlist_id
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.set_my_service_area(text, double precision, double precision, text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.set_my_service_area(text, double precision, double precision, text) TO service_role;
\n-- ===================================================================
-- END: 20260301000001_fix_set_my_service_area_home_lat.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260301000002_mechanic_notes_and_media_geo.sql
-- ===================================================================\n
-- Mechanic notes + geo-tagged job media (optional)

-- 1) Mechanic notes (per job/customer/vehicle) for CRM-like history
CREATE TABLE IF NOT EXISTS public.mechanic_notes (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  mechanic_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  customer_id uuid NULL REFERENCES public.profiles(id) ON DELETE SET NULL,
  vehicle_id uuid NULL REFERENCES public.vehicles(id) ON DELETE SET NULL,
  job_id uuid NULL REFERENCES public.jobs(id) ON DELETE SET NULL,
  note text NOT NULL,
  is_private boolean NOT NULL DEFAULT true,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  deleted_at timestamp with time zone NULL,
  metadata jsonb NOT NULL DEFAULT '{}'::jsonb
);

ALTER TABLE public.mechanic_notes ENABLE ROW LEVEL SECURITY;

-- Mechanics can CRUD their own notes
DROP POLICY IF EXISTS "Mechanics can read own notes" ON public.mechanic_notes;
CREATE POLICY "Mechanics can read own notes" ON public.mechanic_notes
FOR SELECT
USING (mechanic_id = auth.uid() OR public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Mechanics can insert own notes" ON public.mechanic_notes;
CREATE POLICY "Mechanics can insert own notes" ON public.mechanic_notes
FOR INSERT
WITH CHECK (
  mechanic_id = auth.uid()
  AND (public.is_admin(auth.uid()) OR true)
);

DROP POLICY IF EXISTS "Mechanics can update own notes" ON public.mechanic_notes;
CREATE POLICY "Mechanics can update own notes" ON public.mechanic_notes
FOR UPDATE
USING (mechanic_id = auth.uid() OR public.is_admin(auth.uid()))
WITH CHECK (mechanic_id = auth.uid() OR public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Mechanics can delete own notes" ON public.mechanic_notes;
CREATE POLICY "Mechanics can delete own notes" ON public.mechanic_notes
FOR DELETE
USING (mechanic_id = auth.uid() OR public.is_admin(auth.uid()));

-- Keep updated_at fresh
DROP TRIGGER IF EXISTS set_updated_at ON public.mechanic_notes;
CREATE TRIGGER set_updated_at
BEFORE UPDATE ON public.mechanic_notes
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();

GRANT SELECT, INSERT, UPDATE, DELETE ON public.mechanic_notes TO authenticated;

-- 2) Optional geo-tagging on job_media
ALTER TABLE public.job_media
  ADD COLUMN IF NOT EXISTS taken_lat double precision,
  ADD COLUMN IF NOT EXISTS taken_lng double precision;

-- 3) Update create_job_media_record to accept optional lat/lng (defaults NULL)
DROP FUNCTION IF EXISTS public.create_job_media_record(
  p_job_id uuid,
  p_media_category text,
  p_path text,
  p_mime_type text,
  p_file_size_bytes int,
  p_contract_id uuid,
  p_caption text,
  p_taken_at timestamptz
);

CREATE OR REPLACE FUNCTION public.create_job_media_record(
  p_job_id uuid,
  p_media_category text,
  p_path text,
  p_mime_type text,
  p_file_size_bytes int,
  p_contract_id uuid DEFAULT NULL,
  p_caption text DEFAULT NULL,
  p_taken_at timestamptz DEFAULT now(),
  p_taken_lat double precision DEFAULT NULL,
  p_taken_lng double precision DEFAULT NULL
)
RETURNS public.job_media
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id uuid;
  v_user_role public.user_role;
  v_result public.job_media;
  v_title text;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT role INTO v_user_role FROM public.profiles WHERE id = v_user_id;

  IF v_user_role = 'admin' THEN
    NULL;
  ELSIF v_user_role = 'customer' THEN
    IF NOT EXISTS (SELECT 1 FROM public.jobs WHERE id = p_job_id AND customer_id = v_user_id) THEN
      RAISE EXCEPTION 'Not authorized to upload to this job';
    END IF;
  ELSIF v_user_role = 'mechanic' THEN
    IF NOT EXISTS (
      SELECT 1 FROM public.job_contracts
      WHERE job_id = p_job_id AND mechanic_id = v_user_id
    ) THEN
      RAISE EXCEPTION 'Not authorized to upload to this job';
    END IF;
  ELSE
    RAISE EXCEPTION 'Not authorized';
  END IF;

  INSERT INTO public.job_media (
    job_id, contract_id, uploaded_by, uploaded_by_role, media_type,
    media_category, bucket, path, caption, file_size_bytes, mime_type, taken_at,
    taken_lat, taken_lng
  ) VALUES (
    p_job_id, p_contract_id, v_user_id, v_user_role, 'image',
    p_media_category, 'job-media', p_path, p_caption, p_file_size_bytes, p_mime_type, p_taken_at,
    p_taken_lat, p_taken_lng
  )
  RETURNING * INTO v_result;

  v_title := CASE p_media_category
    WHEN 'customer_initial' THEN 'Customer uploaded initial photo'
    WHEN 'mechanic_before' THEN 'Mechanic uploaded before photo'
    WHEN 'mechanic_after' THEN 'Mechanic uploaded after photo'
    WHEN 'mechanic_diagnostic' THEN 'Mechanic uploaded diagnostic photo'
    WHEN 'customer_evidence' THEN 'Customer uploaded evidence'
    WHEN 'mechanic_evidence' THEN 'Mechanic uploaded evidence'
    ELSE 'Photo uploaded'
  END;

  INSERT INTO public.job_events (
    job_id, contract_id, event_type, actor_id, actor_role, title, metadata
  ) VALUES (
    p_job_id, p_contract_id, 'media_uploaded', v_user_id, v_user_role, v_title,
    jsonb_build_object(
      'media_id', v_result.id,
      'category', p_media_category,
      'role', v_user_role::text,
      'lat', p_taken_lat,
      'lng', p_taken_lng
    )
  );

  RETURN v_result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.create_job_media_record(
  uuid, text, text, text, int, uuid, text, timestamptz, double precision, double precision
) TO authenticated;

COMMENT ON FUNCTION public.create_job_media_record(uuid, text, text, text, int, uuid, text, timestamptz, double precision, double precision)
IS 'Creates a job_media record with optional geo-tagged capture location.';
\n-- ===================================================================
-- END: 20260301000002_mechanic_notes_and_media_geo.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260301000002_waitlist_rls.sql
-- ===================================================================\n
-- Enable RLS on waitlist and lock down read access.
--
-- Why:
-- - The app uses the waitlist table both for pre-auth "join the waitlist" and
--   for authenticated users who are out of service area.
-- - We should not allow authenticated users to read the full waitlist.

begin;

alter table public.waitlist enable row level security;

-- Allow anyone (anon/authenticated) to join the waitlist.
-- (The table is still protected from broad reads.)
drop policy if exists "Waitlist public insert" on public.waitlist;
create policy "Waitlist public insert"
  on public.waitlist
  for insert
  to anon, authenticated
  with check (
    email is not null
  );

-- Authenticated users can read only their own waitlist row (matched by email).
drop policy if exists "Waitlist self select" on public.waitlist;
create policy "Waitlist self select"
  on public.waitlist
  for select
  to authenticated
  using (
    email = auth.email()
  );

-- Admins can read/update all rows.
drop policy if exists "Waitlist admin all" on public.waitlist;
create policy "Waitlist admin all"
  on public.waitlist
  for all
  to authenticated
  using (
    public.is_admin()
  )
  with check (
    public.is_admin()
  );

commit;
\n-- ===================================================================
-- END: 20260301000002_waitlist_rls.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260301000003_public_hub_stats.sql
-- ===================================================================\n
-- Public hub summary (safe aggregated counts).
--
-- Used by customer / mechanic UI to show hub coverage and market size
-- WITHOUT exposing individual mechanic locations.

begin;

create or replace function public.list_hubs_public()
returns table(
  id uuid,
  name text,
  slug text,
  zip text,
  city text,
  state text,
  lat numeric,
  lng numeric,
  active_radius_miles integer,
  max_radius_miles integer,
  is_active boolean,
  mechanic_count bigint,
  customer_count bigint,
  open_jobs bigint
)
language plpgsql
security definer
set search_path = public
as $$
begin
  return query
  select
    h.id,
    h.name,
    h.slug,
    h.zip,
    h.city,
    h.state,
    h.lat,
    h.lng,
    h.active_radius_miles,
    h.max_radius_miles,
    h.is_active,
    (
      select count(*)
      from public.mechanic_profiles mp
      join public.profiles p on p.id = mp.id
      where p.hub_id = h.id
        and p.role = 'mechanic'
        and p.deleted_at is null
        and mp.deleted_at is null
        and mp.verification_status = 'active'
        and coalesce(mp.is_available, false) = true
    ) as mechanic_count,
    (
      select count(*)
      from public.profiles p
      where p.hub_id = h.id
        and p.role = 'customer'
        and p.deleted_at is null
    ) as customer_count,
    (
      select count(*)
      from public.jobs j
      where j.hub_id = h.id
        and j.deleted_at is null
        and j.status in ('searching','quoted','accepted','scheduled','in_progress','work_in_progress')
    ) as open_jobs
  from public.service_hubs h
  where h.is_active = true;
end;
$$;

grant execute on function public.list_hubs_public() to anon, authenticated;

commit;
\n-- ===================================================================
-- END: 20260301000003_public_hub_stats.sql
-- ===================================================================\n

\n\n-- ===================================================================
-- BEGIN: 20260302000001_quote_proposed_time_support.sql
-- ===================================================================\n
-- Adds support for storing a mechanic's proposed arrival window on the quote itself.
-- The UI already collects arrival date/time + duration; this migration makes the RPC persist it.

BEGIN;

CREATE OR REPLACE FUNCTION public.submit_quote_with_payment_check(
  p_job_id uuid,
  p_price_cents integer,
  p_estimated_hours numeric DEFAULT NULL,
  p_notes text DEFAULT NULL,
  p_proposed_start_at timestamptz DEFAULT NULL,
  p_duration_minutes integer DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_mechanic_id uuid;
  v_job record;
  v_mechanic record;
  v_quote_id uuid;
  v_start_at timestamptz;
  v_end_at timestamptz;
  v_duration_minutes integer;
BEGIN
  -- Only authenticated mechanics can submit quotes
  v_mechanic_id := auth.uid();
  IF v_mechanic_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Job must exist
  SELECT * INTO v_job
  FROM public.jobs
  WHERE id = p_job_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job not found');
  END IF;

  -- Quote can only be submitted while the job is open for quoting
  IF v_job.status NOT IN ('open', 'awaiting_quotes') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Job is not open for quotes');
  END IF;

  -- Mechanic must exist + be allowed to quote
  SELECT * INTO v_mechanic
  FROM public.mechanic_profiles
  WHERE id = v_mechanic_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Mechanic profile not found');
  END IF;

  IF v_mechanic.verification_status IS DISTINCT FROM 'verified' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Your account must be verified before you can submit quotes');
  END IF;

  IF COALESCE(v_mechanic.is_available, false) IS NOT TRUE THEN
    RETURN jsonb_build_object('success', false, 'error', 'You are not currently marked as available');
  END IF;

  -- If the mechanic has a max quote override, enforce it
  IF v_mechanic.max_quote_cents IS NOT NULL AND p_price_cents > v_mechanic.max_quote_cents THEN
    RETURN jsonb_build_object('success', false, 'error', 'Quote amount exceeds your current max quote limit');
  END IF;

  -- Prevent quoting on jobs outside the mechanic's service area
  IF NOT public.check_mechanic_service_area(v_mechanic_id) THEN
    RETURN jsonb_build_object('success', false, 'error', 'You are outside the service area for this job');
  END IF;

  -- Determine the proposed time window.
  -- If the UI sends a proposed start + duration, we persist those. Otherwise:
  -- fall back to the job's scheduled_at/estimated_duration_minutes, or "now".
  v_start_at := COALESCE(p_proposed_start_at, v_job.scheduled_at, now());
  v_duration_minutes := COALESCE(p_duration_minutes, v_job.estimated_duration_minutes, 90);

  IF v_duration_minutes < 15 THEN
    v_duration_minutes := 15;
  END IF;

  v_end_at := v_start_at + make_interval(mins => v_duration_minutes);

  -- Upsert quote for this mechanic/job. (Unique constraint assumed on (job_id, mechanic_id))
  INSERT INTO public.quotes (
    job_id,
    mechanic_id,
    price_cents,
    estimated_hours,
    notes,
    status,
    proposed_start_at,
    proposed_end_at
  ) VALUES (
    p_job_id,
    v_mechanic_id,
    p_price_cents,
    p_estimated_hours,
    p_notes,
    'submitted',
    v_start_at,
    v_end_at
  )
  ON CONFLICT (job_id, mechanic_id)
  DO UPDATE SET
    price_cents = EXCLUDED.price_cents,
    estimated_hours = EXCLUDED.estimated_hours,
    notes = EXCLUDED.notes,
    status = 'submitted',
    proposed_start_at = EXCLUDED.proposed_start_at,
    proposed_end_at = EXCLUDED.proposed_end_at,
    updated_at = now()
  RETURNING id INTO v_quote_id;

  -- Mark job as awaiting quotes (but do not overwrite if it is already in a later state)
  UPDATE public.jobs
  SET status = CASE WHEN status = 'open' THEN 'awaiting_quotes' ELSE status END,
      updated_at = now()
  WHERE id = p_job_id;

  RETURN jsonb_build_object(
    'success', true,
    'quote_id', v_quote_id,
    'proposed_start_at', v_start_at,
    'proposed_end_at', v_end_at
  );
END;
$$;

COMMIT;
\n-- ===================================================================
-- END: 20260302000001_quote_proposed_time_support.sql
-- ===================================================================\n

\n\n-- =============================================================
-- BEGIN: 20260301000003_admin_resolve_dispute_signature.sql
-- =============================================================\n
-- Align admin_resolve_dispute signature with the admin UI and keep the mechanic_adjustment_cents field.

DO $$ BEGIN
  -- Drop older overload(s) so PostgREST RPC calls are unambiguous
  BEGIN
    DROP FUNCTION IF EXISTS public.admin_resolve_dispute(uuid, public.dispute_status, text, text, integer);
  EXCEPTION WHEN undefined_function THEN
    NULL;
  END;
  BEGIN
    DROP FUNCTION IF EXISTS public.admin_resolve_dispute(uuid, text, text, integer, integer);
  EXCEPTION WHEN undefined_function THEN
    NULL;
  END;
END $$;

CREATE OR REPLACE FUNCTION public.admin_resolve_dispute(
  p_dispute_id uuid,
  p_status public.dispute_status,
  p_resolution_type text DEFAULT NULL,
  p_resolution_notes text DEFAULT NULL,
  p_customer_refund_cents integer DEFAULT NULL,
  p_mechanic_adjustment_cents integer DEFAULT 0
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id uuid;
  v_dispute record;
BEGIN
  v_admin_id := auth.uid();
  IF v_admin_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  IF NOT public.is_admin(v_admin_id) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;

  SELECT * INTO v_dispute FROM public.disputes WHERE id = p_dispute_id;
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Dispute not found');
  END IF;

  UPDATE public.disputes
  SET
    status = p_status,
    resolution_type = p_resolution_type,
    resolution_notes = p_resolution_notes,
    customer_refund_cents = COALESCE(p_customer_refund_cents, customer_refund_cents),
    mechanic_adjustment_cents = p_mechanic_adjustment_cents,
    resolved_at = CASE
      WHEN p_status IN ('resolved_customer','resolved_mechanic','resolved_split','closed') THEN COALESCE(resolved_at, now())
      ELSE resolved_at
    END,
    updated_at = now()
  WHERE id = p_dispute_id;

  INSERT INTO public.dispute_events (dispute_id, actor_id, actor_type, event_type, metadata)
  VALUES (
    p_dispute_id,
    v_admin_id,
    'admin',
    'resolved',
    jsonb_build_object(
      'status', p_status,
      'resolution_type', p_resolution_type,
      'customer_refund_cents', p_customer_refund_cents,
      'mechanic_adjustment_cents', p_mechanic_adjustment_cents
    )
  );

  RETURN jsonb_build_object('success', true);
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_resolve_dispute(uuid, public.dispute_status, text, text, integer, integer) TO authenticated, service_role;
REVOKE ALL ON FUNCTION public.admin_resolve_dispute(uuid, public.dispute_status, text, text, integer, integer) FROM anon;
\n\n-- =============================================================
-- END: 20260301000003_admin_resolve_dispute_signature.sql
-- =============================================================\n
